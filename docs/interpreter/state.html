<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scrolls.interpreter.state API documentation</title>
<meta name="description" content="Implementation of interpreter state. Variables, open files, call stack, etc." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrolls.interpreter.state</code></h1>
</header>
<section id="section-intro">
<p>Implementation of interpreter state. Variables, open files, call stack, etc.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Implementation of interpreter state. Variables, open files, call stack, etc.
&#34;&#34;&#34;

import logging
import math
import pathlib
import typing as t

from .. import ast
from . import callhandler, interpreter_errors, struct

if t.TYPE_CHECKING:
    from . import run

__all__ = (
    &#34;InterpreterContext&#34;,
)


logger = logging.getLogger(__name__)
T = t.TypeVar(&#34;T&#34;)


class InterpreterContext:
    &#34;&#34;&#34;
    Base class for the command interpreter context. Contains all state information for the `scrolls.interpreter.run.Interpreter`.
    This is also the main interface plugin writers will use to interact with the interpreter, and is passed to all
    `scrolls.interpreter.callhandler.CallHandler` implementations.
    &#34;&#34;&#34;

    def __init__(self, *_: t.Any):
        self._current_node: t.Optional[ast.ASTNode] = None
        self._call_context: t.Optional[struct.CallContext] = None
        self._interpreter: t.Optional[&#39;run.Interpreter&#39;] = None
        self._vars = struct.ScopedVarStore()

        self.statement_count = 0
        &#34;&#34;&#34;The number of statements that have been run by the interpreter so far.&#34;&#34;&#34;

        self._call_stack: t.MutableSequence[struct.CallContext] = []

        # Handlers for calls defined at runtime
        self._runtime_command_handlers: callhandler.MutableCallHandlerContainer[None] = callhandler.BaseCallHandlerContainer()
        self._runtime_expansion_handlers: callhandler.MutableCallHandlerContainer[str] = callhandler.BaseCallHandlerContainer()

        # Combined handlers that check both runtime and static calls
        self._all_command_handlers: t.Optional[callhandler.CallHandlerContainer[None]] = None
        self._all_expansion_handlers: t.Optional[callhandler.CallHandlerContainer[str]] = None

        self._open_files: t.MutableMapping[int, t.IO[str]] = {}
        self._fid = 0

    @property
    def vars(self) -&gt; struct.ScopedVarStore:
        &#34;&#34;&#34;The variable store.&#34;&#34;&#34;
        return self._vars

    def set_var(self, name: str, value: str) -&gt; None:
        &#34;&#34;&#34;Set a variable.&#34;&#34;&#34;
        self.vars.set_var(name, value)

    def del_var(self, name: str) -&gt; None:
        &#34;&#34;&#34;Delete a variable.&#34;&#34;&#34;
        self.vars.del_var(name)

    def get_var(self, name: str) -&gt; str:
        &#34;&#34;&#34;Get a variable.&#34;&#34;&#34;
        return self.vars.get_var(name)

    def open_file(self, path: str, mode: str) -&gt; int:
        &#34;&#34;&#34;
        Opens a file for this context.

        Returns:
             A numeric file ID that should be used in other `*_file` functions
             for `scrolls.interpreter.state.InterpreterContext`.
        &#34;&#34;&#34;
        p = pathlib.Path(path)

        if not p.exists():
            raise interpreter_errors.InterpreterError(
                self,
                f&#34;{path} does not exist&#34;
            )

        if not p.is_file():
            raise interpreter_errors.InterpreterError(
                self,
                f&#34;{path} is not a file&#34;
            )

        # do not allow binary mode for now
        mode = mode.replace(&#34;b&#34;, &#34;&#34;)

        f = open(p, mode)
        self._open_files[self._fid] = f
        used_fid = self._fid
        self._fid += 1

        logger.debug(f&#34;Opened file: {path}&#34;)

        return used_fid

    def close_file(self, fid: int) -&gt; None:
        &#34;&#34;&#34;
        Closes a file for this context.
        &#34;&#34;&#34;
        if fid not in self._open_files:
            raise interpreter_errors.InterpreterError(
                self,
                f&#34;file already closed, or not open (fid {fid})&#34;
            )

        self._open_files[fid].close()
        del self._open_files[fid]

    def get_file(self, fid: int) -&gt; t.IO[str]:
        &#34;&#34;&#34;
        Gets an open file for this context.
        &#34;&#34;&#34;
        if fid not in self._open_files:
            raise interpreter_errors.InterpreterError(
                self,
                f&#34;file already closed, or not open (fid {fid})&#34;
            )

        return self._open_files[fid]

    @property
    def runtime_commands(self) -&gt; &#39;callhandler.MutableCallHandlerContainer[None]&#39;:
        &#34;&#34;&#34;The call handler container for runtime command handlers. Runtime commands are defined while the interpreter
        is running, i.e. through the `!def` directive or similar.

        For any command handler added to this container, all commands defined within it:

        - **Should** always perform their work in their own variable scope. See `scrolls.interpreter.struct.ScopedVarStore.new_scope`.
        - **Must** set the `scrolls.interpreter.struct.CallContext.runtime_call` parameter to `True`.
        - **Must** cease executing if an `scrolls.interpreter.interpreter_errors.InterpreterStop` or
          `scrolls.interpreter.interpreter_errors.InterpreterReturn` is raised.
        &#34;&#34;&#34;
        return self._runtime_command_handlers

    @property
    def runtime_expansions(self) -&gt; &#39;callhandler.MutableCallHandlerContainer[str]&#39;:
        &#34;&#34;&#34;Same as `scrolls.interpreter.state.InterpreterContext.runtime_commands`, but for expansion calls.

        Runtime expansions follow the same requirements as commands, plus:

        - **Must** set the `scrolls.interpreter.struct.CallContext.return_value` parameter upon call completion.
        - **Must** catch `scrolls.interpreter.interpreter_errors.InterpreterReturn` and set the return value on this exception.
        &#34;&#34;&#34;
        return self._runtime_expansion_handlers

    @property
    def all_commands(self) -&gt; &#39;callhandler.CallHandlerContainer[None]&#39;:
        &#34;&#34;&#34;
        The call handler container for all commands currently defined at execution
        time, including all static commands.

        Plugins wishing to programmatically call commands should use this.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If this property is not initialized.
        &#34;&#34;&#34;
        if self._all_command_handlers is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Bad context: _all_command_handlers not initialized.&#34;
            )

        return self._all_command_handlers

    @property
    def all_expansions(self) -&gt; &#39;callhandler.CallHandlerContainer[str]&#39;:
        &#34;&#34;&#34;
        The call handler container for all expansions currently defined at execution
        time, including all static commands.

        Plugins wishing to programatically call expansions should use this.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If this property is not initialized.
        &#34;&#34;&#34;
        if self._all_expansion_handlers is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Bad context: _all_expansion_handlers not initialized.&#34;
            )

        return self._all_expansion_handlers

    def init_handlers(
            self,
            interpreter_command_handlers: &#39;callhandler.CallHandlerContainer[None]&#39;,
            interpreter_expansion_handlers: &#39;callhandler.CallHandlerContainer[str]&#39;
    ) -&gt; None:
        &#34;&#34;&#34;
        Internal to the interpreter. This is called with the static command
        handler containers belonging to the interpreter when the context is
        initialized.
        &#34;&#34;&#34;
        self._all_command_handlers = callhandler.ChoiceCallHandlerContainer(
            self.runtime_commands,
            interpreter_command_handlers
        )
        self._all_expansion_handlers = callhandler.ChoiceCallHandlerContainer(
            self.runtime_expansions,
            interpreter_expansion_handlers
        )

    @property
    def interpreter(self) -&gt; &#39;run.Interpreter&#39;:
        &#34;&#34;&#34;
        The interpreter running using this context.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If this property is not initialized.
        &#34;&#34;&#34;
        if self._interpreter is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Interpreter is not initialized.&#34;
            )

        return self._interpreter

    @interpreter.setter
    def interpreter(self, interpreter: &#39;run.Interpreter&#39;) -&gt; None:
        self._interpreter = interpreter

    @property
    def current_node(self) -&gt; ast.ASTNode:
        &#34;&#34;&#34;
        The current `scrolls.ast.syntax.ASTNode` being interpreted.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If there is no current node.
        &#34;&#34;&#34;
        if self._current_node is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Current node is not initialized.&#34;
            )

        return self._current_node

    @current_node.setter
    def current_node(self, node: ast.ASTNode) -&gt; None:
        self._current_node = node

    def _call_check(self) -&gt; None:
        if self._call_context is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Current context is not a call.&#34;
            )

    @property
    def call_stack(self) -&gt; t.Sequence[struct.CallContext]:
        &#34;&#34;&#34;
        The call stack. Used primarily for tracking return values in runtime calls, and feeding
        call information to `scrolls.interpreter.callhandler.CallHandler` implementations. Variables scopes are tracked separately.
        See `scrolls.interpreter.state.InterpreterContext.vars`.

        .. WARNING::
            This stack does not contain the current call. See `InterpreterContext.call_context` for that.
        &#34;&#34;&#34;
        return self._call_stack

    @property
    def call_context(self) -&gt; struct.CallContext:
        &#34;&#34;&#34;
        The current call context.
        &#34;&#34;&#34;
        self._call_check()
        return t.cast(struct.CallContext, self._call_context)

    @property
    def parent_call_context(self) -&gt; struct.CallContext:
        &#34;&#34;&#34;
        Get the context of the call that called the current one. Can be used to
        influence signals in the parent context.
        &#34;&#34;&#34;
        self._call_check()
        if not self.call_stack:
            raise interpreter_errors.InternalInterpreterError(
                self, f&#34;Cannot get parent of base call \&#34;{self.call_context.call_name}\&#34;&#34;
            )

        return self.call_stack[-1]

    @property
    def call_name(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the current call.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.call_name

    @property
    def args(self) -&gt; t.Sequence[str]:
        &#34;&#34;&#34;
        The argments passed into the current call.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.args

    @property
    def arg_nodes(self) -&gt; struct.ArgSourceMap[ast.ASTNode]:
        &#34;&#34;&#34;
        The `scrolls.ast.syntax.ASTNode` instances the current call&#39;s arguments came from.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.arg_nodes

    @property
    def control_node(self) -&gt; ast.ASTNode:
        &#34;&#34;&#34;
        If the current context is a control call, this will contain the `scrolls.ast.syntax.ASTNode` parameter passed into it.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If the current context is not a call.
        &#34;&#34;&#34;
        if self.call_context.control_node is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Current context is not a control call.&#34;
            )

        return self.call_context.control_node

    def set_base_call(
            self
    ) -&gt; None:
        &#34;&#34;&#34;
        Sets the current call context to the base call context for top level code.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        logger.debug(&#34;set_base_call&#34;)
        self._call_context = struct.CallContext(
            &#34;__main__&#34;,
            [],
            struct.ArgSourceMap(),
            None
        )

    def set_call(
            self,
            command: str,
            args: t.Sequence[str],
            arg_nodes: struct.ArgSourceMap[ast.ASTNode],
            control_node: t.Optional[ast.ASTNode] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Sets the current call context, overwriting whatever was previously current. If you want to preserve the
        current context for later use, see `scrolls.interpreter.state.InterpreterContext.push_call`

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        self._call_context = struct.CallContext(
            command,
            args,
            arg_nodes,
            control_node
        )

    def push_call(self) -&gt; None:
        &#34;&#34;&#34;
        Duplicate the current call context and push it onto the call stack. Should be followed up with
        `scrolls.interpreter.state.InterpreterContext.set_call` to create a new context.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        self._call_check()
        self._call_stack.append(self.call_context)

    def pop_call(self) -&gt; None:
        &#34;&#34;&#34;
        Destroy the current call context, and replace it with the first context on the call stack.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If not calls have been pushed.
        &#34;&#34;&#34;
        if not self._call_stack:
            raise interpreter_errors.InternalInterpreterError(
                self,
                f&#34;Cannot pop call. No calls pushed.&#34;
            )

        ctx = self._call_stack.pop()
        self._call_context = ctx

    # In order to set a return value, we need to traverse up the
    # context stack in order to find one actually created by a dynamically
    # generated call.
    def set_retval(self, retval: str) -&gt; None:
        &#34;&#34;&#34;
        Sets the return value in the first runtime call found in the stack.

        Raises:
            scrolls.interpreter.interpreter_errors.InterpreterError: If outside a call context, no call stack, or no runtime call contexts found.
        &#34;&#34;&#34;
        self._call_check()

        if not self.call_stack:
            raise interpreter_errors.InterpreterError(
                self,
                f&#34;cannot return, no call stack (outside calls)&#34;
            )

        for ctx in reversed(self.call_stack):
            if ctx.runtime_call:
                ctx.return_value = retval
                return

        raise interpreter_errors.InterpreterError(
            self,
            f&#34;cannot return outside of function&#34;
        )

    def get_backtrace(self) -&gt; str:
        &#34;&#34;&#34;
        Gets a printable string showing the full call backtrace for this
        context.
        &#34;&#34;&#34;
        stack = list(self.call_stack) + [self.call_context]
        stack_size = len(stack)
        id_size = int(math.log(stack_size, 10)) + 1

        trace = [
            &#34;backtrace (most recent call last)&#34;,
            struct.CallContext.trace_banner(id_size),
            *[call_ctx.trace_str(count, id_size) for count, call_ctx in enumerate(stack)]
        ]

        return &#34;\n&#34;.join(trace)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrolls.interpreter.state.InterpreterContext"><code class="flex name class">
<span>class <span class="ident">InterpreterContext</span></span>
<span>(</span><span>*_: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for the command interpreter context. Contains all state information for the <code><a title="scrolls.interpreter.run.Interpreter" href="run.html#scrolls.interpreter.run.Interpreter">Interpreter</a></code>.
This is also the main interface plugin writers will use to interact with the interpreter, and is passed to all
<code><a title="scrolls.interpreter.callhandler.CallHandler" href="callhandler.html#scrolls.interpreter.callhandler.CallHandler">CallHandler</a></code> implementations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InterpreterContext:
    &#34;&#34;&#34;
    Base class for the command interpreter context. Contains all state information for the `scrolls.interpreter.run.Interpreter`.
    This is also the main interface plugin writers will use to interact with the interpreter, and is passed to all
    `scrolls.interpreter.callhandler.CallHandler` implementations.
    &#34;&#34;&#34;

    def __init__(self, *_: t.Any):
        self._current_node: t.Optional[ast.ASTNode] = None
        self._call_context: t.Optional[struct.CallContext] = None
        self._interpreter: t.Optional[&#39;run.Interpreter&#39;] = None
        self._vars = struct.ScopedVarStore()

        self.statement_count = 0
        &#34;&#34;&#34;The number of statements that have been run by the interpreter so far.&#34;&#34;&#34;

        self._call_stack: t.MutableSequence[struct.CallContext] = []

        # Handlers for calls defined at runtime
        self._runtime_command_handlers: callhandler.MutableCallHandlerContainer[None] = callhandler.BaseCallHandlerContainer()
        self._runtime_expansion_handlers: callhandler.MutableCallHandlerContainer[str] = callhandler.BaseCallHandlerContainer()

        # Combined handlers that check both runtime and static calls
        self._all_command_handlers: t.Optional[callhandler.CallHandlerContainer[None]] = None
        self._all_expansion_handlers: t.Optional[callhandler.CallHandlerContainer[str]] = None

        self._open_files: t.MutableMapping[int, t.IO[str]] = {}
        self._fid = 0

    @property
    def vars(self) -&gt; struct.ScopedVarStore:
        &#34;&#34;&#34;The variable store.&#34;&#34;&#34;
        return self._vars

    def set_var(self, name: str, value: str) -&gt; None:
        &#34;&#34;&#34;Set a variable.&#34;&#34;&#34;
        self.vars.set_var(name, value)

    def del_var(self, name: str) -&gt; None:
        &#34;&#34;&#34;Delete a variable.&#34;&#34;&#34;
        self.vars.del_var(name)

    def get_var(self, name: str) -&gt; str:
        &#34;&#34;&#34;Get a variable.&#34;&#34;&#34;
        return self.vars.get_var(name)

    def open_file(self, path: str, mode: str) -&gt; int:
        &#34;&#34;&#34;
        Opens a file for this context.

        Returns:
             A numeric file ID that should be used in other `*_file` functions
             for `scrolls.interpreter.state.InterpreterContext`.
        &#34;&#34;&#34;
        p = pathlib.Path(path)

        if not p.exists():
            raise interpreter_errors.InterpreterError(
                self,
                f&#34;{path} does not exist&#34;
            )

        if not p.is_file():
            raise interpreter_errors.InterpreterError(
                self,
                f&#34;{path} is not a file&#34;
            )

        # do not allow binary mode for now
        mode = mode.replace(&#34;b&#34;, &#34;&#34;)

        f = open(p, mode)
        self._open_files[self._fid] = f
        used_fid = self._fid
        self._fid += 1

        logger.debug(f&#34;Opened file: {path}&#34;)

        return used_fid

    def close_file(self, fid: int) -&gt; None:
        &#34;&#34;&#34;
        Closes a file for this context.
        &#34;&#34;&#34;
        if fid not in self._open_files:
            raise interpreter_errors.InterpreterError(
                self,
                f&#34;file already closed, or not open (fid {fid})&#34;
            )

        self._open_files[fid].close()
        del self._open_files[fid]

    def get_file(self, fid: int) -&gt; t.IO[str]:
        &#34;&#34;&#34;
        Gets an open file for this context.
        &#34;&#34;&#34;
        if fid not in self._open_files:
            raise interpreter_errors.InterpreterError(
                self,
                f&#34;file already closed, or not open (fid {fid})&#34;
            )

        return self._open_files[fid]

    @property
    def runtime_commands(self) -&gt; &#39;callhandler.MutableCallHandlerContainer[None]&#39;:
        &#34;&#34;&#34;The call handler container for runtime command handlers. Runtime commands are defined while the interpreter
        is running, i.e. through the `!def` directive or similar.

        For any command handler added to this container, all commands defined within it:

        - **Should** always perform their work in their own variable scope. See `scrolls.interpreter.struct.ScopedVarStore.new_scope`.
        - **Must** set the `scrolls.interpreter.struct.CallContext.runtime_call` parameter to `True`.
        - **Must** cease executing if an `scrolls.interpreter.interpreter_errors.InterpreterStop` or
          `scrolls.interpreter.interpreter_errors.InterpreterReturn` is raised.
        &#34;&#34;&#34;
        return self._runtime_command_handlers

    @property
    def runtime_expansions(self) -&gt; &#39;callhandler.MutableCallHandlerContainer[str]&#39;:
        &#34;&#34;&#34;Same as `scrolls.interpreter.state.InterpreterContext.runtime_commands`, but for expansion calls.

        Runtime expansions follow the same requirements as commands, plus:

        - **Must** set the `scrolls.interpreter.struct.CallContext.return_value` parameter upon call completion.
        - **Must** catch `scrolls.interpreter.interpreter_errors.InterpreterReturn` and set the return value on this exception.
        &#34;&#34;&#34;
        return self._runtime_expansion_handlers

    @property
    def all_commands(self) -&gt; &#39;callhandler.CallHandlerContainer[None]&#39;:
        &#34;&#34;&#34;
        The call handler container for all commands currently defined at execution
        time, including all static commands.

        Plugins wishing to programmatically call commands should use this.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If this property is not initialized.
        &#34;&#34;&#34;
        if self._all_command_handlers is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Bad context: _all_command_handlers not initialized.&#34;
            )

        return self._all_command_handlers

    @property
    def all_expansions(self) -&gt; &#39;callhandler.CallHandlerContainer[str]&#39;:
        &#34;&#34;&#34;
        The call handler container for all expansions currently defined at execution
        time, including all static commands.

        Plugins wishing to programatically call expansions should use this.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If this property is not initialized.
        &#34;&#34;&#34;
        if self._all_expansion_handlers is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Bad context: _all_expansion_handlers not initialized.&#34;
            )

        return self._all_expansion_handlers

    def init_handlers(
            self,
            interpreter_command_handlers: &#39;callhandler.CallHandlerContainer[None]&#39;,
            interpreter_expansion_handlers: &#39;callhandler.CallHandlerContainer[str]&#39;
    ) -&gt; None:
        &#34;&#34;&#34;
        Internal to the interpreter. This is called with the static command
        handler containers belonging to the interpreter when the context is
        initialized.
        &#34;&#34;&#34;
        self._all_command_handlers = callhandler.ChoiceCallHandlerContainer(
            self.runtime_commands,
            interpreter_command_handlers
        )
        self._all_expansion_handlers = callhandler.ChoiceCallHandlerContainer(
            self.runtime_expansions,
            interpreter_expansion_handlers
        )

    @property
    def interpreter(self) -&gt; &#39;run.Interpreter&#39;:
        &#34;&#34;&#34;
        The interpreter running using this context.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If this property is not initialized.
        &#34;&#34;&#34;
        if self._interpreter is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Interpreter is not initialized.&#34;
            )

        return self._interpreter

    @interpreter.setter
    def interpreter(self, interpreter: &#39;run.Interpreter&#39;) -&gt; None:
        self._interpreter = interpreter

    @property
    def current_node(self) -&gt; ast.ASTNode:
        &#34;&#34;&#34;
        The current `scrolls.ast.syntax.ASTNode` being interpreted.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If there is no current node.
        &#34;&#34;&#34;
        if self._current_node is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Current node is not initialized.&#34;
            )

        return self._current_node

    @current_node.setter
    def current_node(self, node: ast.ASTNode) -&gt; None:
        self._current_node = node

    def _call_check(self) -&gt; None:
        if self._call_context is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Current context is not a call.&#34;
            )

    @property
    def call_stack(self) -&gt; t.Sequence[struct.CallContext]:
        &#34;&#34;&#34;
        The call stack. Used primarily for tracking return values in runtime calls, and feeding
        call information to `scrolls.interpreter.callhandler.CallHandler` implementations. Variables scopes are tracked separately.
        See `scrolls.interpreter.state.InterpreterContext.vars`.

        .. WARNING::
            This stack does not contain the current call. See `InterpreterContext.call_context` for that.
        &#34;&#34;&#34;
        return self._call_stack

    @property
    def call_context(self) -&gt; struct.CallContext:
        &#34;&#34;&#34;
        The current call context.
        &#34;&#34;&#34;
        self._call_check()
        return t.cast(struct.CallContext, self._call_context)

    @property
    def parent_call_context(self) -&gt; struct.CallContext:
        &#34;&#34;&#34;
        Get the context of the call that called the current one. Can be used to
        influence signals in the parent context.
        &#34;&#34;&#34;
        self._call_check()
        if not self.call_stack:
            raise interpreter_errors.InternalInterpreterError(
                self, f&#34;Cannot get parent of base call \&#34;{self.call_context.call_name}\&#34;&#34;
            )

        return self.call_stack[-1]

    @property
    def call_name(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the current call.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.call_name

    @property
    def args(self) -&gt; t.Sequence[str]:
        &#34;&#34;&#34;
        The argments passed into the current call.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.args

    @property
    def arg_nodes(self) -&gt; struct.ArgSourceMap[ast.ASTNode]:
        &#34;&#34;&#34;
        The `scrolls.ast.syntax.ASTNode` instances the current call&#39;s arguments came from.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.arg_nodes

    @property
    def control_node(self) -&gt; ast.ASTNode:
        &#34;&#34;&#34;
        If the current context is a control call, this will contain the `scrolls.ast.syntax.ASTNode` parameter passed into it.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If the current context is not a call.
        &#34;&#34;&#34;
        if self.call_context.control_node is None:
            raise interpreter_errors.InternalInterpreterError(
                self, &#34;Current context is not a control call.&#34;
            )

        return self.call_context.control_node

    def set_base_call(
            self
    ) -&gt; None:
        &#34;&#34;&#34;
        Sets the current call context to the base call context for top level code.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        logger.debug(&#34;set_base_call&#34;)
        self._call_context = struct.CallContext(
            &#34;__main__&#34;,
            [],
            struct.ArgSourceMap(),
            None
        )

    def set_call(
            self,
            command: str,
            args: t.Sequence[str],
            arg_nodes: struct.ArgSourceMap[ast.ASTNode],
            control_node: t.Optional[ast.ASTNode] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Sets the current call context, overwriting whatever was previously current. If you want to preserve the
        current context for later use, see `scrolls.interpreter.state.InterpreterContext.push_call`

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        self._call_context = struct.CallContext(
            command,
            args,
            arg_nodes,
            control_node
        )

    def push_call(self) -&gt; None:
        &#34;&#34;&#34;
        Duplicate the current call context and push it onto the call stack. Should be followed up with
        `scrolls.interpreter.state.InterpreterContext.set_call` to create a new context.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        self._call_check()
        self._call_stack.append(self.call_context)

    def pop_call(self) -&gt; None:
        &#34;&#34;&#34;
        Destroy the current call context, and replace it with the first context on the call stack.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.

        Raises:
            scrolls.interpreter.interpreter_errors.InternalInterpreterError: If not calls have been pushed.
        &#34;&#34;&#34;
        if not self._call_stack:
            raise interpreter_errors.InternalInterpreterError(
                self,
                f&#34;Cannot pop call. No calls pushed.&#34;
            )

        ctx = self._call_stack.pop()
        self._call_context = ctx

    # In order to set a return value, we need to traverse up the
    # context stack in order to find one actually created by a dynamically
    # generated call.
    def set_retval(self, retval: str) -&gt; None:
        &#34;&#34;&#34;
        Sets the return value in the first runtime call found in the stack.

        Raises:
            scrolls.interpreter.interpreter_errors.InterpreterError: If outside a call context, no call stack, or no runtime call contexts found.
        &#34;&#34;&#34;
        self._call_check()

        if not self.call_stack:
            raise interpreter_errors.InterpreterError(
                self,
                f&#34;cannot return, no call stack (outside calls)&#34;
            )

        for ctx in reversed(self.call_stack):
            if ctx.runtime_call:
                ctx.return_value = retval
                return

        raise interpreter_errors.InterpreterError(
            self,
            f&#34;cannot return outside of function&#34;
        )

    def get_backtrace(self) -&gt; str:
        &#34;&#34;&#34;
        Gets a printable string showing the full call backtrace for this
        context.
        &#34;&#34;&#34;
        stack = list(self.call_stack) + [self.call_context]
        stack_size = len(stack)
        id_size = int(math.log(stack_size, 10)) + 1

        trace = [
            &#34;backtrace (most recent call last)&#34;,
            struct.CallContext.trace_banner(id_size),
            *[call_ctx.trace_str(count, id_size) for count, call_ctx in enumerate(stack)]
        ]

        return &#34;\n&#34;.join(trace)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="scrolls.interpreter.state.InterpreterContext.all_commands"><code class="name">var <span class="ident">all_commands</span> : <a title="scrolls.interpreter.callhandler.CallHandlerContainer" href="callhandler.html#scrolls.interpreter.callhandler.CallHandlerContainer">CallHandlerContainer</a>[None]</code></dt>
<dd>
<div class="desc"><p>The call handler container for all commands currently defined at execution
time, including all static commands.</p>
<p>Plugins wishing to programmatically call commands should use this.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.interpreter_errors.InternalInterpreterError" href="interpreter_errors.html#scrolls.interpreter.interpreter_errors.InternalInterpreterError">InternalInterpreterError</a></code></dt>
<dd>If this property is not initialized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_commands(self) -&gt; &#39;callhandler.CallHandlerContainer[None]&#39;:
    &#34;&#34;&#34;
    The call handler container for all commands currently defined at execution
    time, including all static commands.

    Plugins wishing to programmatically call commands should use this.

    Raises:
        scrolls.interpreter.interpreter_errors.InternalInterpreterError: If this property is not initialized.
    &#34;&#34;&#34;
    if self._all_command_handlers is None:
        raise interpreter_errors.InternalInterpreterError(
            self, &#34;Bad context: _all_command_handlers not initialized.&#34;
        )

    return self._all_command_handlers</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.all_expansions"><code class="name">var <span class="ident">all_expansions</span> : <a title="scrolls.interpreter.callhandler.CallHandlerContainer" href="callhandler.html#scrolls.interpreter.callhandler.CallHandlerContainer">CallHandlerContainer</a>[str]</code></dt>
<dd>
<div class="desc"><p>The call handler container for all expansions currently defined at execution
time, including all static commands.</p>
<p>Plugins wishing to programatically call expansions should use this.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.interpreter_errors.InternalInterpreterError" href="interpreter_errors.html#scrolls.interpreter.interpreter_errors.InternalInterpreterError">InternalInterpreterError</a></code></dt>
<dd>If this property is not initialized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_expansions(self) -&gt; &#39;callhandler.CallHandlerContainer[str]&#39;:
    &#34;&#34;&#34;
    The call handler container for all expansions currently defined at execution
    time, including all static commands.

    Plugins wishing to programatically call expansions should use this.

    Raises:
        scrolls.interpreter.interpreter_errors.InternalInterpreterError: If this property is not initialized.
    &#34;&#34;&#34;
    if self._all_expansion_handlers is None:
        raise interpreter_errors.InternalInterpreterError(
            self, &#34;Bad context: _all_expansion_handlers not initialized.&#34;
        )

    return self._all_expansion_handlers</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.arg_nodes"><code class="name">var <span class="ident">arg_nodes</span> : <a title="scrolls.interpreter.struct.ArgSourceMap" href="struct.html#scrolls.interpreter.struct.ArgSourceMap">ArgSourceMap</a></code></dt>
<dd>
<div class="desc"><p>The <code><a title="scrolls.ast.syntax.ASTNode" href="../ast/syntax.html#scrolls.ast.syntax.ASTNode">ASTNode</a></code> instances the current call's arguments came from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def arg_nodes(self) -&gt; struct.ArgSourceMap[ast.ASTNode]:
    &#34;&#34;&#34;
    The `scrolls.ast.syntax.ASTNode` instances the current call&#39;s arguments came from.
    &#34;&#34;&#34;
    self._call_check()
    return self.call_context.arg_nodes</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.args"><code class="name">var <span class="ident">args</span> : Sequence[str]</code></dt>
<dd>
<div class="desc"><p>The argments passed into the current call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def args(self) -&gt; t.Sequence[str]:
    &#34;&#34;&#34;
    The argments passed into the current call.
    &#34;&#34;&#34;
    self._call_check()
    return self.call_context.args</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.call_context"><code class="name">var <span class="ident">call_context</span> : <a title="scrolls.interpreter.struct.CallContext" href="struct.html#scrolls.interpreter.struct.CallContext">CallContext</a></code></dt>
<dd>
<div class="desc"><p>The current call context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_context(self) -&gt; struct.CallContext:
    &#34;&#34;&#34;
    The current call context.
    &#34;&#34;&#34;
    self._call_check()
    return t.cast(struct.CallContext, self._call_context)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.call_name"><code class="name">var <span class="ident">call_name</span> : str</code></dt>
<dd>
<div class="desc"><p>The name of the current call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_name(self) -&gt; str:
    &#34;&#34;&#34;
    The name of the current call.
    &#34;&#34;&#34;
    self._call_check()
    return self.call_context.call_name</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.call_stack"><code class="name">var <span class="ident">call_stack</span> : Sequence[<a title="scrolls.interpreter.struct.CallContext" href="struct.html#scrolls.interpreter.struct.CallContext">CallContext</a>]</code></dt>
<dd>
<div class="desc"><p>The call stack. Used primarily for tracking return values in runtime calls, and feeding
call information to <code><a title="scrolls.interpreter.callhandler.CallHandler" href="callhandler.html#scrolls.interpreter.callhandler.CallHandler">CallHandler</a></code> implementations. Variables scopes are tracked separately.
See <code><a title="scrolls.interpreter.state.InterpreterContext.vars" href="#scrolls.interpreter.state.InterpreterContext.vars">InterpreterContext.vars</a></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This stack does not contain the current call. See <code><a title="scrolls.interpreter.state.InterpreterContext.call_context" href="#scrolls.interpreter.state.InterpreterContext.call_context">InterpreterContext.call_context</a></code> for that.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_stack(self) -&gt; t.Sequence[struct.CallContext]:
    &#34;&#34;&#34;
    The call stack. Used primarily for tracking return values in runtime calls, and feeding
    call information to `scrolls.interpreter.callhandler.CallHandler` implementations. Variables scopes are tracked separately.
    See `scrolls.interpreter.state.InterpreterContext.vars`.

    .. WARNING::
        This stack does not contain the current call. See `InterpreterContext.call_context` for that.
    &#34;&#34;&#34;
    return self._call_stack</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.control_node"><code class="name">var <span class="ident">control_node</span> : <a title="scrolls.ast.syntax.ASTNode" href="../ast/syntax.html#scrolls.ast.syntax.ASTNode">ASTNode</a></code></dt>
<dd>
<div class="desc"><p>If the current context is a control call, this will contain the <code><a title="scrolls.ast.syntax.ASTNode" href="../ast/syntax.html#scrolls.ast.syntax.ASTNode">ASTNode</a></code> parameter passed into it.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.interpreter_errors.InternalInterpreterError" href="interpreter_errors.html#scrolls.interpreter.interpreter_errors.InternalInterpreterError">InternalInterpreterError</a></code></dt>
<dd>If the current context is not a call.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def control_node(self) -&gt; ast.ASTNode:
    &#34;&#34;&#34;
    If the current context is a control call, this will contain the `scrolls.ast.syntax.ASTNode` parameter passed into it.

    Raises:
        scrolls.interpreter.interpreter_errors.InternalInterpreterError: If the current context is not a call.
    &#34;&#34;&#34;
    if self.call_context.control_node is None:
        raise interpreter_errors.InternalInterpreterError(
            self, &#34;Current context is not a control call.&#34;
        )

    return self.call_context.control_node</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.current_node"><code class="name">var <span class="ident">current_node</span> : <a title="scrolls.ast.syntax.ASTNode" href="../ast/syntax.html#scrolls.ast.syntax.ASTNode">ASTNode</a></code></dt>
<dd>
<div class="desc"><p>The current <code><a title="scrolls.ast.syntax.ASTNode" href="../ast/syntax.html#scrolls.ast.syntax.ASTNode">ASTNode</a></code> being interpreted.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.interpreter_errors.InternalInterpreterError" href="interpreter_errors.html#scrolls.interpreter.interpreter_errors.InternalInterpreterError">InternalInterpreterError</a></code></dt>
<dd>If there is no current node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def current_node(self) -&gt; ast.ASTNode:
    &#34;&#34;&#34;
    The current `scrolls.ast.syntax.ASTNode` being interpreted.

    Raises:
        scrolls.interpreter.interpreter_errors.InternalInterpreterError: If there is no current node.
    &#34;&#34;&#34;
    if self._current_node is None:
        raise interpreter_errors.InternalInterpreterError(
            self, &#34;Current node is not initialized.&#34;
        )

    return self._current_node</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.interpreter"><code class="name">var <span class="ident">interpreter</span> : run.Interpreter</code></dt>
<dd>
<div class="desc"><p>The interpreter running using this context.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.interpreter_errors.InternalInterpreterError" href="interpreter_errors.html#scrolls.interpreter.interpreter_errors.InternalInterpreterError">InternalInterpreterError</a></code></dt>
<dd>If this property is not initialized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def interpreter(self) -&gt; &#39;run.Interpreter&#39;:
    &#34;&#34;&#34;
    The interpreter running using this context.

    Raises:
        scrolls.interpreter.interpreter_errors.InternalInterpreterError: If this property is not initialized.
    &#34;&#34;&#34;
    if self._interpreter is None:
        raise interpreter_errors.InternalInterpreterError(
            self, &#34;Interpreter is not initialized.&#34;
        )

    return self._interpreter</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.parent_call_context"><code class="name">var <span class="ident">parent_call_context</span> : <a title="scrolls.interpreter.struct.CallContext" href="struct.html#scrolls.interpreter.struct.CallContext">CallContext</a></code></dt>
<dd>
<div class="desc"><p>Get the context of the call that called the current one. Can be used to
influence signals in the parent context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent_call_context(self) -&gt; struct.CallContext:
    &#34;&#34;&#34;
    Get the context of the call that called the current one. Can be used to
    influence signals in the parent context.
    &#34;&#34;&#34;
    self._call_check()
    if not self.call_stack:
        raise interpreter_errors.InternalInterpreterError(
            self, f&#34;Cannot get parent of base call \&#34;{self.call_context.call_name}\&#34;&#34;
        )

    return self.call_stack[-1]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.runtime_commands"><code class="name">var <span class="ident">runtime_commands</span> : <a title="scrolls.interpreter.callhandler.MutableCallHandlerContainer" href="callhandler.html#scrolls.interpreter.callhandler.MutableCallHandlerContainer">MutableCallHandlerContainer</a>[None]</code></dt>
<dd>
<div class="desc"><p>The call handler container for runtime command handlers. Runtime commands are defined while the interpreter
is running, i.e. through the <code>!def</code> directive or similar.</p>
<p>For any command handler added to this container, all commands defined within it:</p>
<ul>
<li><strong>Should</strong> always perform their work in their own variable scope. See <code><a title="scrolls.interpreter.struct.ScopedVarStore.new_scope" href="struct.html#scrolls.interpreter.struct.ScopedVarStore.new_scope">ScopedVarStore.new_scope()</a></code>.</li>
<li><strong>Must</strong> set the <code><a title="scrolls.interpreter.struct.CallContext.runtime_call" href="struct.html#scrolls.interpreter.struct.CallContext.runtime_call">CallContext.runtime_call</a></code> parameter to <code>True</code>.</li>
<li><strong>Must</strong> cease executing if an <code><a title="scrolls.interpreter.interpreter_errors.InterpreterStop" href="interpreter_errors.html#scrolls.interpreter.interpreter_errors.InterpreterStop">InterpreterStop</a></code> or
<code><a title="scrolls.interpreter.interpreter_errors.InterpreterReturn" href="interpreter_errors.html#scrolls.interpreter.interpreter_errors.InterpreterReturn">InterpreterReturn</a></code> is raised.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def runtime_commands(self) -&gt; &#39;callhandler.MutableCallHandlerContainer[None]&#39;:
    &#34;&#34;&#34;The call handler container for runtime command handlers. Runtime commands are defined while the interpreter
    is running, i.e. through the `!def` directive or similar.

    For any command handler added to this container, all commands defined within it:

    - **Should** always perform their work in their own variable scope. See `scrolls.interpreter.struct.ScopedVarStore.new_scope`.
    - **Must** set the `scrolls.interpreter.struct.CallContext.runtime_call` parameter to `True`.
    - **Must** cease executing if an `scrolls.interpreter.interpreter_errors.InterpreterStop` or
      `scrolls.interpreter.interpreter_errors.InterpreterReturn` is raised.
    &#34;&#34;&#34;
    return self._runtime_command_handlers</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.runtime_expansions"><code class="name">var <span class="ident">runtime_expansions</span> : <a title="scrolls.interpreter.callhandler.MutableCallHandlerContainer" href="callhandler.html#scrolls.interpreter.callhandler.MutableCallHandlerContainer">MutableCallHandlerContainer</a>[str]</code></dt>
<dd>
<div class="desc"><p>Same as <code><a title="scrolls.interpreter.state.InterpreterContext.runtime_commands" href="#scrolls.interpreter.state.InterpreterContext.runtime_commands">InterpreterContext.runtime_commands</a></code>, but for expansion calls.</p>
<p>Runtime expansions follow the same requirements as commands, plus:</p>
<ul>
<li><strong>Must</strong> set the <code><a title="scrolls.interpreter.struct.CallContext.return_value" href="struct.html#scrolls.interpreter.struct.CallContext.return_value">CallContext.return_value</a></code> parameter upon call completion.</li>
<li><strong>Must</strong> catch <code><a title="scrolls.interpreter.interpreter_errors.InterpreterReturn" href="interpreter_errors.html#scrolls.interpreter.interpreter_errors.InterpreterReturn">InterpreterReturn</a></code> and set the return value on this exception.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def runtime_expansions(self) -&gt; &#39;callhandler.MutableCallHandlerContainer[str]&#39;:
    &#34;&#34;&#34;Same as `scrolls.interpreter.state.InterpreterContext.runtime_commands`, but for expansion calls.

    Runtime expansions follow the same requirements as commands, plus:

    - **Must** set the `scrolls.interpreter.struct.CallContext.return_value` parameter upon call completion.
    - **Must** catch `scrolls.interpreter.interpreter_errors.InterpreterReturn` and set the return value on this exception.
    &#34;&#34;&#34;
    return self._runtime_expansion_handlers</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.statement_count"><code class="name">var <span class="ident">statement_count</span></code></dt>
<dd>
<div class="desc"><p>The number of statements that have been run by the interpreter so far.</p></div>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.vars"><code class="name">var <span class="ident">vars</span> : <a title="scrolls.interpreter.struct.ScopedVarStore" href="struct.html#scrolls.interpreter.struct.ScopedVarStore">ScopedVarStore</a></code></dt>
<dd>
<div class="desc"><p>The variable store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vars(self) -&gt; struct.ScopedVarStore:
    &#34;&#34;&#34;The variable store.&#34;&#34;&#34;
    return self._vars</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.state.InterpreterContext.close_file"><code class="name flex">
<span>def <span class="ident">close_file</span></span>(<span>self, fid: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Closes a file for this context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_file(self, fid: int) -&gt; None:
    &#34;&#34;&#34;
    Closes a file for this context.
    &#34;&#34;&#34;
    if fid not in self._open_files:
        raise interpreter_errors.InterpreterError(
            self,
            f&#34;file already closed, or not open (fid {fid})&#34;
        )

    self._open_files[fid].close()
    del self._open_files[fid]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.del_var"><code class="name flex">
<span>def <span class="ident">del_var</span></span>(<span>self, name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_var(self, name: str) -&gt; None:
    &#34;&#34;&#34;Delete a variable.&#34;&#34;&#34;
    self.vars.del_var(name)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.get_backtrace"><code class="name flex">
<span>def <span class="ident">get_backtrace</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a printable string showing the full call backtrace for this
context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_backtrace(self) -&gt; str:
    &#34;&#34;&#34;
    Gets a printable string showing the full call backtrace for this
    context.
    &#34;&#34;&#34;
    stack = list(self.call_stack) + [self.call_context]
    stack_size = len(stack)
    id_size = int(math.log(stack_size, 10)) + 1

    trace = [
        &#34;backtrace (most recent call last)&#34;,
        struct.CallContext.trace_banner(id_size),
        *[call_ctx.trace_str(count, id_size) for count, call_ctx in enumerate(stack)]
    ]

    return &#34;\n&#34;.join(trace)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.get_file"><code class="name flex">
<span>def <span class="ident">get_file</span></span>(<span>self, fid: int) ‑> IO[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets an open file for this context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file(self, fid: int) -&gt; t.IO[str]:
    &#34;&#34;&#34;
    Gets an open file for this context.
    &#34;&#34;&#34;
    if fid not in self._open_files:
        raise interpreter_errors.InterpreterError(
            self,
            f&#34;file already closed, or not open (fid {fid})&#34;
        )

    return self._open_files[fid]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.get_var"><code class="name flex">
<span>def <span class="ident">get_var</span></span>(<span>self, name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get a variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_var(self, name: str) -&gt; str:
    &#34;&#34;&#34;Get a variable.&#34;&#34;&#34;
    return self.vars.get_var(name)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.init_handlers"><code class="name flex">
<span>def <span class="ident">init_handlers</span></span>(<span>self, interpreter_command_handlers: callhandler.CallHandlerContainer[None], interpreter_expansion_handlers: callhandler.CallHandlerContainer[str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Internal to the interpreter. This is called with the static command
handler containers belonging to the interpreter when the context is
initialized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_handlers(
        self,
        interpreter_command_handlers: &#39;callhandler.CallHandlerContainer[None]&#39;,
        interpreter_expansion_handlers: &#39;callhandler.CallHandlerContainer[str]&#39;
) -&gt; None:
    &#34;&#34;&#34;
    Internal to the interpreter. This is called with the static command
    handler containers belonging to the interpreter when the context is
    initialized.
    &#34;&#34;&#34;
    self._all_command_handlers = callhandler.ChoiceCallHandlerContainer(
        self.runtime_commands,
        interpreter_command_handlers
    )
    self._all_expansion_handlers = callhandler.ChoiceCallHandlerContainer(
        self.runtime_expansions,
        interpreter_expansion_handlers
    )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.open_file"><code class="name flex">
<span>def <span class="ident">open_file</span></span>(<span>self, path: str, mode: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a file for this context.</p>
<h2 id="returns">Returns</h2>
<p>A numeric file ID that should be used in other <code>*_file</code> functions
for <code><a title="scrolls.interpreter.state.InterpreterContext" href="#scrolls.interpreter.state.InterpreterContext">InterpreterContext</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_file(self, path: str, mode: str) -&gt; int:
    &#34;&#34;&#34;
    Opens a file for this context.

    Returns:
         A numeric file ID that should be used in other `*_file` functions
         for `scrolls.interpreter.state.InterpreterContext`.
    &#34;&#34;&#34;
    p = pathlib.Path(path)

    if not p.exists():
        raise interpreter_errors.InterpreterError(
            self,
            f&#34;{path} does not exist&#34;
        )

    if not p.is_file():
        raise interpreter_errors.InterpreterError(
            self,
            f&#34;{path} is not a file&#34;
        )

    # do not allow binary mode for now
    mode = mode.replace(&#34;b&#34;, &#34;&#34;)

    f = open(p, mode)
    self._open_files[self._fid] = f
    used_fid = self._fid
    self._fid += 1

    logger.debug(f&#34;Opened file: {path}&#34;)

    return used_fid</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.pop_call"><code class="name flex">
<span>def <span class="ident">pop_call</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Destroy the current call context, and replace it with the first context on the call stack.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.interpreter_errors.InternalInterpreterError" href="interpreter_errors.html#scrolls.interpreter.interpreter_errors.InternalInterpreterError">InternalInterpreterError</a></code></dt>
<dd>If not calls have been pushed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_call(self) -&gt; None:
    &#34;&#34;&#34;
    Destroy the current call context, and replace it with the first context on the call stack.

    .. WARNING::
        Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.

    Raises:
        scrolls.interpreter.interpreter_errors.InternalInterpreterError: If not calls have been pushed.
    &#34;&#34;&#34;
    if not self._call_stack:
        raise interpreter_errors.InternalInterpreterError(
            self,
            f&#34;Cannot pop call. No calls pushed.&#34;
        )

    ctx = self._call_stack.pop()
    self._call_context = ctx</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.push_call"><code class="name flex">
<span>def <span class="ident">push_call</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Duplicate the current call context and push it onto the call stack. Should be followed up with
<code><a title="scrolls.interpreter.state.InterpreterContext.set_call" href="#scrolls.interpreter.state.InterpreterContext.set_call">InterpreterContext.set_call()</a></code> to create a new context.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_call(self) -&gt; None:
    &#34;&#34;&#34;
    Duplicate the current call context and push it onto the call stack. Should be followed up with
    `scrolls.interpreter.state.InterpreterContext.set_call` to create a new context.

    .. WARNING::
        Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
    &#34;&#34;&#34;
    self._call_check()
    self._call_stack.append(self.call_context)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.set_base_call"><code class="name flex">
<span>def <span class="ident">set_base_call</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the current call context to the base call context for top level code.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_base_call(
        self
) -&gt; None:
    &#34;&#34;&#34;
    Sets the current call context to the base call context for top level code.

    .. WARNING::
        Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
    &#34;&#34;&#34;
    logger.debug(&#34;set_base_call&#34;)
    self._call_context = struct.CallContext(
        &#34;__main__&#34;,
        [],
        struct.ArgSourceMap(),
        None
    )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.set_call"><code class="name flex">
<span>def <span class="ident">set_call</span></span>(<span>self, command: str, args: Sequence[str], arg_nodes: <a title="scrolls.interpreter.struct.ArgSourceMap" href="struct.html#scrolls.interpreter.struct.ArgSourceMap">ArgSourceMap</a>, control_node: Optional[<a title="scrolls.ast.syntax.ASTNode" href="../ast/syntax.html#scrolls.ast.syntax.ASTNode">ASTNode</a>] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the current call context, overwriting whatever was previously current. If you want to preserve the
current context for later use, see <code><a title="scrolls.interpreter.state.InterpreterContext.push_call" href="#scrolls.interpreter.state.InterpreterContext.push_call">InterpreterContext.push_call()</a></code></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_call(
        self,
        command: str,
        args: t.Sequence[str],
        arg_nodes: struct.ArgSourceMap[ast.ASTNode],
        control_node: t.Optional[ast.ASTNode] = None
) -&gt; None:
    &#34;&#34;&#34;
    Sets the current call context, overwriting whatever was previously current. If you want to preserve the
    current context for later use, see `scrolls.interpreter.state.InterpreterContext.push_call`

    .. WARNING::
        Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
    &#34;&#34;&#34;
    self._call_context = struct.CallContext(
        command,
        args,
        arg_nodes,
        control_node
    )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.set_retval"><code class="name flex">
<span>def <span class="ident">set_retval</span></span>(<span>self, retval: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the return value in the first runtime call found in the stack.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.interpreter_errors.InterpreterError" href="interpreter_errors.html#scrolls.interpreter.interpreter_errors.InterpreterError">InterpreterError</a></code></dt>
<dd>If outside a call context, no call stack, or no runtime call contexts found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_retval(self, retval: str) -&gt; None:
    &#34;&#34;&#34;
    Sets the return value in the first runtime call found in the stack.

    Raises:
        scrolls.interpreter.interpreter_errors.InterpreterError: If outside a call context, no call stack, or no runtime call contexts found.
    &#34;&#34;&#34;
    self._call_check()

    if not self.call_stack:
        raise interpreter_errors.InterpreterError(
            self,
            f&#34;cannot return, no call stack (outside calls)&#34;
        )

    for ctx in reversed(self.call_stack):
        if ctx.runtime_call:
            ctx.return_value = retval
            return

    raise interpreter_errors.InterpreterError(
        self,
        f&#34;cannot return outside of function&#34;
    )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.state.InterpreterContext.set_var"><code class="name flex">
<span>def <span class="ident">set_var</span></span>(<span>self, name: str, value: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set a variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_var(self, name: str, value: str) -&gt; None:
    &#34;&#34;&#34;Set a variable.&#34;&#34;&#34;
    self.vars.set_var(name, value)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrolls.interpreter" href="index.html">scrolls.interpreter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrolls.interpreter.state.InterpreterContext" href="#scrolls.interpreter.state.InterpreterContext">InterpreterContext</a></code></h4>
<ul class="two-column">
<li><code><a title="scrolls.interpreter.state.InterpreterContext.all_commands" href="#scrolls.interpreter.state.InterpreterContext.all_commands">all_commands</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.all_expansions" href="#scrolls.interpreter.state.InterpreterContext.all_expansions">all_expansions</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.arg_nodes" href="#scrolls.interpreter.state.InterpreterContext.arg_nodes">arg_nodes</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.args" href="#scrolls.interpreter.state.InterpreterContext.args">args</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.call_context" href="#scrolls.interpreter.state.InterpreterContext.call_context">call_context</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.call_name" href="#scrolls.interpreter.state.InterpreterContext.call_name">call_name</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.call_stack" href="#scrolls.interpreter.state.InterpreterContext.call_stack">call_stack</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.close_file" href="#scrolls.interpreter.state.InterpreterContext.close_file">close_file</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.control_node" href="#scrolls.interpreter.state.InterpreterContext.control_node">control_node</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.current_node" href="#scrolls.interpreter.state.InterpreterContext.current_node">current_node</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.del_var" href="#scrolls.interpreter.state.InterpreterContext.del_var">del_var</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.get_backtrace" href="#scrolls.interpreter.state.InterpreterContext.get_backtrace">get_backtrace</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.get_file" href="#scrolls.interpreter.state.InterpreterContext.get_file">get_file</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.get_var" href="#scrolls.interpreter.state.InterpreterContext.get_var">get_var</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.init_handlers" href="#scrolls.interpreter.state.InterpreterContext.init_handlers">init_handlers</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.interpreter" href="#scrolls.interpreter.state.InterpreterContext.interpreter">interpreter</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.open_file" href="#scrolls.interpreter.state.InterpreterContext.open_file">open_file</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.parent_call_context" href="#scrolls.interpreter.state.InterpreterContext.parent_call_context">parent_call_context</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.pop_call" href="#scrolls.interpreter.state.InterpreterContext.pop_call">pop_call</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.push_call" href="#scrolls.interpreter.state.InterpreterContext.push_call">push_call</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.runtime_commands" href="#scrolls.interpreter.state.InterpreterContext.runtime_commands">runtime_commands</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.runtime_expansions" href="#scrolls.interpreter.state.InterpreterContext.runtime_expansions">runtime_expansions</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.set_base_call" href="#scrolls.interpreter.state.InterpreterContext.set_base_call">set_base_call</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.set_call" href="#scrolls.interpreter.state.InterpreterContext.set_call">set_call</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.set_retval" href="#scrolls.interpreter.state.InterpreterContext.set_retval">set_retval</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.set_var" href="#scrolls.interpreter.state.InterpreterContext.set_var">set_var</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.statement_count" href="#scrolls.interpreter.state.InterpreterContext.statement_count">statement_count</a></code></li>
<li><code><a title="scrolls.interpreter.state.InterpreterContext.vars" href="#scrolls.interpreter.state.InterpreterContext.vars">vars</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>