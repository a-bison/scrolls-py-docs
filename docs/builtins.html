<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scrolls.builtins API documentation</title>
<meta name="description" content="Built in Scrolls language features â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrolls.builtins</code></h1>
</header>
<section id="section-intro">
<p>Built in Scrolls language features.</p>
<h1 id="reading-this-reference">Reading This Reference</h1>
<p>This page serves as documentation for Scrolls' built in language features.
Functions defined by call handler classes define a scrolls call of the same name,
unless otherwise specified.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Built in Scrolls language features.

.. include:: pdoc/builtins.md
&#34;&#34;&#34;

import operator
import random
import typing as t

from . import ast, containers, datatypes, interpreter

__all__ = (
    &#34;StdIoCommandHandler&#34;,
    &#34;BuiltinControlHandler&#34;,
    &#34;BuiltinCommandHandler&#34;,
    &#34;RandomExpansionHandler&#34;,
    &#34;ArithmeticExpansionHandler&#34;,
    &#34;ComparisonExpansionHandler&#34;,
    &#34;LogicExpansionHandler&#34;,
    &#34;StringExpansionHandler&#34;,
    &#34;BuiltinInitializer&#34;,
    &#34;FileCommandHandler&#34;,
    &#34;FileExpansionHandler&#34;,
    &#34;base_config&#34;,
    &#34;file_config&#34;
)

base_config: containers.DecoratorInterpreterConfig = containers.DecoratorInterpreterConfig()
&#34;&#34;&#34;
A configuration object containing the Scrolls base language. This currently consists of:

- `BuiltinControlHandler`
- `BuiltinCommandHandler`
- `BuiltinInitializer`
- `ArithmeticExpansionHandler`
- `ComparisonExpansionHandler`
- `LogicExpansionHandler`
- `StringExpansionHandler`

.. WARNING::
    `print` and `input` are **not** defined as part of the base language, and must be added manually. See
    `StdIoCommandHandler`.
&#34;&#34;&#34;

file_config: containers.DecoratorInterpreterConfig = containers.DecoratorInterpreterConfig()
&#34;&#34;&#34;
A configuration object containing base Scrolls utilities for working with files.
Consists of:

- `FileExpansionHandler`
- `FileCommandHandler`
&#34;&#34;&#34;

class StdIoCommandHandler(interpreter.CallbackCommandHandler):
    &#34;&#34;&#34;
    Implements input and output commands using stdout/stdin.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;print&#34;, self.print)
        self.add_call(&#34;write&#34;, self.write)
        self.add_call(&#34;input&#34;, self.input)

    def print(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `print` command. Prints all arguments passed to it, joined by spaces.

        **Usage**
        ```scrolls
        print hello world foo bar
        ```
        &#34;&#34;&#34;
        print(&#34; &#34;.join(context.args))

    def write(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `write` command. Prints all arguments passed to it, joined
        by spaces. The difference vs. `print` is that `print` appends a newline,
        while `write` does not.

        **Usage**
        ```scrolls
        write hello world foo bar
        ```
        &#34;&#34;&#34;
        print(&#34; &#34;.join(context.args), end=&#34;&#34;)

    def input(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `input` command. Reads `stdin` for input, and stores the input in a variable named
        by the first argument.

        **Usage**
        ```scrolls
        input foo
        print $foo # prints what you entered
        ```
        &#34;&#34;&#34;
        if not context.args:
            raise interpreter.InterpreterError(
                context,
                &#34;input: variable name is not specified&#34;
            )

        result = input()
        context.set_var(context.args[0], result)


@file_config.commandhandler
class FileCommandHandler(interpreter.CallbackCommandHandler):
    &#34;&#34;&#34;
    Defines commands for working with files.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;file-close&#34;, self.close)

    def close(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements `file-close`. If you&#39;re looking for `file-open`, see
        `FileExpansionHandler.open`.

        **Usage**
        ```scrolls
        set f $(file-open file w)
        # do things to file...
        file-close $f
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        fid, _ = datatypes.require_numeric(context, context.args[0])
        context.close_file(int(fid))


@file_config.expansionhandler
class FileExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Defines expansions for working with files.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;file-open&#34;, self.open)
        self.add_call(&#34;file-read&#34;, self.read)

    def open(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `file-open`. If you&#39;re looking for `file-close`, see
        `FileCommandHandler.close`.

        `file-open` returns an integer ID used as a handle to the file.
        This ID should be saved and used for all `file-*` functions.

        **Usage**
        ```scrolls
        set f $(file-open file w)
        # do things to file...
        file-close $f
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)

        if len(context.args) &gt; 1:
            mode = context.args[1]
        else:
            # default is read
            mode = &#34;r&#34;

        return str(context.open_file(context.args[0], mode))

    def read(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `file-read`. Reads an entire file and returns a string.

        **Usage**
        ```scrolls
        set f $(file-open file w)
        print $(file-read $f)
        file-close $f
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        fid, _ = datatypes.require_numeric(context, context.args[0])

        f = context.get_file(int(fid))
        return f.read()


@base_config.initializer
class BuiltinInitializer(interpreter.Initializer):
    &#34;&#34;&#34;
    Sets built in constants, and initializes plumbing used by
    [`def`](#scrolls.builtins.BuiltinControlHandler.def_) and
    [`return`](#scrolls.builtins.BuiltinCommandHandler.return_).

    ### Variables
    - `$true` - A true boolean.
    - `$false` - A false boolean.
    &#34;&#34;&#34;
    def handle_call(self, context: interpreter.InterpreterContext) -&gt; None:
        context.set_var(&#34;true&#34;, datatypes.TRUE)
        context.set_var(&#34;false&#34;, datatypes.FALSE)
        context.runtime_commands.add(interpreter.RuntimeCallHandler(), &#34;__def__&#34;)
        context.runtime_expansions.add(interpreter.RuntimeCallHandler(), &#34;__def__&#34;)


@base_config.commandhandler
class BuiltinCommandHandler(interpreter.CallbackCommandHandler):
    &#34;&#34;&#34;
    Implements built-in command statements. In order for
    [`return`](#scrolls.builtins.BuiltinCommandHandler.return_)
    to be functional, `BuiltinControlHandler` and `BuiltinInitializer` must also be loaded.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;set&#34;, self.set)
        self.add_call(&#34;unset&#34;, self.unset)
        self.add_call(&#34;stop&#34;, self.stop)
        self.add_call(&#34;return&#34;, self.return_)
        self.add_call(&#34;nonlocal&#34;, self.nonlocal_)
        self.add_call(&#34;global&#34;, self.global_)

    def return_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `return` command. Returns all arguments passed to it as a single string, joined by spaces.
        If this command is present in a [`def`](#scrolls.builtins.BuiltinControlHandler.def_) block, that `def` block
        will define a new expansion call. Otherwise, it defines a command.

        Using this command outside a `def` block will result in an error.

        **Usage**
        ```scrolls
        !def(example foo) {
            return $foo
        }
        print $(example &#34;hello world&#34;)
        ```
        &#34;&#34;&#34;
        retval = &#34; &#34;.join(context.args)
        context.set_retval(retval)
        raise interpreter.InterpreterReturn()

    def set(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `set` command. Sets a variable. The first argument is the name of the variable. The rest of the
        arguments are joined by spaces and stored in the named variable.

        **Usage**
        ```scrolls
        set varname arg1 arg2 arg3
        print $varname # prints arg1 arg2 arg3
        ```
        &#34;&#34;&#34;
        if not context.args:
            raise interpreter.InterpreterError(
                context,
                &#34;set: variable name is not specified&#34;
            )

        context.set_var(context.args[0], &#34; &#34;.join(context.args[1:]))

    def unset(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `unset` command. Deletes a variable. The first argument is the name of the variable to delete.

        **Usage**
        ```scrolls
        set varname hello
        print $varname # prints hello
        unset varname
        print $varname # ERROR
        ```
        &#34;&#34;&#34;
        if not context.args:
            raise interpreter.InterpreterError(
                context,
                &#34;unset: variable name is not specified&#34;
            )

        try:
            context.del_var(context.args[0])
        except KeyError:
            raise interpreter.InterpreterError(
                context,
                f&#34;unset: no such variable {context.args[0]}&#34;
            )

    def nonlocal_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `nonlocal` command. Declares a variable as nonlocal, which allows variable references to modify
        variables in the enclosing scope.

        **Usage**
        ```scrolls
        !def(zero varname) {
            nonlocal $varname
            set $varname 0
        }
        !def(main) {
            set example 42
            zero example

            # &#34;0&#34; is printed, since example was declared nonlocal
            # in the zero function.
            print $example
        }

        set example 200
        main # prints &#34;0&#34;

        # Prints &#34;200&#34;, since the zero call in main only
        # modifies the DIRECTLY enclosing scope.
        print $example
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        context.vars.declare_nonlocal(context.args[0])

    def global_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `global` command. Declares a variable as global, which allows variable references to modify
        variables in the global scope.

        **Usage**
        ```scrolls
        !def(set_global varname *args) {
            global $varname
            set $varname $args
        }
        !def(main) {
            set_global example arg1 arg2 arg3
        }

        main

        # prints &#34;arg1 arg2 arg3&#34;, since main-&gt;set_global example
        # sets a variable in the global scope.
        print $example
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        context.vars.declare_global(context.args[0])

    def stop(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `stop` command. Stops the script execution. Takes no arguments.
        &#34;&#34;&#34;
        raise interpreter.InterpreterStop()


@base_config.controlhandler
class BuiltinControlHandler(interpreter.CallbackControlHandler):
    &#34;&#34;&#34;
    Implements built-in command statements. In order for
    [`def`](#scrolls.builtins.BuiltinControlHandler.def_)
    to be functional, `BuiltinCommandHandler` and `BuiltinInitializer` must also be loaded.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;repeat&#34;, self.repeat)
        self.add_call(&#34;for&#34;, self.for_)
        self.add_call(&#34;if&#34;, self.if_)
        self.add_call(&#34;while&#34;, self.while_)
        self.add_call(&#34;def&#34;, self.def_)

    def def_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `def` control structure. Allows the definition of new commands and expansion calls.
        The first argument is the name of the call to define. The rest of the arguments name the parameters to the
        call. The last parameter name may be prefixed with `*` to support variable arguments.

        **Usage**
        ```scrolls
        !def(example a b) {
            print &#34;a is&#34; $a
            print &#34;b is&#34; $b
        }

        # prints
        # a is foo
        # b is bar
        example foo bar

        !def(varargs_example x *args) {
            print &#34;x is&#34; $x
            print &#34;the rest of the args are:&#34;
            !for(i in $^args) print $i
        }

        # prints
        # x is 10
        # the rest of the args are:
        # foo
        # bar
        # baz
        varargs_example 10 foo bar baz
        ```
        &#34;&#34;&#34;
        args = context.args
        datatypes.require_arg_length(context, 1)

        command_calls = context.control_node.find_all(
            lambda node: (node.type == ast.ASTNodeType.COMMAND_CALL and
                          bool(node.children))
        )

        has_return = False
        for node in command_calls:
            name_node = node.children[0]

            if name_node.type == ast.ASTNodeType.STRING and name_node.str_content() == &#34;return&#34;:
                has_return = True
                break

        if has_return:
            t.cast(
                interpreter.RuntimeCallHandler[str],
                context.runtime_expansions.get(&#34;__def__&#34;)
            ).define(args[0], context.control_node, args[1:])
        else:
            t.cast(
                interpreter.RuntimeCallHandler[None],
                context.runtime_commands.get(&#34;__def__&#34;)
            ).define(args[0], context.control_node, args[1:])

    def repeat(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `repeat` control structure. Takes a single integer argument, that repeats the body n times.

        **Usage**
        ```scrolls
        # prints &#34;hello world&#34; 4 times
        !repeat(4) {
            print &#34;hello world&#34;
        }
        ```
        &#34;&#34;&#34;
        if len(context.args) != 1:
            raise interpreter.InterpreterError(
                context,
                &#34;repeat requires exactly one argument, the number of times to repeat&#34;
            )

        context.current_node = context.arg_nodes[0]

        try:
            repeat_times = int(context.args[0])
        except ValueError:
            raise interpreter.InterpreterError(
                context,
                f&#34;&#39;{context.args[0]}&#39; is not a valid integer&#34;
            )

        control_node = context.control_node
        for _ in range(repeat_times):
            context.interpreter.interpret_statement(context, control_node)

    def for_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `for` control structure. The syntax is as follows: `!for(VARNAME in VECTOR) ...`

        **Usage**
        ```scrolls
        # prints
        # 1
        # 2
        # 3
        # 4
        # 5
        !for(x in 1 2 3 4 5) {
            print $x
        }
        ```
        &#34;&#34;&#34;
        if not context.args or len(context.args) &lt; 3:
            raise interpreter.InterpreterError(
                context,
                &#34;bad format in !for: expected !for(VARNAME in ARGS)&#34;
            )

        var_name, _in, *items = context.args

        if _in != &#34;in&#34;:
            context.current_node = context.arg_nodes[1]
            raise interpreter.InterpreterError(
                context,
                f&#34;unexpected token &#39;{_in}&#39;, should be &#39;in&#39;&#34;
            )

        control_node = context.control_node
        for item in items:
            context.set_var(var_name, item)
            context.interpreter.interpret_statement(context, control_node)

        context.del_var(var_name)

    def if_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `if` control structure. Takes one argument, a boolean. If it&#39;s `scrolls.datatypes.TRUE`,
        executes the body statement. Otherwise, the body is skipped. `else` is not supported.

        **Usage**
        ```scrolls
        !if($true) {
            print &#34;this will print&#34;
        }
        !if($false) {
            print &#34;this will not print&#34;
        }
        ```
        &#34;&#34;&#34;
        if len(context.args) != 1:
            raise interpreter.InterpreterError(
                context,
                f&#34;if: needs one and only one argument&#34;
            )

        if datatypes.str_to_bool(context.args[0]):
            context.interpreter.interpret_statement(context, context.control_node)

    def while_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `while` control structure. Takes one argument, a boolean. Repeats the body while
        the condition is `scrolls.datatypes.TRUE`.

        **Usage**
        ```scrolls
        # counting down from 10 to 1
        set i 10
        !while($(&gt; 0 $i)) {
            print $i
            set i $(- $i 1)
        }
        ```
        &#34;&#34;&#34;
        if len(context.args) != 1:
            raise interpreter.InterpreterError(
                context,
                f&#34;while: needs one and only one argument&#34;
            )

        arg = context.args[0]

        while datatypes.str_to_bool(arg):
            context.interpreter.interpret_statement(context, context.control_node)

            # HACK:
            # In order for while to work right, we need to re-evaluate the argument
            # every time.
            arg = context.interpreter.interpret_string_or_expansion(context, context.arg_nodes[0])[0]


class RandomExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Implements random expansions.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;select&#34;, self.select)
        self.add_call(&#34;shuffle&#34;, self.shuffle)
        self.add_call(&#34;uniform&#34;, self.uniform)

    def select(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `select` expansion. Randomly selects one of the arguments and returns it.

        **Usage**
        ```scrolls
        # randomly prints either foo, bar, or baz
        print $(select foo bar baz)
        ```
        &#34;&#34;&#34;
        return random.choice(context.args)

    def shuffle(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `shuffle` expansion. Shuffle the arguments given and return them.

        **Usage**
        ```scrolls
        print $(shuffle 1 2 3 4 5)
        ```
        &#34;&#34;&#34;
        args = list(context.args)
        random.shuffle(args)
        return &#34; &#34;.join(args)

    def uniform(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `uniform` expansion. Returns a random floating point number between two bounds, inclusive.

        **Usage**
        ```scrolls
        print $(uniform 0 2) # print a random float between 0 and 2.
        ```
        &#34;&#34;&#34;
        if len(context.args) != 2:
            raise interpreter.InterpreterError(
                context,
                f&#34;uniform: must have two args. (got {&#39;, &#39;.join(context.args)})&#34;
            )

        try:
            lower = float(context.args[0])
            upper = float(context.args[1])
        except ValueError as e:
            raise interpreter.InterpreterError(
                context,
                f&#34;uniform: {str(e)}&#34;
            )

        return str(random.uniform(lower, upper))


@base_config.expansionhandler
class ArithmeticExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Implements basic arithmetic expansions. These aren&#39;t very efficient, but
    if you want efficiency, you shouldn&#39;t be using an interpreted language
    with no JIT being interpreted by another interpreted language `:)`.

    Most of these are self-explanatory. Examples will be provided where appropriate.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;toint&#34;, self.toint)
        self.add_call(&#34;tofloat&#34;, self.tofloat)
        self.add_call(&#34;+&#34;, self.add)
        self.add_call(&#34;-&#34;, self.sub)
        self.add_call(&#34;*&#34;, self.mul)
        self.add_call(&#34;/&#34;, self.div)
        self.add_call(&#34;//&#34;, self.intdiv)
        self.add_call(&#34;%&#34;, self.mod)

    @staticmethod
    def __unary(context: interpreter.InterpreterContext, op: datatypes.UnaryNumOpT) -&gt; str:
        return str(datatypes.apply_unary_num_op(context, op)[0])

    @staticmethod
    def __binary(context: interpreter.InterpreterContext, op: datatypes.BinaryNumOpT) -&gt; str:
        return str(datatypes.apply_binary_num_op(context, op)[0])

    @staticmethod
    def __mass(
        context: interpreter.InterpreterContext,
        reduce_op: datatypes.BinaryNumOpT,
        final_op: datatypes.BinaryNumOpT
    ) -&gt; str:
        return str(datatypes.apply_mass_binary_num_op(context, reduce_op, final_op)[0])

    @staticmethod
    def __reduce(
        context: interpreter.InterpreterContext,
        reduce_op: datatypes.BinaryNumOpT
    ) -&gt; str:
        return str(datatypes.apply_reduce_binary_num_op(context, reduce_op)[0])

    def sub(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `-`.

        **Usage**
        ```scrolls
        print $(- 4) # negate a number
        print $(- 10 3) # subtract 3 from 10
        print $(- 10 1 2 3) # subtract 1, 2, and 3 from 10.
        ```
        &#34;&#34;&#34;
        # Sub behaves a little differently. If only one arg, negate instead of subtracting.
        if len(context.args) == 1:
            return self.__unary(context, operator.neg)

        return self.__mass(context, reduce_op=operator.add, final_op=operator.sub)

    def toint(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `toint`. Forces a number to be an integer. If the input is a float, the decimal point
        will be truncated.
        &#34;&#34;&#34;
        return self.__unary(context, datatypes.toint)

    def tofloat(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `tofloat`. Forces a number to be a float.
        &#34;&#34;&#34;
        return self.__unary(context, datatypes.tofloat)

    def add(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `+`. `+` will take 2 or more arguments, and sum them all together.

        **Usage**
        ```scrolls
        print $(+ 2 3)
        print $(+ 1 10 34)
        ```
        &#34;&#34;&#34;
        return self.__reduce(context, operator.add)

    def mul(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `*`. `*` will take 2 or more arguments, and multiplies them all together.

        **Usage**
        ```scrolls
        print $(* 2 3)
        print $(* 1 10 34)
        ```
        &#34;&#34;&#34;
        return self.__reduce(context, operator.mul)

    def div(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `/`.

        **Usage**
        ```scrolls
        print $(/ 6 2) # prints 3.0
        print $(/ 20 2 5) # divides 20 by 2, then by 5. prints 2.0
        ```
        &#34;&#34;&#34;
        return self.__mass(context, reduce_op=operator.mul, final_op=operator.truediv)

    def intdiv(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `//` (integer division).

        **Usage**
        ```scrolls
        print $(// 5 2) # prints 2.
        print $(// 20 2 3) # divides 20 by 2*3 (6), (3.3333...), then truncates float part. prints 3.
        ```
        &#34;&#34;&#34;
        return self.__mass(context, reduce_op=operator.mul, final_op=operator.floordiv)

    def mod(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `%` (modulo). Takes only two arguments.

        **Usage**
        ```scrolls
        print $(% 5 2) # prints 1.
        ```
        &#34;&#34;&#34;
        return self.__binary(context, operator.mod)


@base_config.expansionhandler
class ComparisonExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Implements basic comparison operators.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;eq?&#34;, self.equals)
        self.add_alias(&#34;==&#34;, &#34;eq?&#34;)
        self.add_call(&#34;neq?&#34;, self.not_equals)
        self.add_call(&#34;===&#34;, self.str_equals)
        self.add_call(&#34;&gt;&#34;, self.gt)
        self.add_call(&#34;&lt;&#34;, self.lt)
        self.add_call(&#34;&gt;=&#34;, self.gte)
        self.add_call(&#34;&lt;=&#34;, self.lte)
        self.add_call(&#34;in?&#34;, self._in)

    def __equals_bool(self, context: interpreter.InterpreterContext) -&gt; bool:
        args = context.args
        if len(args) != 2:
            raise interpreter.InterpreterError(
                context,
                f&#34;{context.call_name}: must have exactly 2 args&#34;
            )

        try:
            num_args, _ = datatypes.require_all_numeric(context, args)
            return num_args[0] == num_args[1]
        except interpreter.InterpreterError:
            return args[0] == args[1]

    def __get_numeric_compare_args(self, context: interpreter.InterpreterContext) -&gt; t.Tuple[float, float]:
        args = context.args
        if len(args) != 2:
            raise interpreter.InterpreterError(
                context,
                f&#34;{context.call_name}: must have exactly 2 args&#34;
            )

        (a, b), _ = datatypes.require_all_numeric(context, args)

        return a, b

    def str_equals(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `===`. Takes only two arguments.

        `===` is the strong comparison operator. It only operates on strings,
        and no implicit conversion is done.

        Contrast with the behavior of `ComparisonExpansionHandler.equals`.

        **Usage**
        ```scrolls
        print $(=== 0123 123) # prints 0
        print $(=== hello hello) # prints 0
        ```
        &#34;&#34;&#34;
        args = context.args
        if len(args) != 2:
            raise interpreter.InterpreterError(
                context,
                f&#34;{context.call_name}: must have exactly 2 args&#34;
            )

        return datatypes.bool_to_str(args[0] == args[1])

    def equals(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `==`, or `eq?`. Takes only two arguments.

        `==` is a weak comparison operator. If both arguments can be interpreted numerically, they will be converted
        to numbers before testing for equivalence. Otherwise, `==` just tests if the strings passed are equal.

        Contrast with the behavior of `ComparisonExpansionHandler.str_equals`.

        **Usage**
        ```scrolls
        print $(eq? 0123 123) # prints 1, numeric comparison
        print $(eq? hello hello) # prints 1, string comparison
        ```
        &#34;&#34;&#34;
        return datatypes.bool_to_str(self.__equals_bool(context))

    def not_equals(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `ne?`. Note this is not aliased to `!=` due to `!` being a reserved character. Takes only two arguments.

        Same as with `ComparisonExpansionHandler.equals`, this operator implicitly converts to numbers when possible.

        **Usage**
        ```scrolls
        print $(ne? 0123 123) # prints 0, numeric comparison
        print $(ne? hello world) # prints 1, string comparison
        ```
        &#34;&#34;&#34;
        return datatypes.bool_to_str(not self.__equals_bool(context))

    def gt(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `&gt;`. Takes only two arguments, both must be numeric.

        **Usage**
        ```scrolls
        print $(&gt; 0 3) # prints 1.
        ```
        &#34;&#34;&#34;
        a, b = self.__get_numeric_compare_args(context)
        return datatypes.bool_to_str(a &gt; b)

    def lt(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `&lt;`. Takes only two arguments, both must be numeric.

        **Usage**
        ```scrolls
        print $(&lt; 4 10) # prints 1.
        ```
        &#34;&#34;&#34;
        a, b = self.__get_numeric_compare_args(context)
        return datatypes.bool_to_str(a &lt; b)

    def gte(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `&gt;=`. Takes only two arguments, both must be numeric.

        **Usage**
        ```scrolls
        print $(&gt;= 10 4) # prints 1.
        print $(&gt;= 4 4) # prints 1.
        ```
        &#34;&#34;&#34;
        a, b = self.__get_numeric_compare_args(context)
        return datatypes.bool_to_str(a &gt;= b)

    def lte(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `&lt;=`. Takes only two arguments, both must be numeric.

        **Usage**
        ```scrolls
        print $(&lt;= 4 10) # prints 1.
        print $(&lt;= 4 4) # prints 1.
        ```
        &#34;&#34;&#34;
        a, b = self.__get_numeric_compare_args(context)
        return datatypes.bool_to_str(a &lt;= b)

    def _in(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `in?`. Takes at least one argument.

        **Usage**
        ```scrolls
        # in? x args...
        # Tests if x is in the following arguments.
        print $(in? blah) # always returns &#39;0&#39;.
        print $(in? bar foo bar baz) # returns &#39;1&#39;.
        ```
        &#34;&#34;&#34;
        if len(context.args) == 0:
            raise interpreter.InterpreterError(
                context,
                f&#34;{context.call_name} requires at least one argument&#34;
            )

        return datatypes.bool_to_str(context.args[0] in context.args[1:])


@base_config.expansionhandler
class LogicExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Implements basic logic operators.

    Related:
        `scrolls.datatypes.TRUE`
        `scrolls.datatypes.FALSE`
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;not&#34;, self.not_)
        self.add_call(&#34;and&#34;, self.and_)
        self.add_call(&#34;or&#34;, self.or_)
        self.add_call(&#34;xor&#34;, self.xor_)

    @staticmethod
    def __unary(context: interpreter.InterpreterContext, op: datatypes.UnaryNumOpT) -&gt; str:
        return datatypes.bool_to_str(datatypes.apply_unary_bool_op(context, op))

    @staticmethod
    def __reduce(context: interpreter.InterpreterContext, op: datatypes.BinaryNumOpT) -&gt; str:
        return datatypes.bool_to_str(datatypes.apply_reduce_bool_op(context, op))

    def not_(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `not` operator.

        **Usage**
        ```scrolls
        print $(not $true) # prints 0.
        ```
        &#34;&#34;&#34;
        return self.__unary(context, operator.not_)

    def and_(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `and` operator. Takes 2 or more arguments, and `and`s them all together.

        **Usage**
        ```scrolls
        print $(and $true $false $true) # prints 0.
        print $(and $true $true) # prints 1.
        ```
        &#34;&#34;&#34;
        return self.__reduce(context, operator.and_)

    def or_(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `or` operator. Takes 2 or more arguments, and `or`s them all together.

        **Usage**
        ```scrolls
        print $(or $true $false $true) # prints 1.
        print $(or $false $false) # prints 0.
        ```
        &#34;&#34;&#34;
        return self.__reduce(context, operator.or_)

    def xor_(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `xor` operator. Takes 2 or more arguments. With 2 arguments, `xor` performs a standard XOR
        operation. With more arguments, `xor` will perform a parity check. It will return `scrolls.datatypes.TRUE`
        for an odd number of `scrolls.datatypes.TRUE` inputs, and `scrolls.datatypes.FALSE` for an even number of
        `scrolls.datatypes.TRUE` inputs.

        **Usage**
        ```scrolls
        print $(xor $true $false) # prints 1.
        print $(xor $true $false $true) # prints 0.
        ```
        &#34;&#34;&#34;
        return self.__reduce(context, operator.xor)


@base_config.expansionhandler
class StringExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Implements basic string manipulation expansions.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;cat&#34;, self.concat)
        self.add_alias(&#34;concat&#34;, &#34;cat&#34;)
        self.add_call(&#34;getc&#34;, self.getc)
        self.add_call(&#34;len&#34;, self.len)
        self.add_call(&#34;ord&#34;, self.ord)
        self.add_call(&#34;chr&#34;, self.chr)
        self.add_call(&#34;vempty?&#34;, self.vempty)
        self.add_call(&#34;vhead&#34;, self.vhead)
        self.add_call(&#34;vtail&#34;, self.vtail)
        self.add_call(&#34;rangev&#34;, self.rangev)

    def concat(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `cat`. Concatenates all arguments into one string and returns it. Commonly used to concatenate
        punctuation onto variable output.

        **Usage**
        ```scrolls
        set example &#34;Hello world&#34;
        print $(cat $example &#34;!&#34;) # prints Hello World!
        ```
        &#34;&#34;&#34;
        return &#34;&#34;.join(context.args)

    def getc(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `getc`. Gets a single character from a string, starting at 0.

        **Usage**
        ```scrolls
        set example &#34;Hello&#34;
        print $(getc $example 4) # prints &#39;o&#39;
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 2)
        n = int(datatypes.require_numeric(context, context.args[1])[0])

        return context.args[0][n]

    def len(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `len`. Gets the length of the passed string.

        **Usage**
        ```scrolls
        print $(len &#34;hello&#34;) # prints 5
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        return str(len(context.args[0]))

    def ord(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `ord`. Converts a single character to its integer equivalent.

        **Usage**
        ```scrolls
        print $(ord &#34;h&#34;) # prints 104
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        return str(ord(context.args[0]))

    def chr(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `chr`. Converts a number into the character it corresponds to.

        **Usage**
        ```scrolls
        print $(chr 104) # prints h
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        c = int(datatypes.require_numeric(context, context.args[0])[0])
        return chr(c)

    def vempty(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `vempty?`. Returns `scrolls.datatypes.TRUE` if the passed vector is empty.

        **Usage**
        ```scrolls
        set empty_vec &#34;&#34;
        print $(vempty? $empty_vec) # prints 1.
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        return datatypes.bool_to_str(not bool(context.args[0]))

    def vhead(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `vhead`. Returns the first element of a vector (the leftmost element).

        **Usage**
        ```scrolls
        set vec &#34;2 4 8 16&#34;
        print $(vhead $vec) # prints 2.
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        return context.args[0].split(maxsplit=1)[0]

    def vtail(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `vtail`. Returns every element of a vector except the first.

        **Usage**
        ```scrolls
        set vec &#34;2 4 8 16&#34;
        print $(vtail $vec) # prints 4 8 16.
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        return &#34;&#34;.join(context.args[0].split(maxsplit=1)[1:])

    def rangev(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `rangev`. Returns a vector consisting of a range of numbers.

        **Usage**
        ```scrolls
        set min 0
        set max 4
        print $(rangev $min $max) # prints 0 1 2 3
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 2)
        (a, b, *rest), _ = datatypes.require_all_numeric(context, context.args)

        a = int(a)
        b = int(b)

        return &#34; &#34;.join([str(x) for x in range(a, b)])</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="scrolls.builtins.base_config"><code class="name">var <span class="ident">base_config</span> :Â <a title="scrolls.containers.DecoratorInterpreterConfig" href="containers.html#scrolls.containers.DecoratorInterpreterConfig">DecoratorInterpreterConfig</a></code></dt>
<dd>
<div class="desc"><p>A configuration object containing the Scrolls base language. This currently consists of:</p>
<ul>
<li><code><a title="scrolls.builtins.BuiltinControlHandler" href="#scrolls.builtins.BuiltinControlHandler">BuiltinControlHandler</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinCommandHandler" href="#scrolls.builtins.BuiltinCommandHandler">BuiltinCommandHandler</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinInitializer" href="#scrolls.builtins.BuiltinInitializer">BuiltinInitializer</a></code></li>
<li><code><a title="scrolls.builtins.ArithmeticExpansionHandler" href="#scrolls.builtins.ArithmeticExpansionHandler">ArithmeticExpansionHandler</a></code></li>
<li><code><a title="scrolls.builtins.ComparisonExpansionHandler" href="#scrolls.builtins.ComparisonExpansionHandler">ComparisonExpansionHandler</a></code></li>
<li><code><a title="scrolls.builtins.LogicExpansionHandler" href="#scrolls.builtins.LogicExpansionHandler">LogicExpansionHandler</a></code></li>
<li><code><a title="scrolls.builtins.StringExpansionHandler" href="#scrolls.builtins.StringExpansionHandler">StringExpansionHandler</a></code></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code>print</code> and <code>input</code> are <strong>not</strong> defined as part of the base language, and must be added manually. See
<code><a title="scrolls.builtins.StdIoCommandHandler" href="#scrolls.builtins.StdIoCommandHandler">StdIoCommandHandler</a></code>.</p>
</div></div>
</dd>
<dt id="scrolls.builtins.file_config"><code class="name">var <span class="ident">file_config</span> :Â <a title="scrolls.containers.DecoratorInterpreterConfig" href="containers.html#scrolls.containers.DecoratorInterpreterConfig">DecoratorInterpreterConfig</a></code></dt>
<dd>
<div class="desc"><p>A configuration object containing base Scrolls utilities for working with files.
Consists of:</p>
<ul>
<li><code><a title="scrolls.builtins.FileExpansionHandler" href="#scrolls.builtins.FileExpansionHandler">FileExpansionHandler</a></code></li>
<li><code><a title="scrolls.builtins.FileCommandHandler" href="#scrolls.builtins.FileCommandHandler">FileCommandHandler</a></code></li>
</ul></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrolls.builtins.ArithmeticExpansionHandler"><code class="flex name class">
<span>class <span class="ident">ArithmeticExpansionHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Implements basic arithmetic expansions. These aren't very efficient, but
if you want efficiency, you shouldn't be using an interpreted language
with no JIT being interpreted by another interpreted language <code>:)</code>.</p>
<p>Most of these are self-explanatory. Examples will be provided where appropriate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@base_config.expansionhandler
class ArithmeticExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Implements basic arithmetic expansions. These aren&#39;t very efficient, but
    if you want efficiency, you shouldn&#39;t be using an interpreted language
    with no JIT being interpreted by another interpreted language `:)`.

    Most of these are self-explanatory. Examples will be provided where appropriate.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;toint&#34;, self.toint)
        self.add_call(&#34;tofloat&#34;, self.tofloat)
        self.add_call(&#34;+&#34;, self.add)
        self.add_call(&#34;-&#34;, self.sub)
        self.add_call(&#34;*&#34;, self.mul)
        self.add_call(&#34;/&#34;, self.div)
        self.add_call(&#34;//&#34;, self.intdiv)
        self.add_call(&#34;%&#34;, self.mod)

    @staticmethod
    def __unary(context: interpreter.InterpreterContext, op: datatypes.UnaryNumOpT) -&gt; str:
        return str(datatypes.apply_unary_num_op(context, op)[0])

    @staticmethod
    def __binary(context: interpreter.InterpreterContext, op: datatypes.BinaryNumOpT) -&gt; str:
        return str(datatypes.apply_binary_num_op(context, op)[0])

    @staticmethod
    def __mass(
        context: interpreter.InterpreterContext,
        reduce_op: datatypes.BinaryNumOpT,
        final_op: datatypes.BinaryNumOpT
    ) -&gt; str:
        return str(datatypes.apply_mass_binary_num_op(context, reduce_op, final_op)[0])

    @staticmethod
    def __reduce(
        context: interpreter.InterpreterContext,
        reduce_op: datatypes.BinaryNumOpT
    ) -&gt; str:
        return str(datatypes.apply_reduce_binary_num_op(context, reduce_op)[0])

    def sub(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `-`.

        **Usage**
        ```scrolls
        print $(- 4) # negate a number
        print $(- 10 3) # subtract 3 from 10
        print $(- 10 1 2 3) # subtract 1, 2, and 3 from 10.
        ```
        &#34;&#34;&#34;
        # Sub behaves a little differently. If only one arg, negate instead of subtracting.
        if len(context.args) == 1:
            return self.__unary(context, operator.neg)

        return self.__mass(context, reduce_op=operator.add, final_op=operator.sub)

    def toint(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `toint`. Forces a number to be an integer. If the input is a float, the decimal point
        will be truncated.
        &#34;&#34;&#34;
        return self.__unary(context, datatypes.toint)

    def tofloat(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `tofloat`. Forces a number to be a float.
        &#34;&#34;&#34;
        return self.__unary(context, datatypes.tofloat)

    def add(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `+`. `+` will take 2 or more arguments, and sum them all together.

        **Usage**
        ```scrolls
        print $(+ 2 3)
        print $(+ 1 10 34)
        ```
        &#34;&#34;&#34;
        return self.__reduce(context, operator.add)

    def mul(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `*`. `*` will take 2 or more arguments, and multiplies them all together.

        **Usage**
        ```scrolls
        print $(* 2 3)
        print $(* 1 10 34)
        ```
        &#34;&#34;&#34;
        return self.__reduce(context, operator.mul)

    def div(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `/`.

        **Usage**
        ```scrolls
        print $(/ 6 2) # prints 3.0
        print $(/ 20 2 5) # divides 20 by 2, then by 5. prints 2.0
        ```
        &#34;&#34;&#34;
        return self.__mass(context, reduce_op=operator.mul, final_op=operator.truediv)

    def intdiv(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `//` (integer division).

        **Usage**
        ```scrolls
        print $(// 5 2) # prints 2.
        print $(// 20 2 3) # divides 20 by 2*3 (6), (3.3333...), then truncates float part. prints 3.
        ```
        &#34;&#34;&#34;
        return self.__mass(context, reduce_op=operator.mul, final_op=operator.floordiv)

    def mod(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `%` (modulo). Takes only two arguments.

        **Usage**
        ```scrolls
        print $(% 5 2) # prints 1.
        ```
        &#34;&#34;&#34;
        return self.__binary(context, operator.mod)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.builtins.ArithmeticExpansionHandler.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>+</code>. <code>+</code> will take 2 or more arguments, and sum them all together.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(+ 2 3)
print $(+ 1 10 34)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `+`. `+` will take 2 or more arguments, and sum them all together.

    **Usage**
    ```scrolls
    print $(+ 2 3)
    print $(+ 1 10 34)
    ```
    &#34;&#34;&#34;
    return self.__reduce(context, operator.add)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ArithmeticExpansionHandler.div"><code class="name flex">
<span>def <span class="ident">div</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>/</code>.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(/ 6 2) # prints 3.0
print $(/ 20 2 5) # divides 20 by 2, then by 5. prints 2.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def div(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `/`.

    **Usage**
    ```scrolls
    print $(/ 6 2) # prints 3.0
    print $(/ 20 2 5) # divides 20 by 2, then by 5. prints 2.0
    ```
    &#34;&#34;&#34;
    return self.__mass(context, reduce_op=operator.mul, final_op=operator.truediv)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ArithmeticExpansionHandler.intdiv"><code class="name flex">
<span>def <span class="ident">intdiv</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>//</code> (integer division).</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(// 5 2) # prints 2.
print $(// 20 2 3) # divides 20 by 2*3 (6), (3.3333...), then truncates float part. prints 3.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intdiv(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `//` (integer division).

    **Usage**
    ```scrolls
    print $(// 5 2) # prints 2.
    print $(// 20 2 3) # divides 20 by 2*3 (6), (3.3333...), then truncates float part. prints 3.
    ```
    &#34;&#34;&#34;
    return self.__mass(context, reduce_op=operator.mul, final_op=operator.floordiv)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ArithmeticExpansionHandler.mod"><code class="name flex">
<span>def <span class="ident">mod</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>%</code> (modulo). Takes only two arguments.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(% 5 2) # prints 1.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mod(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `%` (modulo). Takes only two arguments.

    **Usage**
    ```scrolls
    print $(% 5 2) # prints 1.
    ```
    &#34;&#34;&#34;
    return self.__binary(context, operator.mod)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ArithmeticExpansionHandler.mul"><code class="name flex">
<span>def <span class="ident">mul</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>*</code>. <code>*</code> will take 2 or more arguments, and multiplies them all together.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(* 2 3)
print $(* 1 10 34)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mul(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `*`. `*` will take 2 or more arguments, and multiplies them all together.

    **Usage**
    ```scrolls
    print $(* 2 3)
    print $(* 1 10 34)
    ```
    &#34;&#34;&#34;
    return self.__reduce(context, operator.mul)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ArithmeticExpansionHandler.sub"><code class="name flex">
<span>def <span class="ident">sub</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>-</code>.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(- 4) # negate a number
print $(- 10 3) # subtract 3 from 10
print $(- 10 1 2 3) # subtract 1, 2, and 3 from 10.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sub(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `-`.

    **Usage**
    ```scrolls
    print $(- 4) # negate a number
    print $(- 10 3) # subtract 3 from 10
    print $(- 10 1 2 3) # subtract 1, 2, and 3 from 10.
    ```
    &#34;&#34;&#34;
    # Sub behaves a little differently. If only one arg, negate instead of subtracting.
    if len(context.args) == 1:
        return self.__unary(context, operator.neg)

    return self.__mass(context, reduce_op=operator.add, final_op=operator.sub)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ArithmeticExpansionHandler.tofloat"><code class="name flex">
<span>def <span class="ident">tofloat</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>tofloat</code>. Forces a number to be a float.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tofloat(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `tofloat`. Forces a number to be a float.
    &#34;&#34;&#34;
    return self.__unary(context, datatypes.tofloat)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ArithmeticExpansionHandler.toint"><code class="name flex">
<span>def <span class="ident">toint</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>toint</code>. Forces a number to be an integer. If the input is a float, the decimal point
will be truncated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toint(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `toint`. Forces a number to be an integer. If the input is a float, the decimal point
    will be truncated.
    &#34;&#34;&#34;
    return self.__unary(context, datatypes.toint)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.builtins.BuiltinCommandHandler"><code class="flex name class">
<span>class <span class="ident">BuiltinCommandHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Implements built-in command statements. In order for
<a href="#scrolls.builtins.BuiltinCommandHandler.return_"><code>return</code></a>
to be functional, <code><a title="scrolls.builtins.BuiltinControlHandler" href="#scrolls.builtins.BuiltinControlHandler">BuiltinControlHandler</a></code> and <code><a title="scrolls.builtins.BuiltinInitializer" href="#scrolls.builtins.BuiltinInitializer">BuiltinInitializer</a></code> must also be loaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@base_config.commandhandler
class BuiltinCommandHandler(interpreter.CallbackCommandHandler):
    &#34;&#34;&#34;
    Implements built-in command statements. In order for
    [`return`](#scrolls.builtins.BuiltinCommandHandler.return_)
    to be functional, `BuiltinControlHandler` and `BuiltinInitializer` must also be loaded.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;set&#34;, self.set)
        self.add_call(&#34;unset&#34;, self.unset)
        self.add_call(&#34;stop&#34;, self.stop)
        self.add_call(&#34;return&#34;, self.return_)
        self.add_call(&#34;nonlocal&#34;, self.nonlocal_)
        self.add_call(&#34;global&#34;, self.global_)

    def return_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `return` command. Returns all arguments passed to it as a single string, joined by spaces.
        If this command is present in a [`def`](#scrolls.builtins.BuiltinControlHandler.def_) block, that `def` block
        will define a new expansion call. Otherwise, it defines a command.

        Using this command outside a `def` block will result in an error.

        **Usage**
        ```scrolls
        !def(example foo) {
            return $foo
        }
        print $(example &#34;hello world&#34;)
        ```
        &#34;&#34;&#34;
        retval = &#34; &#34;.join(context.args)
        context.set_retval(retval)
        raise interpreter.InterpreterReturn()

    def set(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `set` command. Sets a variable. The first argument is the name of the variable. The rest of the
        arguments are joined by spaces and stored in the named variable.

        **Usage**
        ```scrolls
        set varname arg1 arg2 arg3
        print $varname # prints arg1 arg2 arg3
        ```
        &#34;&#34;&#34;
        if not context.args:
            raise interpreter.InterpreterError(
                context,
                &#34;set: variable name is not specified&#34;
            )

        context.set_var(context.args[0], &#34; &#34;.join(context.args[1:]))

    def unset(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `unset` command. Deletes a variable. The first argument is the name of the variable to delete.

        **Usage**
        ```scrolls
        set varname hello
        print $varname # prints hello
        unset varname
        print $varname # ERROR
        ```
        &#34;&#34;&#34;
        if not context.args:
            raise interpreter.InterpreterError(
                context,
                &#34;unset: variable name is not specified&#34;
            )

        try:
            context.del_var(context.args[0])
        except KeyError:
            raise interpreter.InterpreterError(
                context,
                f&#34;unset: no such variable {context.args[0]}&#34;
            )

    def nonlocal_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `nonlocal` command. Declares a variable as nonlocal, which allows variable references to modify
        variables in the enclosing scope.

        **Usage**
        ```scrolls
        !def(zero varname) {
            nonlocal $varname
            set $varname 0
        }
        !def(main) {
            set example 42
            zero example

            # &#34;0&#34; is printed, since example was declared nonlocal
            # in the zero function.
            print $example
        }

        set example 200
        main # prints &#34;0&#34;

        # Prints &#34;200&#34;, since the zero call in main only
        # modifies the DIRECTLY enclosing scope.
        print $example
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        context.vars.declare_nonlocal(context.args[0])

    def global_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `global` command. Declares a variable as global, which allows variable references to modify
        variables in the global scope.

        **Usage**
        ```scrolls
        !def(set_global varname *args) {
            global $varname
            set $varname $args
        }
        !def(main) {
            set_global example arg1 arg2 arg3
        }

        main

        # prints &#34;arg1 arg2 arg3&#34;, since main-&gt;set_global example
        # sets a variable in the global scope.
        print $example
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        context.vars.declare_global(context.args[0])

    def stop(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `stop` command. Stops the script execution. Takes no arguments.
        &#34;&#34;&#34;
        raise interpreter.InterpreterStop()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.builtins.BuiltinCommandHandler.global_"><code class="name flex">
<span>def <span class="ident">global_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>global</code> command. Declares a variable as global, which allows variable references to modify
variables in the global scope.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">!def(set_global varname *args) {
    global $varname
    set $varname $args
}
!def(main) {
    set_global example arg1 arg2 arg3
}

main

# prints &quot;arg1 arg2 arg3&quot;, since main-&gt;set_global example
# sets a variable in the global scope.
print $example
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `global` command. Declares a variable as global, which allows variable references to modify
    variables in the global scope.

    **Usage**
    ```scrolls
    !def(set_global varname *args) {
        global $varname
        set $varname $args
    }
    !def(main) {
        set_global example arg1 arg2 arg3
    }

    main

    # prints &#34;arg1 arg2 arg3&#34;, since main-&gt;set_global example
    # sets a variable in the global scope.
    print $example
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)
    context.vars.declare_global(context.args[0])</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.BuiltinCommandHandler.nonlocal_"><code class="name flex">
<span>def <span class="ident">nonlocal_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>nonlocal</code> command. Declares a variable as nonlocal, which allows variable references to modify
variables in the enclosing scope.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">!def(zero varname) {
    nonlocal $varname
    set $varname 0
}
!def(main) {
    set example 42
    zero example

    # &quot;0&quot; is printed, since example was declared nonlocal
    # in the zero function.
    print $example
}

set example 200
main # prints &quot;0&quot;

# Prints &quot;200&quot;, since the zero call in main only
# modifies the DIRECTLY enclosing scope.
print $example
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nonlocal_(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `nonlocal` command. Declares a variable as nonlocal, which allows variable references to modify
    variables in the enclosing scope.

    **Usage**
    ```scrolls
    !def(zero varname) {
        nonlocal $varname
        set $varname 0
    }
    !def(main) {
        set example 42
        zero example

        # &#34;0&#34; is printed, since example was declared nonlocal
        # in the zero function.
        print $example
    }

    set example 200
    main # prints &#34;0&#34;

    # Prints &#34;200&#34;, since the zero call in main only
    # modifies the DIRECTLY enclosing scope.
    print $example
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)
    context.vars.declare_nonlocal(context.args[0])</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.BuiltinCommandHandler.return_"><code class="name flex">
<span>def <span class="ident">return_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>return</code> command. Returns all arguments passed to it as a single string, joined by spaces.
If this command is present in a <a href="#scrolls.builtins.BuiltinControlHandler.def_"><code>def</code></a> block, that <code>def</code> block
will define a new expansion call. Otherwise, it defines a command.</p>
<p>Using this command outside a <code>def</code> block will result in an error.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">!def(example foo) {
    return $foo
}
print $(example &quot;hello world&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `return` command. Returns all arguments passed to it as a single string, joined by spaces.
    If this command is present in a [`def`](#scrolls.builtins.BuiltinControlHandler.def_) block, that `def` block
    will define a new expansion call. Otherwise, it defines a command.

    Using this command outside a `def` block will result in an error.

    **Usage**
    ```scrolls
    !def(example foo) {
        return $foo
    }
    print $(example &#34;hello world&#34;)
    ```
    &#34;&#34;&#34;
    retval = &#34; &#34;.join(context.args)
    context.set_retval(retval)
    raise interpreter.InterpreterReturn()</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.BuiltinCommandHandler.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>set</code> command. Sets a variable. The first argument is the name of the variable. The rest of the
arguments are joined by spaces and stored in the named variable.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set varname arg1 arg2 arg3
print $varname # prints arg1 arg2 arg3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `set` command. Sets a variable. The first argument is the name of the variable. The rest of the
    arguments are joined by spaces and stored in the named variable.

    **Usage**
    ```scrolls
    set varname arg1 arg2 arg3
    print $varname # prints arg1 arg2 arg3
    ```
    &#34;&#34;&#34;
    if not context.args:
        raise interpreter.InterpreterError(
            context,
            &#34;set: variable name is not specified&#34;
        )

    context.set_var(context.args[0], &#34; &#34;.join(context.args[1:]))</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.BuiltinCommandHandler.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>stop</code> command. Stops the script execution. Takes no arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `stop` command. Stops the script execution. Takes no arguments.
    &#34;&#34;&#34;
    raise interpreter.InterpreterStop()</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.BuiltinCommandHandler.unset"><code class="name flex">
<span>def <span class="ident">unset</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>unset</code> command. Deletes a variable. The first argument is the name of the variable to delete.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set varname hello
print $varname # prints hello
unset varname
print $varname # ERROR
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unset(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `unset` command. Deletes a variable. The first argument is the name of the variable to delete.

    **Usage**
    ```scrolls
    set varname hello
    print $varname # prints hello
    unset varname
    print $varname # ERROR
    ```
    &#34;&#34;&#34;
    if not context.args:
        raise interpreter.InterpreterError(
            context,
            &#34;unset: variable name is not specified&#34;
        )

    try:
        context.del_var(context.args[0])
    except KeyError:
        raise interpreter.InterpreterError(
            context,
            f&#34;unset: no such variable {context.args[0]}&#34;
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.builtins.BuiltinControlHandler"><code class="flex name class">
<span>class <span class="ident">BuiltinControlHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Implements built-in command statements. In order for
<a href="#scrolls.builtins.BuiltinControlHandler.def_"><code>def</code></a>
to be functional, <code><a title="scrolls.builtins.BuiltinCommandHandler" href="#scrolls.builtins.BuiltinCommandHandler">BuiltinCommandHandler</a></code> and <code><a title="scrolls.builtins.BuiltinInitializer" href="#scrolls.builtins.BuiltinInitializer">BuiltinInitializer</a></code> must also be loaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@base_config.controlhandler
class BuiltinControlHandler(interpreter.CallbackControlHandler):
    &#34;&#34;&#34;
    Implements built-in command statements. In order for
    [`def`](#scrolls.builtins.BuiltinControlHandler.def_)
    to be functional, `BuiltinCommandHandler` and `BuiltinInitializer` must also be loaded.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;repeat&#34;, self.repeat)
        self.add_call(&#34;for&#34;, self.for_)
        self.add_call(&#34;if&#34;, self.if_)
        self.add_call(&#34;while&#34;, self.while_)
        self.add_call(&#34;def&#34;, self.def_)

    def def_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `def` control structure. Allows the definition of new commands and expansion calls.
        The first argument is the name of the call to define. The rest of the arguments name the parameters to the
        call. The last parameter name may be prefixed with `*` to support variable arguments.

        **Usage**
        ```scrolls
        !def(example a b) {
            print &#34;a is&#34; $a
            print &#34;b is&#34; $b
        }

        # prints
        # a is foo
        # b is bar
        example foo bar

        !def(varargs_example x *args) {
            print &#34;x is&#34; $x
            print &#34;the rest of the args are:&#34;
            !for(i in $^args) print $i
        }

        # prints
        # x is 10
        # the rest of the args are:
        # foo
        # bar
        # baz
        varargs_example 10 foo bar baz
        ```
        &#34;&#34;&#34;
        args = context.args
        datatypes.require_arg_length(context, 1)

        command_calls = context.control_node.find_all(
            lambda node: (node.type == ast.ASTNodeType.COMMAND_CALL and
                          bool(node.children))
        )

        has_return = False
        for node in command_calls:
            name_node = node.children[0]

            if name_node.type == ast.ASTNodeType.STRING and name_node.str_content() == &#34;return&#34;:
                has_return = True
                break

        if has_return:
            t.cast(
                interpreter.RuntimeCallHandler[str],
                context.runtime_expansions.get(&#34;__def__&#34;)
            ).define(args[0], context.control_node, args[1:])
        else:
            t.cast(
                interpreter.RuntimeCallHandler[None],
                context.runtime_commands.get(&#34;__def__&#34;)
            ).define(args[0], context.control_node, args[1:])

    def repeat(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `repeat` control structure. Takes a single integer argument, that repeats the body n times.

        **Usage**
        ```scrolls
        # prints &#34;hello world&#34; 4 times
        !repeat(4) {
            print &#34;hello world&#34;
        }
        ```
        &#34;&#34;&#34;
        if len(context.args) != 1:
            raise interpreter.InterpreterError(
                context,
                &#34;repeat requires exactly one argument, the number of times to repeat&#34;
            )

        context.current_node = context.arg_nodes[0]

        try:
            repeat_times = int(context.args[0])
        except ValueError:
            raise interpreter.InterpreterError(
                context,
                f&#34;&#39;{context.args[0]}&#39; is not a valid integer&#34;
            )

        control_node = context.control_node
        for _ in range(repeat_times):
            context.interpreter.interpret_statement(context, control_node)

    def for_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `for` control structure. The syntax is as follows: `!for(VARNAME in VECTOR) ...`

        **Usage**
        ```scrolls
        # prints
        # 1
        # 2
        # 3
        # 4
        # 5
        !for(x in 1 2 3 4 5) {
            print $x
        }
        ```
        &#34;&#34;&#34;
        if not context.args or len(context.args) &lt; 3:
            raise interpreter.InterpreterError(
                context,
                &#34;bad format in !for: expected !for(VARNAME in ARGS)&#34;
            )

        var_name, _in, *items = context.args

        if _in != &#34;in&#34;:
            context.current_node = context.arg_nodes[1]
            raise interpreter.InterpreterError(
                context,
                f&#34;unexpected token &#39;{_in}&#39;, should be &#39;in&#39;&#34;
            )

        control_node = context.control_node
        for item in items:
            context.set_var(var_name, item)
            context.interpreter.interpret_statement(context, control_node)

        context.del_var(var_name)

    def if_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `if` control structure. Takes one argument, a boolean. If it&#39;s `scrolls.datatypes.TRUE`,
        executes the body statement. Otherwise, the body is skipped. `else` is not supported.

        **Usage**
        ```scrolls
        !if($true) {
            print &#34;this will print&#34;
        }
        !if($false) {
            print &#34;this will not print&#34;
        }
        ```
        &#34;&#34;&#34;
        if len(context.args) != 1:
            raise interpreter.InterpreterError(
                context,
                f&#34;if: needs one and only one argument&#34;
            )

        if datatypes.str_to_bool(context.args[0]):
            context.interpreter.interpret_statement(context, context.control_node)

    def while_(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `while` control structure. Takes one argument, a boolean. Repeats the body while
        the condition is `scrolls.datatypes.TRUE`.

        **Usage**
        ```scrolls
        # counting down from 10 to 1
        set i 10
        !while($(&gt; 0 $i)) {
            print $i
            set i $(- $i 1)
        }
        ```
        &#34;&#34;&#34;
        if len(context.args) != 1:
            raise interpreter.InterpreterError(
                context,
                f&#34;while: needs one and only one argument&#34;
            )

        arg = context.args[0]

        while datatypes.str_to_bool(arg):
            context.interpreter.interpret_statement(context, context.control_node)

            # HACK:
            # In order for while to work right, we need to re-evaluate the argument
            # every time.
            arg = context.interpreter.interpret_string_or_expansion(context, context.arg_nodes[0])[0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.builtins.BuiltinControlHandler.def_"><code class="name flex">
<span>def <span class="ident">def_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>def</code> control structure. Allows the definition of new commands and expansion calls.
The first argument is the name of the call to define. The rest of the arguments name the parameters to the
call. The last parameter name may be prefixed with <code>*</code> to support variable arguments.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">!def(example a b) {
    print &quot;a is&quot; $a
    print &quot;b is&quot; $b
}

# prints
# a is foo
# b is bar
example foo bar

!def(varargs_example x *args) {
    print &quot;x is&quot; $x
    print &quot;the rest of the args are:&quot;
    !for(i in $^args) print $i
}

# prints
# x is 10
# the rest of the args are:
# foo
# bar
# baz
varargs_example 10 foo bar baz
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def def_(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `def` control structure. Allows the definition of new commands and expansion calls.
    The first argument is the name of the call to define. The rest of the arguments name the parameters to the
    call. The last parameter name may be prefixed with `*` to support variable arguments.

    **Usage**
    ```scrolls
    !def(example a b) {
        print &#34;a is&#34; $a
        print &#34;b is&#34; $b
    }

    # prints
    # a is foo
    # b is bar
    example foo bar

    !def(varargs_example x *args) {
        print &#34;x is&#34; $x
        print &#34;the rest of the args are:&#34;
        !for(i in $^args) print $i
    }

    # prints
    # x is 10
    # the rest of the args are:
    # foo
    # bar
    # baz
    varargs_example 10 foo bar baz
    ```
    &#34;&#34;&#34;
    args = context.args
    datatypes.require_arg_length(context, 1)

    command_calls = context.control_node.find_all(
        lambda node: (node.type == ast.ASTNodeType.COMMAND_CALL and
                      bool(node.children))
    )

    has_return = False
    for node in command_calls:
        name_node = node.children[0]

        if name_node.type == ast.ASTNodeType.STRING and name_node.str_content() == &#34;return&#34;:
            has_return = True
            break

    if has_return:
        t.cast(
            interpreter.RuntimeCallHandler[str],
            context.runtime_expansions.get(&#34;__def__&#34;)
        ).define(args[0], context.control_node, args[1:])
    else:
        t.cast(
            interpreter.RuntimeCallHandler[None],
            context.runtime_commands.get(&#34;__def__&#34;)
        ).define(args[0], context.control_node, args[1:])</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.BuiltinControlHandler.for_"><code class="name flex">
<span>def <span class="ident">for_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>for</code> control structure. The syntax is as follows: <code>!for(VARNAME in VECTOR) ...</code></p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls"># prints
# 1
# 2
# 3
# 4
# 5
!for(x in 1 2 3 4 5) {
    print $x
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def for_(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `for` control structure. The syntax is as follows: `!for(VARNAME in VECTOR) ...`

    **Usage**
    ```scrolls
    # prints
    # 1
    # 2
    # 3
    # 4
    # 5
    !for(x in 1 2 3 4 5) {
        print $x
    }
    ```
    &#34;&#34;&#34;
    if not context.args or len(context.args) &lt; 3:
        raise interpreter.InterpreterError(
            context,
            &#34;bad format in !for: expected !for(VARNAME in ARGS)&#34;
        )

    var_name, _in, *items = context.args

    if _in != &#34;in&#34;:
        context.current_node = context.arg_nodes[1]
        raise interpreter.InterpreterError(
            context,
            f&#34;unexpected token &#39;{_in}&#39;, should be &#39;in&#39;&#34;
        )

    control_node = context.control_node
    for item in items:
        context.set_var(var_name, item)
        context.interpreter.interpret_statement(context, control_node)

    context.del_var(var_name)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.BuiltinControlHandler.if_"><code class="name flex">
<span>def <span class="ident">if_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>if</code> control structure. Takes one argument, a boolean. If it's <code><a title="scrolls.datatypes.TRUE" href="datatypes.html#scrolls.datatypes.TRUE">TRUE</a></code>,
executes the body statement. Otherwise, the body is skipped. <code>else</code> is not supported.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">!if($true) {
    print &quot;this will print&quot;
}
!if($false) {
    print &quot;this will not print&quot;
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def if_(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `if` control structure. Takes one argument, a boolean. If it&#39;s `scrolls.datatypes.TRUE`,
    executes the body statement. Otherwise, the body is skipped. `else` is not supported.

    **Usage**
    ```scrolls
    !if($true) {
        print &#34;this will print&#34;
    }
    !if($false) {
        print &#34;this will not print&#34;
    }
    ```
    &#34;&#34;&#34;
    if len(context.args) != 1:
        raise interpreter.InterpreterError(
            context,
            f&#34;if: needs one and only one argument&#34;
        )

    if datatypes.str_to_bool(context.args[0]):
        context.interpreter.interpret_statement(context, context.control_node)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.BuiltinControlHandler.repeat"><code class="name flex">
<span>def <span class="ident">repeat</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>repeat</code> control structure. Takes a single integer argument, that repeats the body n times.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls"># prints &quot;hello world&quot; 4 times
!repeat(4) {
    print &quot;hello world&quot;
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `repeat` control structure. Takes a single integer argument, that repeats the body n times.

    **Usage**
    ```scrolls
    # prints &#34;hello world&#34; 4 times
    !repeat(4) {
        print &#34;hello world&#34;
    }
    ```
    &#34;&#34;&#34;
    if len(context.args) != 1:
        raise interpreter.InterpreterError(
            context,
            &#34;repeat requires exactly one argument, the number of times to repeat&#34;
        )

    context.current_node = context.arg_nodes[0]

    try:
        repeat_times = int(context.args[0])
    except ValueError:
        raise interpreter.InterpreterError(
            context,
            f&#34;&#39;{context.args[0]}&#39; is not a valid integer&#34;
        )

    control_node = context.control_node
    for _ in range(repeat_times):
        context.interpreter.interpret_statement(context, control_node)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.BuiltinControlHandler.while_"><code class="name flex">
<span>def <span class="ident">while_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>while</code> control structure. Takes one argument, a boolean. Repeats the body while
the condition is <code><a title="scrolls.datatypes.TRUE" href="datatypes.html#scrolls.datatypes.TRUE">TRUE</a></code>.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls"># counting down from 10 to 1
set i 10
!while($(&gt; 0 $i)) {
    print $i
    set i $(- $i 1)
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def while_(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `while` control structure. Takes one argument, a boolean. Repeats the body while
    the condition is `scrolls.datatypes.TRUE`.

    **Usage**
    ```scrolls
    # counting down from 10 to 1
    set i 10
    !while($(&gt; 0 $i)) {
        print $i
        set i $(- $i 1)
    }
    ```
    &#34;&#34;&#34;
    if len(context.args) != 1:
        raise interpreter.InterpreterError(
            context,
            f&#34;while: needs one and only one argument&#34;
        )

    arg = context.args[0]

    while datatypes.str_to_bool(arg):
        context.interpreter.interpret_statement(context, context.control_node)

        # HACK:
        # In order for while to work right, we need to re-evaluate the argument
        # every time.
        arg = context.interpreter.interpret_string_or_expansion(context, context.arg_nodes[0])[0]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.builtins.BuiltinInitializer"><code class="flex name class">
<span>class <span class="ident">BuiltinInitializer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Sets built in constants, and initializes plumbing used by
<a href="#scrolls.builtins.BuiltinControlHandler.def_"><code>def</code></a> and
<a href="#scrolls.builtins.BuiltinCommandHandler.return_"><code>return</code></a>.</p>
<h3 id="variables">Variables</h3>
<ul>
<li><code>$true</code> - A true boolean.</li>
<li><code>$false</code> - A false boolean.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@base_config.initializer
class BuiltinInitializer(interpreter.Initializer):
    &#34;&#34;&#34;
    Sets built in constants, and initializes plumbing used by
    [`def`](#scrolls.builtins.BuiltinControlHandler.def_) and
    [`return`](#scrolls.builtins.BuiltinCommandHandler.return_).

    ### Variables
    - `$true` - A true boolean.
    - `$false` - A false boolean.
    &#34;&#34;&#34;
    def handle_call(self, context: interpreter.InterpreterContext) -&gt; None:
        context.set_var(&#34;true&#34;, datatypes.TRUE)
        context.set_var(&#34;false&#34;, datatypes.FALSE)
        context.runtime_commands.add(interpreter.RuntimeCallHandler(), &#34;__def__&#34;)
        context.runtime_expansions.add(interpreter.RuntimeCallHandler(), &#34;__def__&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.Initializer" href="interpreter.html#scrolls.interpreter.Initializer">Initializer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.Initializer" href="interpreter.html#scrolls.interpreter.Initializer">Initializer</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.Initializer.handle_call" href="interpreter.html#scrolls.interpreter.Initializer.handle_call">handle_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.builtins.ComparisonExpansionHandler"><code class="flex name class">
<span>class <span class="ident">ComparisonExpansionHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Implements basic comparison operators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@base_config.expansionhandler
class ComparisonExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Implements basic comparison operators.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;eq?&#34;, self.equals)
        self.add_alias(&#34;==&#34;, &#34;eq?&#34;)
        self.add_call(&#34;neq?&#34;, self.not_equals)
        self.add_call(&#34;===&#34;, self.str_equals)
        self.add_call(&#34;&gt;&#34;, self.gt)
        self.add_call(&#34;&lt;&#34;, self.lt)
        self.add_call(&#34;&gt;=&#34;, self.gte)
        self.add_call(&#34;&lt;=&#34;, self.lte)
        self.add_call(&#34;in?&#34;, self._in)

    def __equals_bool(self, context: interpreter.InterpreterContext) -&gt; bool:
        args = context.args
        if len(args) != 2:
            raise interpreter.InterpreterError(
                context,
                f&#34;{context.call_name}: must have exactly 2 args&#34;
            )

        try:
            num_args, _ = datatypes.require_all_numeric(context, args)
            return num_args[0] == num_args[1]
        except interpreter.InterpreterError:
            return args[0] == args[1]

    def __get_numeric_compare_args(self, context: interpreter.InterpreterContext) -&gt; t.Tuple[float, float]:
        args = context.args
        if len(args) != 2:
            raise interpreter.InterpreterError(
                context,
                f&#34;{context.call_name}: must have exactly 2 args&#34;
            )

        (a, b), _ = datatypes.require_all_numeric(context, args)

        return a, b

    def str_equals(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `===`. Takes only two arguments.

        `===` is the strong comparison operator. It only operates on strings,
        and no implicit conversion is done.

        Contrast with the behavior of `ComparisonExpansionHandler.equals`.

        **Usage**
        ```scrolls
        print $(=== 0123 123) # prints 0
        print $(=== hello hello) # prints 0
        ```
        &#34;&#34;&#34;
        args = context.args
        if len(args) != 2:
            raise interpreter.InterpreterError(
                context,
                f&#34;{context.call_name}: must have exactly 2 args&#34;
            )

        return datatypes.bool_to_str(args[0] == args[1])

    def equals(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `==`, or `eq?`. Takes only two arguments.

        `==` is a weak comparison operator. If both arguments can be interpreted numerically, they will be converted
        to numbers before testing for equivalence. Otherwise, `==` just tests if the strings passed are equal.

        Contrast with the behavior of `ComparisonExpansionHandler.str_equals`.

        **Usage**
        ```scrolls
        print $(eq? 0123 123) # prints 1, numeric comparison
        print $(eq? hello hello) # prints 1, string comparison
        ```
        &#34;&#34;&#34;
        return datatypes.bool_to_str(self.__equals_bool(context))

    def not_equals(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `ne?`. Note this is not aliased to `!=` due to `!` being a reserved character. Takes only two arguments.

        Same as with `ComparisonExpansionHandler.equals`, this operator implicitly converts to numbers when possible.

        **Usage**
        ```scrolls
        print $(ne? 0123 123) # prints 0, numeric comparison
        print $(ne? hello world) # prints 1, string comparison
        ```
        &#34;&#34;&#34;
        return datatypes.bool_to_str(not self.__equals_bool(context))

    def gt(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `&gt;`. Takes only two arguments, both must be numeric.

        **Usage**
        ```scrolls
        print $(&gt; 0 3) # prints 1.
        ```
        &#34;&#34;&#34;
        a, b = self.__get_numeric_compare_args(context)
        return datatypes.bool_to_str(a &gt; b)

    def lt(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `&lt;`. Takes only two arguments, both must be numeric.

        **Usage**
        ```scrolls
        print $(&lt; 4 10) # prints 1.
        ```
        &#34;&#34;&#34;
        a, b = self.__get_numeric_compare_args(context)
        return datatypes.bool_to_str(a &lt; b)

    def gte(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `&gt;=`. Takes only two arguments, both must be numeric.

        **Usage**
        ```scrolls
        print $(&gt;= 10 4) # prints 1.
        print $(&gt;= 4 4) # prints 1.
        ```
        &#34;&#34;&#34;
        a, b = self.__get_numeric_compare_args(context)
        return datatypes.bool_to_str(a &gt;= b)

    def lte(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `&lt;=`. Takes only two arguments, both must be numeric.

        **Usage**
        ```scrolls
        print $(&lt;= 4 10) # prints 1.
        print $(&lt;= 4 4) # prints 1.
        ```
        &#34;&#34;&#34;
        a, b = self.__get_numeric_compare_args(context)
        return datatypes.bool_to_str(a &lt;= b)

    def _in(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `in?`. Takes at least one argument.

        **Usage**
        ```scrolls
        # in? x args...
        # Tests if x is in the following arguments.
        print $(in? blah) # always returns &#39;0&#39;.
        print $(in? bar foo bar baz) # returns &#39;1&#39;.
        ```
        &#34;&#34;&#34;
        if len(context.args) == 0:
            raise interpreter.InterpreterError(
                context,
                f&#34;{context.call_name} requires at least one argument&#34;
            )

        return datatypes.bool_to_str(context.args[0] in context.args[1:])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.builtins.ComparisonExpansionHandler.equals"><code class="name flex">
<span>def <span class="ident">equals</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>==</code>, or <code>eq?</code>. Takes only two arguments.</p>
<p><code>==</code> is a weak comparison operator. If both arguments can be interpreted numerically, they will be converted
to numbers before testing for equivalence. Otherwise, <code>==</code> just tests if the strings passed are equal.</p>
<p>Contrast with the behavior of <code><a title="scrolls.builtins.ComparisonExpansionHandler.str_equals" href="#scrolls.builtins.ComparisonExpansionHandler.str_equals">ComparisonExpansionHandler.str_equals()</a></code>.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(eq? 0123 123) # prints 1, numeric comparison
print $(eq? hello hello) # prints 1, string comparison
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equals(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `==`, or `eq?`. Takes only two arguments.

    `==` is a weak comparison operator. If both arguments can be interpreted numerically, they will be converted
    to numbers before testing for equivalence. Otherwise, `==` just tests if the strings passed are equal.

    Contrast with the behavior of `ComparisonExpansionHandler.str_equals`.

    **Usage**
    ```scrolls
    print $(eq? 0123 123) # prints 1, numeric comparison
    print $(eq? hello hello) # prints 1, string comparison
    ```
    &#34;&#34;&#34;
    return datatypes.bool_to_str(self.__equals_bool(context))</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ComparisonExpansionHandler.gt"><code class="name flex">
<span>def <span class="ident">gt</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>&gt;</code>. Takes only two arguments, both must be numeric.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(&gt; 0 3) # prints 1.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gt(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `&gt;`. Takes only two arguments, both must be numeric.

    **Usage**
    ```scrolls
    print $(&gt; 0 3) # prints 1.
    ```
    &#34;&#34;&#34;
    a, b = self.__get_numeric_compare_args(context)
    return datatypes.bool_to_str(a &gt; b)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ComparisonExpansionHandler.gte"><code class="name flex">
<span>def <span class="ident">gte</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>&gt;=</code>. Takes only two arguments, both must be numeric.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(&gt;= 10 4) # prints 1.
print $(&gt;= 4 4) # prints 1.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gte(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `&gt;=`. Takes only two arguments, both must be numeric.

    **Usage**
    ```scrolls
    print $(&gt;= 10 4) # prints 1.
    print $(&gt;= 4 4) # prints 1.
    ```
    &#34;&#34;&#34;
    a, b = self.__get_numeric_compare_args(context)
    return datatypes.bool_to_str(a &gt;= b)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ComparisonExpansionHandler.lt"><code class="name flex">
<span>def <span class="ident">lt</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>&lt;</code>. Takes only two arguments, both must be numeric.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(&lt; 4 10) # prints 1.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lt(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `&lt;`. Takes only two arguments, both must be numeric.

    **Usage**
    ```scrolls
    print $(&lt; 4 10) # prints 1.
    ```
    &#34;&#34;&#34;
    a, b = self.__get_numeric_compare_args(context)
    return datatypes.bool_to_str(a &lt; b)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ComparisonExpansionHandler.lte"><code class="name flex">
<span>def <span class="ident">lte</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>&lt;=</code>. Takes only two arguments, both must be numeric.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(&lt;= 4 10) # prints 1.
print $(&lt;= 4 4) # prints 1.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lte(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `&lt;=`. Takes only two arguments, both must be numeric.

    **Usage**
    ```scrolls
    print $(&lt;= 4 10) # prints 1.
    print $(&lt;= 4 4) # prints 1.
    ```
    &#34;&#34;&#34;
    a, b = self.__get_numeric_compare_args(context)
    return datatypes.bool_to_str(a &lt;= b)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ComparisonExpansionHandler.not_equals"><code class="name flex">
<span>def <span class="ident">not_equals</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>ne?</code>. Note this is not aliased to <code>!=</code> due to <code>!</code> being a reserved character. Takes only two arguments.</p>
<p>Same as with <code><a title="scrolls.builtins.ComparisonExpansionHandler.equals" href="#scrolls.builtins.ComparisonExpansionHandler.equals">ComparisonExpansionHandler.equals()</a></code>, this operator implicitly converts to numbers when possible.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(ne? 0123 123) # prints 0, numeric comparison
print $(ne? hello world) # prints 1, string comparison
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def not_equals(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `ne?`. Note this is not aliased to `!=` due to `!` being a reserved character. Takes only two arguments.

    Same as with `ComparisonExpansionHandler.equals`, this operator implicitly converts to numbers when possible.

    **Usage**
    ```scrolls
    print $(ne? 0123 123) # prints 0, numeric comparison
    print $(ne? hello world) # prints 1, string comparison
    ```
    &#34;&#34;&#34;
    return datatypes.bool_to_str(not self.__equals_bool(context))</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.ComparisonExpansionHandler.str_equals"><code class="name flex">
<span>def <span class="ident">str_equals</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>===</code>. Takes only two arguments.</p>
<p><code>===</code> is the strong comparison operator. It only operates on strings,
and no implicit conversion is done.</p>
<p>Contrast with the behavior of <code><a title="scrolls.builtins.ComparisonExpansionHandler.equals" href="#scrolls.builtins.ComparisonExpansionHandler.equals">ComparisonExpansionHandler.equals()</a></code>.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(=== 0123 123) # prints 0
print $(=== hello hello) # prints 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def str_equals(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `===`. Takes only two arguments.

    `===` is the strong comparison operator. It only operates on strings,
    and no implicit conversion is done.

    Contrast with the behavior of `ComparisonExpansionHandler.equals`.

    **Usage**
    ```scrolls
    print $(=== 0123 123) # prints 0
    print $(=== hello hello) # prints 0
    ```
    &#34;&#34;&#34;
    args = context.args
    if len(args) != 2:
        raise interpreter.InterpreterError(
            context,
            f&#34;{context.call_name}: must have exactly 2 args&#34;
        )

    return datatypes.bool_to_str(args[0] == args[1])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.builtins.FileCommandHandler"><code class="flex name class">
<span>class <span class="ident">FileCommandHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Defines commands for working with files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@file_config.commandhandler
class FileCommandHandler(interpreter.CallbackCommandHandler):
    &#34;&#34;&#34;
    Defines commands for working with files.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;file-close&#34;, self.close)

    def close(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements `file-close`. If you&#39;re looking for `file-open`, see
        `FileExpansionHandler.open`.

        **Usage**
        ```scrolls
        set f $(file-open file w)
        # do things to file...
        file-close $f
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        fid, _ = datatypes.require_numeric(context, context.args[0])
        context.close_file(int(fid))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.builtins.FileCommandHandler.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>file-close</code>. If you're looking for <code>file-open</code>, see
<code><a title="scrolls.builtins.FileExpansionHandler.open" href="#scrolls.builtins.FileExpansionHandler.open">FileExpansionHandler.open()</a></code>.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set f $(file-open file w)
# do things to file...
file-close $f
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements `file-close`. If you&#39;re looking for `file-open`, see
    `FileExpansionHandler.open`.

    **Usage**
    ```scrolls
    set f $(file-open file w)
    # do things to file...
    file-close $f
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)
    fid, _ = datatypes.require_numeric(context, context.args[0])
    context.close_file(int(fid))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.builtins.FileExpansionHandler"><code class="flex name class">
<span>class <span class="ident">FileExpansionHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Defines expansions for working with files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@file_config.expansionhandler
class FileExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Defines expansions for working with files.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;file-open&#34;, self.open)
        self.add_call(&#34;file-read&#34;, self.read)

    def open(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `file-open`. If you&#39;re looking for `file-close`, see
        `FileCommandHandler.close`.

        `file-open` returns an integer ID used as a handle to the file.
        This ID should be saved and used for all `file-*` functions.

        **Usage**
        ```scrolls
        set f $(file-open file w)
        # do things to file...
        file-close $f
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)

        if len(context.args) &gt; 1:
            mode = context.args[1]
        else:
            # default is read
            mode = &#34;r&#34;

        return str(context.open_file(context.args[0], mode))

    def read(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `file-read`. Reads an entire file and returns a string.

        **Usage**
        ```scrolls
        set f $(file-open file w)
        print $(file-read $f)
        file-close $f
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        fid, _ = datatypes.require_numeric(context, context.args[0])

        f = context.get_file(int(fid))
        return f.read()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.builtins.FileExpansionHandler.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>file-open</code>. If you're looking for <code>file-close</code>, see
<code><a title="scrolls.builtins.FileCommandHandler.close" href="#scrolls.builtins.FileCommandHandler.close">FileCommandHandler.close()</a></code>.</p>
<p><code>file-open</code> returns an integer ID used as a handle to the file.
This ID should be saved and used for all <code>file-*</code> functions.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set f $(file-open file w)
# do things to file...
file-close $f
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `file-open`. If you&#39;re looking for `file-close`, see
    `FileCommandHandler.close`.

    `file-open` returns an integer ID used as a handle to the file.
    This ID should be saved and used for all `file-*` functions.

    **Usage**
    ```scrolls
    set f $(file-open file w)
    # do things to file...
    file-close $f
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)

    if len(context.args) &gt; 1:
        mode = context.args[1]
    else:
        # default is read
        mode = &#34;r&#34;

    return str(context.open_file(context.args[0], mode))</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.FileExpansionHandler.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>file-read</code>. Reads an entire file and returns a string.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set f $(file-open file w)
print $(file-read $f)
file-close $f
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `file-read`. Reads an entire file and returns a string.

    **Usage**
    ```scrolls
    set f $(file-open file w)
    print $(file-read $f)
    file-close $f
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)
    fid, _ = datatypes.require_numeric(context, context.args[0])

    f = context.get_file(int(fid))
    return f.read()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.builtins.LogicExpansionHandler"><code class="flex name class">
<span>class <span class="ident">LogicExpansionHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Implements basic logic operators.</p>
<h2 id="related">Related</h2>
<p><code><a title="scrolls.datatypes.TRUE" href="datatypes.html#scrolls.datatypes.TRUE">TRUE</a></code>
<code><a title="scrolls.datatypes.FALSE" href="datatypes.html#scrolls.datatypes.FALSE">FALSE</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@base_config.expansionhandler
class LogicExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Implements basic logic operators.

    Related:
        `scrolls.datatypes.TRUE`
        `scrolls.datatypes.FALSE`
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;not&#34;, self.not_)
        self.add_call(&#34;and&#34;, self.and_)
        self.add_call(&#34;or&#34;, self.or_)
        self.add_call(&#34;xor&#34;, self.xor_)

    @staticmethod
    def __unary(context: interpreter.InterpreterContext, op: datatypes.UnaryNumOpT) -&gt; str:
        return datatypes.bool_to_str(datatypes.apply_unary_bool_op(context, op))

    @staticmethod
    def __reduce(context: interpreter.InterpreterContext, op: datatypes.BinaryNumOpT) -&gt; str:
        return datatypes.bool_to_str(datatypes.apply_reduce_bool_op(context, op))

    def not_(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `not` operator.

        **Usage**
        ```scrolls
        print $(not $true) # prints 0.
        ```
        &#34;&#34;&#34;
        return self.__unary(context, operator.not_)

    def and_(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `and` operator. Takes 2 or more arguments, and `and`s them all together.

        **Usage**
        ```scrolls
        print $(and $true $false $true) # prints 0.
        print $(and $true $true) # prints 1.
        ```
        &#34;&#34;&#34;
        return self.__reduce(context, operator.and_)

    def or_(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `or` operator. Takes 2 or more arguments, and `or`s them all together.

        **Usage**
        ```scrolls
        print $(or $true $false $true) # prints 1.
        print $(or $false $false) # prints 0.
        ```
        &#34;&#34;&#34;
        return self.__reduce(context, operator.or_)

    def xor_(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `xor` operator. Takes 2 or more arguments. With 2 arguments, `xor` performs a standard XOR
        operation. With more arguments, `xor` will perform a parity check. It will return `scrolls.datatypes.TRUE`
        for an odd number of `scrolls.datatypes.TRUE` inputs, and `scrolls.datatypes.FALSE` for an even number of
        `scrolls.datatypes.TRUE` inputs.

        **Usage**
        ```scrolls
        print $(xor $true $false) # prints 1.
        print $(xor $true $false $true) # prints 0.
        ```
        &#34;&#34;&#34;
        return self.__reduce(context, operator.xor)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.builtins.LogicExpansionHandler.and_"><code class="name flex">
<span>def <span class="ident">and_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>and</code> operator. Takes 2 or more arguments, and <code>and</code>s them all together.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(and $true $false $true) # prints 0.
print $(and $true $true) # prints 1.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def and_(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements the `and` operator. Takes 2 or more arguments, and `and`s them all together.

    **Usage**
    ```scrolls
    print $(and $true $false $true) # prints 0.
    print $(and $true $true) # prints 1.
    ```
    &#34;&#34;&#34;
    return self.__reduce(context, operator.and_)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.LogicExpansionHandler.not_"><code class="name flex">
<span>def <span class="ident">not_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>not</code> operator.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(not $true) # prints 0.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def not_(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements the `not` operator.

    **Usage**
    ```scrolls
    print $(not $true) # prints 0.
    ```
    &#34;&#34;&#34;
    return self.__unary(context, operator.not_)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.LogicExpansionHandler.or_"><code class="name flex">
<span>def <span class="ident">or_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>or</code> operator. Takes 2 or more arguments, and <code>or</code>s them all together.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(or $true $false $true) # prints 1.
print $(or $false $false) # prints 0.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def or_(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements the `or` operator. Takes 2 or more arguments, and `or`s them all together.

    **Usage**
    ```scrolls
    print $(or $true $false $true) # prints 1.
    print $(or $false $false) # prints 0.
    ```
    &#34;&#34;&#34;
    return self.__reduce(context, operator.or_)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.LogicExpansionHandler.xor_"><code class="name flex">
<span>def <span class="ident">xor_</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>xor</code> operator. Takes 2 or more arguments. With 2 arguments, <code>xor</code> performs a standard XOR
operation. With more arguments, <code>xor</code> will perform a parity check. It will return <code><a title="scrolls.datatypes.TRUE" href="datatypes.html#scrolls.datatypes.TRUE">TRUE</a></code>
for an odd number of <code><a title="scrolls.datatypes.TRUE" href="datatypes.html#scrolls.datatypes.TRUE">TRUE</a></code> inputs, and <code><a title="scrolls.datatypes.FALSE" href="datatypes.html#scrolls.datatypes.FALSE">FALSE</a></code> for an even number of
<code><a title="scrolls.datatypes.TRUE" href="datatypes.html#scrolls.datatypes.TRUE">TRUE</a></code> inputs.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(xor $true $false) # prints 1.
print $(xor $true $false $true) # prints 0.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xor_(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements the `xor` operator. Takes 2 or more arguments. With 2 arguments, `xor` performs a standard XOR
    operation. With more arguments, `xor` will perform a parity check. It will return `scrolls.datatypes.TRUE`
    for an odd number of `scrolls.datatypes.TRUE` inputs, and `scrolls.datatypes.FALSE` for an even number of
    `scrolls.datatypes.TRUE` inputs.

    **Usage**
    ```scrolls
    print $(xor $true $false) # prints 1.
    print $(xor $true $false $true) # prints 0.
    ```
    &#34;&#34;&#34;
    return self.__reduce(context, operator.xor)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.builtins.RandomExpansionHandler"><code class="flex name class">
<span>class <span class="ident">RandomExpansionHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Implements random expansions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RandomExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Implements random expansions.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;select&#34;, self.select)
        self.add_call(&#34;shuffle&#34;, self.shuffle)
        self.add_call(&#34;uniform&#34;, self.uniform)

    def select(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `select` expansion. Randomly selects one of the arguments and returns it.

        **Usage**
        ```scrolls
        # randomly prints either foo, bar, or baz
        print $(select foo bar baz)
        ```
        &#34;&#34;&#34;
        return random.choice(context.args)

    def shuffle(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `shuffle` expansion. Shuffle the arguments given and return them.

        **Usage**
        ```scrolls
        print $(shuffle 1 2 3 4 5)
        ```
        &#34;&#34;&#34;
        args = list(context.args)
        random.shuffle(args)
        return &#34; &#34;.join(args)

    def uniform(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements the `uniform` expansion. Returns a random floating point number between two bounds, inclusive.

        **Usage**
        ```scrolls
        print $(uniform 0 2) # print a random float between 0 and 2.
        ```
        &#34;&#34;&#34;
        if len(context.args) != 2:
            raise interpreter.InterpreterError(
                context,
                f&#34;uniform: must have two args. (got {&#39;, &#39;.join(context.args)})&#34;
            )

        try:
            lower = float(context.args[0])
            upper = float(context.args[1])
        except ValueError as e:
            raise interpreter.InterpreterError(
                context,
                f&#34;uniform: {str(e)}&#34;
            )

        return str(random.uniform(lower, upper))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.builtins.RandomExpansionHandler.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>select</code> expansion. Randomly selects one of the arguments and returns it.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls"># randomly prints either foo, bar, or baz
print $(select foo bar baz)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements the `select` expansion. Randomly selects one of the arguments and returns it.

    **Usage**
    ```scrolls
    # randomly prints either foo, bar, or baz
    print $(select foo bar baz)
    ```
    &#34;&#34;&#34;
    return random.choice(context.args)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.RandomExpansionHandler.shuffle"><code class="name flex">
<span>def <span class="ident">shuffle</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>shuffle</code> expansion. Shuffle the arguments given and return them.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(shuffle 1 2 3 4 5)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shuffle(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements the `shuffle` expansion. Shuffle the arguments given and return them.

    **Usage**
    ```scrolls
    print $(shuffle 1 2 3 4 5)
    ```
    &#34;&#34;&#34;
    args = list(context.args)
    random.shuffle(args)
    return &#34; &#34;.join(args)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.RandomExpansionHandler.uniform"><code class="name flex">
<span>def <span class="ident">uniform</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>uniform</code> expansion. Returns a random floating point number between two bounds, inclusive.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(uniform 0 2) # print a random float between 0 and 2.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniform(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements the `uniform` expansion. Returns a random floating point number between two bounds, inclusive.

    **Usage**
    ```scrolls
    print $(uniform 0 2) # print a random float between 0 and 2.
    ```
    &#34;&#34;&#34;
    if len(context.args) != 2:
        raise interpreter.InterpreterError(
            context,
            f&#34;uniform: must have two args. (got {&#39;, &#39;.join(context.args)})&#34;
        )

    try:
        lower = float(context.args[0])
        upper = float(context.args[1])
    except ValueError as e:
        raise interpreter.InterpreterError(
            context,
            f&#34;uniform: {str(e)}&#34;
        )

    return str(random.uniform(lower, upper))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.builtins.StdIoCommandHandler"><code class="flex name class">
<span>class <span class="ident">StdIoCommandHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Implements input and output commands using stdout/stdin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StdIoCommandHandler(interpreter.CallbackCommandHandler):
    &#34;&#34;&#34;
    Implements input and output commands using stdout/stdin.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;print&#34;, self.print)
        self.add_call(&#34;write&#34;, self.write)
        self.add_call(&#34;input&#34;, self.input)

    def print(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `print` command. Prints all arguments passed to it, joined by spaces.

        **Usage**
        ```scrolls
        print hello world foo bar
        ```
        &#34;&#34;&#34;
        print(&#34; &#34;.join(context.args))

    def write(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `write` command. Prints all arguments passed to it, joined
        by spaces. The difference vs. `print` is that `print` appends a newline,
        while `write` does not.

        **Usage**
        ```scrolls
        write hello world foo bar
        ```
        &#34;&#34;&#34;
        print(&#34; &#34;.join(context.args), end=&#34;&#34;)

    def input(self, context: interpreter.InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Implements the `input` command. Reads `stdin` for input, and stores the input in a variable named
        by the first argument.

        **Usage**
        ```scrolls
        input foo
        print $foo # prints what you entered
        ```
        &#34;&#34;&#34;
        if not context.args:
            raise interpreter.InterpreterError(
                context,
                &#34;input: variable name is not specified&#34;
            )

        result = input()
        context.set_var(context.args[0], result)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.builtins.StdIoCommandHandler.input"><code class="name flex">
<span>def <span class="ident">input</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>input</code> command. Reads <code>stdin</code> for input, and stores the input in a variable named
by the first argument.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">input foo
print $foo # prints what you entered
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `input` command. Reads `stdin` for input, and stores the input in a variable named
    by the first argument.

    **Usage**
    ```scrolls
    input foo
    print $foo # prints what you entered
    ```
    &#34;&#34;&#34;
    if not context.args:
        raise interpreter.InterpreterError(
            context,
            &#34;input: variable name is not specified&#34;
        )

    result = input()
    context.set_var(context.args[0], result)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.StdIoCommandHandler.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>print</code> command. Prints all arguments passed to it, joined by spaces.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print hello world foo bar
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `print` command. Prints all arguments passed to it, joined by spaces.

    **Usage**
    ```scrolls
    print hello world foo bar
    ```
    &#34;&#34;&#34;
    print(&#34; &#34;.join(context.args))</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.StdIoCommandHandler.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the <code>write</code> command. Prints all arguments passed to it, joined
by spaces. The difference vs. <code>print</code> is that <code>print</code> appends a newline,
while <code>write</code> does not.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">write hello world foo bar
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, context: interpreter.InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Implements the `write` command. Prints all arguments passed to it, joined
    by spaces. The difference vs. `print` is that `print` appends a newline,
    while `write` does not.

    **Usage**
    ```scrolls
    write hello world foo bar
    ```
    &#34;&#34;&#34;
    print(&#34; &#34;.join(context.args), end=&#34;&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.builtins.StringExpansionHandler"><code class="flex name class">
<span>class <span class="ident">StringExpansionHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Implements basic string manipulation expansions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@base_config.expansionhandler
class StringExpansionHandler(interpreter.CallbackExpansionHandler):
    &#34;&#34;&#34;
    Implements basic string manipulation expansions.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.add_call(&#34;cat&#34;, self.concat)
        self.add_alias(&#34;concat&#34;, &#34;cat&#34;)
        self.add_call(&#34;getc&#34;, self.getc)
        self.add_call(&#34;len&#34;, self.len)
        self.add_call(&#34;ord&#34;, self.ord)
        self.add_call(&#34;chr&#34;, self.chr)
        self.add_call(&#34;vempty?&#34;, self.vempty)
        self.add_call(&#34;vhead&#34;, self.vhead)
        self.add_call(&#34;vtail&#34;, self.vtail)
        self.add_call(&#34;rangev&#34;, self.rangev)

    def concat(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `cat`. Concatenates all arguments into one string and returns it. Commonly used to concatenate
        punctuation onto variable output.

        **Usage**
        ```scrolls
        set example &#34;Hello world&#34;
        print $(cat $example &#34;!&#34;) # prints Hello World!
        ```
        &#34;&#34;&#34;
        return &#34;&#34;.join(context.args)

    def getc(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `getc`. Gets a single character from a string, starting at 0.

        **Usage**
        ```scrolls
        set example &#34;Hello&#34;
        print $(getc $example 4) # prints &#39;o&#39;
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 2)
        n = int(datatypes.require_numeric(context, context.args[1])[0])

        return context.args[0][n]

    def len(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `len`. Gets the length of the passed string.

        **Usage**
        ```scrolls
        print $(len &#34;hello&#34;) # prints 5
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        return str(len(context.args[0]))

    def ord(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `ord`. Converts a single character to its integer equivalent.

        **Usage**
        ```scrolls
        print $(ord &#34;h&#34;) # prints 104
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        return str(ord(context.args[0]))

    def chr(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `chr`. Converts a number into the character it corresponds to.

        **Usage**
        ```scrolls
        print $(chr 104) # prints h
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        c = int(datatypes.require_numeric(context, context.args[0])[0])
        return chr(c)

    def vempty(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `vempty?`. Returns `scrolls.datatypes.TRUE` if the passed vector is empty.

        **Usage**
        ```scrolls
        set empty_vec &#34;&#34;
        print $(vempty? $empty_vec) # prints 1.
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        return datatypes.bool_to_str(not bool(context.args[0]))

    def vhead(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `vhead`. Returns the first element of a vector (the leftmost element).

        **Usage**
        ```scrolls
        set vec &#34;2 4 8 16&#34;
        print $(vhead $vec) # prints 2.
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        return context.args[0].split(maxsplit=1)[0]

    def vtail(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `vtail`. Returns every element of a vector except the first.

        **Usage**
        ```scrolls
        set vec &#34;2 4 8 16&#34;
        print $(vtail $vec) # prints 4 8 16.
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 1)
        return &#34;&#34;.join(context.args[0].split(maxsplit=1)[1:])

    def rangev(self, context: interpreter.InterpreterContext) -&gt; str:
        &#34;&#34;&#34;
        Implements `rangev`. Returns a vector consisting of a range of numbers.

        **Usage**
        ```scrolls
        set min 0
        set max 4
        print $(rangev $min $max) # prints 0 1 2 3
        ```
        &#34;&#34;&#34;
        datatypes.require_arg_length(context, 2)
        (a, b, *rest), _ = datatypes.require_all_numeric(context, context.args)

        a = int(a)
        b = int(b)

        return &#34; &#34;.join([str(x) for x in range(a, b)])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.builtins.StringExpansionHandler.chr"><code class="name flex">
<span>def <span class="ident">chr</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>chr</code>. Converts a number into the character it corresponds to.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(chr 104) # prints h
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chr(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `chr`. Converts a number into the character it corresponds to.

    **Usage**
    ```scrolls
    print $(chr 104) # prints h
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)
    c = int(datatypes.require_numeric(context, context.args[0])[0])
    return chr(c)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.StringExpansionHandler.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>cat</code>. Concatenates all arguments into one string and returns it. Commonly used to concatenate
punctuation onto variable output.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set example &quot;Hello world&quot;
print $(cat $example &quot;!&quot;) # prints Hello World!
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `cat`. Concatenates all arguments into one string and returns it. Commonly used to concatenate
    punctuation onto variable output.

    **Usage**
    ```scrolls
    set example &#34;Hello world&#34;
    print $(cat $example &#34;!&#34;) # prints Hello World!
    ```
    &#34;&#34;&#34;
    return &#34;&#34;.join(context.args)</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.StringExpansionHandler.getc"><code class="name flex">
<span>def <span class="ident">getc</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>getc</code>. Gets a single character from a string, starting at 0.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set example &quot;Hello&quot;
print $(getc $example 4) # prints 'o'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getc(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `getc`. Gets a single character from a string, starting at 0.

    **Usage**
    ```scrolls
    set example &#34;Hello&#34;
    print $(getc $example 4) # prints &#39;o&#39;
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 2)
    n = int(datatypes.require_numeric(context, context.args[1])[0])

    return context.args[0][n]</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.StringExpansionHandler.len"><code class="name flex">
<span>def <span class="ident">len</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>len</code>. Gets the length of the passed string.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(len &quot;hello&quot;) # prints 5
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def len(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `len`. Gets the length of the passed string.

    **Usage**
    ```scrolls
    print $(len &#34;hello&#34;) # prints 5
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)
    return str(len(context.args[0]))</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.StringExpansionHandler.ord"><code class="name flex">
<span>def <span class="ident">ord</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>ord</code>. Converts a single character to its integer equivalent.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">print $(ord &quot;h&quot;) # prints 104
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ord(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `ord`. Converts a single character to its integer equivalent.

    **Usage**
    ```scrolls
    print $(ord &#34;h&#34;) # prints 104
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)
    return str(ord(context.args[0]))</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.StringExpansionHandler.rangev"><code class="name flex">
<span>def <span class="ident">rangev</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>rangev</code>. Returns a vector consisting of a range of numbers.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set min 0
set max 4
print $(rangev $min $max) # prints 0 1 2 3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rangev(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `rangev`. Returns a vector consisting of a range of numbers.

    **Usage**
    ```scrolls
    set min 0
    set max 4
    print $(rangev $min $max) # prints 0 1 2 3
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 2)
    (a, b, *rest), _ = datatypes.require_all_numeric(context, context.args)

    a = int(a)
    b = int(b)

    return &#34; &#34;.join([str(x) for x in range(a, b)])</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.StringExpansionHandler.vempty"><code class="name flex">
<span>def <span class="ident">vempty</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>vempty?</code>. Returns <code><a title="scrolls.datatypes.TRUE" href="datatypes.html#scrolls.datatypes.TRUE">TRUE</a></code> if the passed vector is empty.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set empty_vec &quot;&quot;
print $(vempty? $empty_vec) # prints 1.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vempty(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `vempty?`. Returns `scrolls.datatypes.TRUE` if the passed vector is empty.

    **Usage**
    ```scrolls
    set empty_vec &#34;&#34;
    print $(vempty? $empty_vec) # prints 1.
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)
    return datatypes.bool_to_str(not bool(context.args[0]))</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.StringExpansionHandler.vhead"><code class="name flex">
<span>def <span class="ident">vhead</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>vhead</code>. Returns the first element of a vector (the leftmost element).</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set vec &quot;2 4 8 16&quot;
print $(vhead $vec) # prints 2.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vhead(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `vhead`. Returns the first element of a vector (the leftmost element).

    **Usage**
    ```scrolls
    set vec &#34;2 4 8 16&#34;
    print $(vhead $vec) # prints 2.
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)
    return context.args[0].split(maxsplit=1)[0]</code></pre>
</details>
</dd>
<dt id="scrolls.builtins.StringExpansionHandler.vtail"><code class="name flex">
<span>def <span class="ident">vtail</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="interpreter.html#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Implements <code>vtail</code>. Returns every element of a vector except the first.</p>
<p><strong>Usage</strong></p>
<pre><code class="language-scrolls">set vec &quot;2 4 8 16&quot;
print $(vtail $vec) # prints 4 8 16.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vtail(self, context: interpreter.InterpreterContext) -&gt; str:
    &#34;&#34;&#34;
    Implements `vtail`. Returns every element of a vector except the first.

    **Usage**
    ```scrolls
    set vec &#34;2 4 8 16&#34;
    print $(vtail $vec) # prints 4 8 16.
    ```
    &#34;&#34;&#34;
    datatypes.require_arg_length(context, 1)
    return &#34;&#34;.join(context.args[0].split(maxsplit=1)[1:])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.CallbackCallHandler" href="interpreter.html#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="interpreter.html#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#reading-this-reference">Reading This Reference</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrolls" href="index.html">scrolls</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="scrolls.builtins.base_config" href="#scrolls.builtins.base_config">base_config</a></code></li>
<li><code><a title="scrolls.builtins.file_config" href="#scrolls.builtins.file_config">file_config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrolls.builtins.ArithmeticExpansionHandler" href="#scrolls.builtins.ArithmeticExpansionHandler">ArithmeticExpansionHandler</a></code></h4>
<ul class="two-column">
<li><code><a title="scrolls.builtins.ArithmeticExpansionHandler.add" href="#scrolls.builtins.ArithmeticExpansionHandler.add">add</a></code></li>
<li><code><a title="scrolls.builtins.ArithmeticExpansionHandler.div" href="#scrolls.builtins.ArithmeticExpansionHandler.div">div</a></code></li>
<li><code><a title="scrolls.builtins.ArithmeticExpansionHandler.intdiv" href="#scrolls.builtins.ArithmeticExpansionHandler.intdiv">intdiv</a></code></li>
<li><code><a title="scrolls.builtins.ArithmeticExpansionHandler.mod" href="#scrolls.builtins.ArithmeticExpansionHandler.mod">mod</a></code></li>
<li><code><a title="scrolls.builtins.ArithmeticExpansionHandler.mul" href="#scrolls.builtins.ArithmeticExpansionHandler.mul">mul</a></code></li>
<li><code><a title="scrolls.builtins.ArithmeticExpansionHandler.sub" href="#scrolls.builtins.ArithmeticExpansionHandler.sub">sub</a></code></li>
<li><code><a title="scrolls.builtins.ArithmeticExpansionHandler.tofloat" href="#scrolls.builtins.ArithmeticExpansionHandler.tofloat">tofloat</a></code></li>
<li><code><a title="scrolls.builtins.ArithmeticExpansionHandler.toint" href="#scrolls.builtins.ArithmeticExpansionHandler.toint">toint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.builtins.BuiltinCommandHandler" href="#scrolls.builtins.BuiltinCommandHandler">BuiltinCommandHandler</a></code></h4>
<ul class="two-column">
<li><code><a title="scrolls.builtins.BuiltinCommandHandler.global_" href="#scrolls.builtins.BuiltinCommandHandler.global_">global_</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinCommandHandler.nonlocal_" href="#scrolls.builtins.BuiltinCommandHandler.nonlocal_">nonlocal_</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinCommandHandler.return_" href="#scrolls.builtins.BuiltinCommandHandler.return_">return_</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinCommandHandler.set" href="#scrolls.builtins.BuiltinCommandHandler.set">set</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinCommandHandler.stop" href="#scrolls.builtins.BuiltinCommandHandler.stop">stop</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinCommandHandler.unset" href="#scrolls.builtins.BuiltinCommandHandler.unset">unset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.builtins.BuiltinControlHandler" href="#scrolls.builtins.BuiltinControlHandler">BuiltinControlHandler</a></code></h4>
<ul class="">
<li><code><a title="scrolls.builtins.BuiltinControlHandler.def_" href="#scrolls.builtins.BuiltinControlHandler.def_">def_</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinControlHandler.for_" href="#scrolls.builtins.BuiltinControlHandler.for_">for_</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinControlHandler.if_" href="#scrolls.builtins.BuiltinControlHandler.if_">if_</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinControlHandler.repeat" href="#scrolls.builtins.BuiltinControlHandler.repeat">repeat</a></code></li>
<li><code><a title="scrolls.builtins.BuiltinControlHandler.while_" href="#scrolls.builtins.BuiltinControlHandler.while_">while_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.builtins.BuiltinInitializer" href="#scrolls.builtins.BuiltinInitializer">BuiltinInitializer</a></code></h4>
</li>
<li>
<h4><code><a title="scrolls.builtins.ComparisonExpansionHandler" href="#scrolls.builtins.ComparisonExpansionHandler">ComparisonExpansionHandler</a></code></h4>
<ul class="two-column">
<li><code><a title="scrolls.builtins.ComparisonExpansionHandler.equals" href="#scrolls.builtins.ComparisonExpansionHandler.equals">equals</a></code></li>
<li><code><a title="scrolls.builtins.ComparisonExpansionHandler.gt" href="#scrolls.builtins.ComparisonExpansionHandler.gt">gt</a></code></li>
<li><code><a title="scrolls.builtins.ComparisonExpansionHandler.gte" href="#scrolls.builtins.ComparisonExpansionHandler.gte">gte</a></code></li>
<li><code><a title="scrolls.builtins.ComparisonExpansionHandler.lt" href="#scrolls.builtins.ComparisonExpansionHandler.lt">lt</a></code></li>
<li><code><a title="scrolls.builtins.ComparisonExpansionHandler.lte" href="#scrolls.builtins.ComparisonExpansionHandler.lte">lte</a></code></li>
<li><code><a title="scrolls.builtins.ComparisonExpansionHandler.not_equals" href="#scrolls.builtins.ComparisonExpansionHandler.not_equals">not_equals</a></code></li>
<li><code><a title="scrolls.builtins.ComparisonExpansionHandler.str_equals" href="#scrolls.builtins.ComparisonExpansionHandler.str_equals">str_equals</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.builtins.FileCommandHandler" href="#scrolls.builtins.FileCommandHandler">FileCommandHandler</a></code></h4>
<ul class="">
<li><code><a title="scrolls.builtins.FileCommandHandler.close" href="#scrolls.builtins.FileCommandHandler.close">close</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.builtins.FileExpansionHandler" href="#scrolls.builtins.FileExpansionHandler">FileExpansionHandler</a></code></h4>
<ul class="">
<li><code><a title="scrolls.builtins.FileExpansionHandler.open" href="#scrolls.builtins.FileExpansionHandler.open">open</a></code></li>
<li><code><a title="scrolls.builtins.FileExpansionHandler.read" href="#scrolls.builtins.FileExpansionHandler.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.builtins.LogicExpansionHandler" href="#scrolls.builtins.LogicExpansionHandler">LogicExpansionHandler</a></code></h4>
<ul class="">
<li><code><a title="scrolls.builtins.LogicExpansionHandler.and_" href="#scrolls.builtins.LogicExpansionHandler.and_">and_</a></code></li>
<li><code><a title="scrolls.builtins.LogicExpansionHandler.not_" href="#scrolls.builtins.LogicExpansionHandler.not_">not_</a></code></li>
<li><code><a title="scrolls.builtins.LogicExpansionHandler.or_" href="#scrolls.builtins.LogicExpansionHandler.or_">or_</a></code></li>
<li><code><a title="scrolls.builtins.LogicExpansionHandler.xor_" href="#scrolls.builtins.LogicExpansionHandler.xor_">xor_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.builtins.RandomExpansionHandler" href="#scrolls.builtins.RandomExpansionHandler">RandomExpansionHandler</a></code></h4>
<ul class="">
<li><code><a title="scrolls.builtins.RandomExpansionHandler.select" href="#scrolls.builtins.RandomExpansionHandler.select">select</a></code></li>
<li><code><a title="scrolls.builtins.RandomExpansionHandler.shuffle" href="#scrolls.builtins.RandomExpansionHandler.shuffle">shuffle</a></code></li>
<li><code><a title="scrolls.builtins.RandomExpansionHandler.uniform" href="#scrolls.builtins.RandomExpansionHandler.uniform">uniform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.builtins.StdIoCommandHandler" href="#scrolls.builtins.StdIoCommandHandler">StdIoCommandHandler</a></code></h4>
<ul class="">
<li><code><a title="scrolls.builtins.StdIoCommandHandler.input" href="#scrolls.builtins.StdIoCommandHandler.input">input</a></code></li>
<li><code><a title="scrolls.builtins.StdIoCommandHandler.print" href="#scrolls.builtins.StdIoCommandHandler.print">print</a></code></li>
<li><code><a title="scrolls.builtins.StdIoCommandHandler.write" href="#scrolls.builtins.StdIoCommandHandler.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.builtins.StringExpansionHandler" href="#scrolls.builtins.StringExpansionHandler">StringExpansionHandler</a></code></h4>
<ul class="two-column">
<li><code><a title="scrolls.builtins.StringExpansionHandler.chr" href="#scrolls.builtins.StringExpansionHandler.chr">chr</a></code></li>
<li><code><a title="scrolls.builtins.StringExpansionHandler.concat" href="#scrolls.builtins.StringExpansionHandler.concat">concat</a></code></li>
<li><code><a title="scrolls.builtins.StringExpansionHandler.getc" href="#scrolls.builtins.StringExpansionHandler.getc">getc</a></code></li>
<li><code><a title="scrolls.builtins.StringExpansionHandler.len" href="#scrolls.builtins.StringExpansionHandler.len">len</a></code></li>
<li><code><a title="scrolls.builtins.StringExpansionHandler.ord" href="#scrolls.builtins.StringExpansionHandler.ord">ord</a></code></li>
<li><code><a title="scrolls.builtins.StringExpansionHandler.rangev" href="#scrolls.builtins.StringExpansionHandler.rangev">rangev</a></code></li>
<li><code><a title="scrolls.builtins.StringExpansionHandler.vempty" href="#scrolls.builtins.StringExpansionHandler.vempty">vempty</a></code></li>
<li><code><a title="scrolls.builtins.StringExpansionHandler.vhead" href="#scrolls.builtins.StringExpansionHandler.vhead">vhead</a></code></li>
<li><code><a title="scrolls.builtins.StringExpansionHandler.vtail" href="#scrolls.builtins.StringExpansionHandler.vtail">vtail</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>