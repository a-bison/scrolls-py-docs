<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scrolls.interpreter API documentation</title>
<meta name="description" content="The interpreter implementation â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrolls.interpreter</code></h1>
</header>
<section id="section-intro">
<p>The interpreter implementation.</p>
<p>This module is the main point of interaction for most uses of Scrolls. The <code><a title="scrolls.interpreter.Interpreter" href="#scrolls.interpreter.Interpreter">Interpreter</a></code> implements functions that
interpret Scrolls scripts. The <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> class is responsible for tracking the state of the Scrolls
interpreter.</p>
<h1 id="using-the-interpreter">Using the Interpreter</h1>
<h2 id="quickstart">Quickstart</h2>
<p>Basic usage of the interpreter is straightforward. Instantiate <code><a title="scrolls.interpreter.Interpreter" href="#scrolls.interpreter.Interpreter">Interpreter</a></code>, and configure it with the desired
features, either from <code><a title="scrolls.builtins" href="builtins.html">scrolls.builtins</a></code>, or custom modules. Then, the interpreter may be used to run Scrolls scripts.</p>
<pre><code class="language-py">import scrolls

# Create an interpreter. Note that an interpreter created this 
# way will not actually do anything. It's the responsibility of 
# the user to configure with the desired language features.
interpreter = scrolls.Interpreter()

# Configure the interpreter with the base language.
# scrolls.base_config is provided to make this common task
# a bit easier.
scrolls.base_config.configure(interpreter)

# Configure with stdio commands like input, and print
interpreter.command_handlers.add(scrolls.StdIoCommandHandler())

# Run your script.
script = &quot;&quot;&quot;
!repeat(4) {
    print &quot;Hello world!&quot;
}
&quot;&quot;&quot;
interpreter.run(script)

# Note: This will print
# Hello world!
# Hello world!
# Hello world!
# Hello world!
</code></pre>
<p><code>scrolls.__main__</code> implements a bare minimum standalone Scrolls interpreter with this interface. Take a look if you
need a more concrete example.</p>
<h2 id="extensions">Extensions</h2>
<p>Of course, the main usage of Scrolls is not as a standalone language, but as an engine embedded in a parent application.
Eventually, you'll most likely need to implement extensions to the language.</p>
<p>The primary method of extending Scrolls is through call handlers (<code><a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a></code>).</p>
<h3 id="call-types">Call Types</h3>
<p>Calls come in three different types, however all calls are fundamentally function calls. Most of the time, they will
call into some python code, but support is offered for calls written in Scrolls code themselves (see <code>!def</code>).</p>
<h4 id="command-calls">Command Calls</h4>
<p>Command calls are what most languages would refer to as "statements".</p>
<pre><code class="language-scrolls">print &quot;Tell me your name:&quot;
input name
print &quot;Hello,&quot; $name
</code></pre>
<p>In the above example, <code>print</code> and <code>input</code> are command calls. Command calls do not return anything. In <code><a title="scrolls.interpreter" href="#scrolls.interpreter">scrolls.interpreter</a></code>
terms, command calls are calls for which <code><a title="scrolls.interpreter.CallHandler.handle_call" href="#scrolls.interpreter.CallHandler.handle_call">CallHandler.handle_call()</a></code> returns <code>None</code>. Command calls are counted as
statements. See <code><a title="scrolls.interpreter.Interpreter.interpret_statement" href="#scrolls.interpreter.Interpreter.interpret_statement">Interpreter.interpret_statement()</a></code>.</p>
<h4 id="expansion-calls">Expansion Calls</h4>
<p>Expansion calls are what most languages would refer to as "functions".</p>
<pre><code class="language-scrolls">print &quot;Here's a random choice:&quot; $(select foo bar baz)
print &quot;9 + 10 is:&quot; $(+ 9 10)
</code></pre>
<p>In the above example, <code>select</code> and <code>+</code> are expansion calls. Expansion calls always return strings. In <code><a title="scrolls.interpreter" href="#scrolls.interpreter">scrolls.interpreter</a></code>
terms, expansion calls are calls for which <code><a title="scrolls.interpreter.CallHandler.handle_call" href="#scrolls.interpreter.CallHandler.handle_call">CallHandler.handle_call()</a></code> returns <code>str</code>. Expansion calls are <strong>not</strong>
counted as statements, and must be used in the context of either a command call, or control call.</p>
<p>Note that even arithmetic operations like <code>+ - * /</code> are implemented as expansion calls.
See <code><a title="scrolls.builtins.ArithmeticExpansionHandler" href="builtins.html#scrolls.builtins.ArithmeticExpansionHandler">ArithmeticExpansionHandler</a></code>.</p>
<h4 id="control-calls">Control Calls</h4>
<p>Control calls implement control structures.</p>
<pre><code class="language-scrolls">!repeat(4) {
    print &quot;Hello world!&quot;
}
!if($true) print &quot;This was a true statement.&quot;
</code></pre>
<p>In the above example, <code>repeat</code> and <code>if</code> are control calls. Control calls are unique in that they take a Scrolls
statement in addition to the normal call arguments. This can be used to implement common control structures like
<code>if</code>, <code>while</code>, etc. See <code><a title="scrolls.builtins.BuiltinControlHandler" href="builtins.html#scrolls.builtins.BuiltinControlHandler">BuiltinControlHandler</a></code>. Control calls do not return anything, like command calls.
Control calls are counted as statements.</p>
<h3 id="implementing-call-handlers">Implementing Call Handlers</h3>
<p>The bare minimum for implementing a call handler is to implement the <code><a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a></code> protocol. Call handlers must implement
two functions:</p>
<ul>
<li><code>handle_call</code>: Called when a call is invoked.</li>
<li><code>__contains__</code>: Should return <code>True</code> if the call handler supports a call, i.e. <code>"call_name" in handler</code>.</li>
</ul>
<p>Let's make a simple command call handler for a call named <code>printargs</code>, which prints out all of the arguments passed to
it.</p>
<pre><code class="language-py">import scrolls

# Create interpreter
interpreter = scrolls.Interpreter()

# Create your handler
class PrintArgsHandler:
    def handle_call(self, ctx: scrolls.InterpreterContext) -&gt; None:
        if ctx.call_name == &quot;printargs&quot;:
            for arg in ctx.args:
                print(arg)

    def __contains__(self, call_name: str) -&gt; bool:
        return call_name == &quot;printargs&quot;

# Add the handler to the interpreter
interpreter.command_handlers.add(PrintArgsHandler())

# Run a script containing your command:
interpreter.run(&quot;&quot;&quot;
printargs foo bar &quot;this is one argument&quot; baz
&quot;&quot;&quot;)

# NOTE - Prints
# foo
# bar
# this is one argument
# baz
</code></pre>
<h3 id="using-callbackcallhandler">Using <code><a title="scrolls.interpreter.CallbackCallHandler" href="#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></code></h3>
<p>The <code><a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a></code> protocol is deliberately left simple for maximum flexibility, but it's also kind of awkward for most
uses. A basic call handler is provided to handle boilerplate, <code><a title="scrolls.interpreter.CallbackCallHandler" href="#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></code>.
Let's implement <code>printargs</code> with <code><a title="scrolls.interpreter.CallbackCallHandler" href="#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></code>.</p>
<pre><code class="language-py">import scrolls

# Create interpreter
interpreter = scrolls.Interpreter()

# Create your handler
# Note that this may also use the shortcut: scrolls.CallbackCommandHandler,
# but it's the same thing.
class PrintArgsHandler(scrolls.CallbackCallHandler[None]):
    def __init__(self):
        super().__init__()
        self.add_call(&quot;printargs&quot;, self.printargs)

    def printargs(self, ctx: scrolls.InterpreterContext) -&gt; None:
        for arg in ctx.args:
            print(arg)

# Add the handler to the interpreter
interpreter.command_handlers.add(PrintArgsHandler())

# Run a script containing your command:
interpreter.run(&quot;&quot;&quot;
printargs foo bar &quot;this is one argument&quot; baz
&quot;&quot;&quot;)

# NOTE - Prints
# foo
# bar
# this is one argument
# baz
</code></pre>
<p><code><a title="scrolls.interpreter.CallbackCallHandler" href="#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></code> may be considered the base call handler class for most purposes. All builtin language features
are implemented with <code><a title="scrolls.interpreter.CallbackCallHandler" href="#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></code>. See <code><a title="scrolls.builtins" href="builtins.html">scrolls.builtins</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The interpreter implementation.

.. include:: ./pdoc/interpreter.md
&#34;&#34;&#34;

import abc
import dataclasses
import logging
import pathlib
import types
import typing as t
import uuid

from . import ast, errors

__all__ = (
    &#34;ArgSourceMap&#34;,
    &#34;CallContext&#34;,
    &#34;ScopedVarStore&#34;,
    &#34;VarScope&#34;,
    &#34;InterpreterContext&#34;,
    &#34;CallHandler&#34;,
    &#34;CallbackCommandHandler&#34;,
    &#34;CallbackControlHandler&#34;,
    &#34;CallbackExpansionHandler&#34;,
    &#34;Interpreter&#34;,
    &#34;InterpreterError&#34;,
    &#34;InternalInterpreterError&#34;,
    &#34;ScrollCallback&#34;,
    &#34;Initializer&#34;,
    &#34;CallHandlerContainer&#34;,
    &#34;MutableCallHandlerContainer&#34;,
    &#34;BaseCallHandlerContainer&#34;,
    &#34;RuntimeCallHandler&#34;,
    &#34;CallbackCallHandler&#34;,
    &#34;InterpreterStop&#34;,
    &#34;InterpreterReturn&#34;,
    &#34;RuntimeCall&#34;,
    &#34;ChoiceCallHandlerContainer&#34;
)

logger = logging.getLogger(__name__)

T = t.TypeVar(&#34;T&#34;)
T_co = t.TypeVar(&#34;T_co&#34;, covariant=True)
AnyContextTV = t.TypeVar(&#34;AnyContextTV&#34;, bound=&#39;InterpreterContext&#39;)


class ArgSourceMap(dict[int, T], t.Generic[T]):
    &#34;&#34;&#34;A utility class that maps argument numbers to some source.

    The main purpose of this container is to map call arguments to the `scrolls.ast.ASTNode` they came from.
    This class is typically used to accurately point to a node in the case of a call error.

    Usage
    ```py
    # Note: SourceClass is just an example here.
    sources: typing.Sequence[SourceClass] = get_some_sources()
    source_map: ArgSourceMap[SourceClass] = ArgSourceMap()

    args = []
    for source in sources:
        args_from_source = source.get_args()
        source_map.add_args(args_from_source, source)

    # Now, you can use an arg number to look up which SourceClass it came from.
    arg_2_src = source_map[2]
    ```
    &#34;&#34;&#34;

    def __init__(self, *args: t.Any, **kwargs: t.Any):
        super().__init__(*args, **kwargs)

        self.count = 0

    def add_args(self, args: t.Sequence, source: T) -&gt; None:
        &#34;&#34;&#34;
        Add an `(args, source)` pair to this mapping. See usage example above.
        &#34;&#34;&#34;
        for i, _ in enumerate(args):
            self[i + self.count] = source

        self.count += len(args)


@dataclasses.dataclass
class CallContext:
    &#34;&#34;&#34;
    The context of a call. Contains all information necessary to run a call. Under normal circumstances,
    you won&#39;t need to create instances of this yourself. Instead access instances through:

    - `InterpreterContext.call_stack`
    - `InterpreterContext.call_context`

    &lt;br/&gt;

    .. NOTE::
        Control structures such as `!for`, `!while`, etc., are also considered calls, but they do not create
        a new `VarScope`. So, call contexts and variable scopes are considered separately.
    &#34;&#34;&#34;

    call_name: str
    &#34;&#34;&#34;The name of this call.&#34;&#34;&#34;

    args: t.Sequence[str]
    &#34;&#34;&#34;The arguments passed into this call.&#34;&#34;&#34;

    arg_nodes: ArgSourceMap[ast.ASTNode]
    &#34;&#34;&#34;A map of argument indices to the `scrolls.ast.ASTNode` they came from.&#34;&#34;&#34;

    control_node: t.Optional[ast.ASTNode] = None
    &#34;&#34;&#34;If this call is a control call, this will contain the call&#39;s `scrolls.ast.ASTNode` parameter.&#34;&#34;&#34;

    return_value: t.Optional[t.Any] = None
    &#34;&#34;&#34;The return value set by a runtime call.&#34;&#34;&#34;

    runtime_call: bool = False
    &#34;&#34;&#34;A runtime call is a call defined while the interpreter is running, such as through `!def`.&#34;&#34;&#34;


class VarScope:
    &#34;&#34;&#34;
    A variable scope. See `ScopedVarStore`.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        self.vars: t.MutableMapping[str, str] = {}
        &#34;&#34;&#34;The local variables defined in this scope.
        
        .. NOTE::
            Generally this should not be modified directly, use `ScopedVarStore.set_var` instead.
        &#34;&#34;&#34;

        self.nonlocals: t.MutableMapping[str, bool] = {}
        &#34;&#34;&#34;Nonlocal variables defined in this scope.
        
        If a variable is declared nonlocal, attempts to read/write it will go to the enclosing scope.
        
        .. NOTE::
            Generally this should not be modified directly, use `ScopedVarStore.declare_nonlocal` instead.
        &#34;&#34;&#34;

        self.globals: t.MutableMapping[str, bool] = {}
        &#34;&#34;&#34;Global variables defined in this scope.
        
        If a variable is declared global, attempts to read/write it will go to the global (top level) variable scope.
        
        .. NOTE::
            Generally this should not be modified directly, use `ScopedVarStore.declare_global` instead.
        &#34;&#34;&#34;


class ScopedVarStore:
    &#34;&#34;&#34;
    A variable store divided into a stack of key-value pairs.

    This class is used to implement the concept of local vs global variables in scrolls. Runtime calls (see
    `CallContext`) use scoped variable stores to allow the definition of local variables in call defs without
    stepping on existing variables.

    .. IMPORTANT::
        Calls implemented in Python do not enter a new variable scope by default. You typically won&#39;t need to enter
        a new scope unless you run Scrolls code during a call, i.e. for control calls, and runtime-defined calls.

        Most control calls, such as `while`, `for`, `if`, etc. do not need to define a new variable scope. The option
        is available if desired. See the source code of `RuntimeCallHandler.handle_call` for an example of defining
        a new scope.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        self.scopes: t.MutableSequence[VarScope] = []
        &#34;&#34;&#34;The `VarScope` stack. Later indices are deeper scopes. `scopes[0]` is the global scope, which is always available.&#34;&#34;&#34;

        self.new_scope()  # There should always be one scope.

    def new_scope(self) -&gt; None:
        &#34;&#34;&#34;
        Push a new scope onto the stack.
        &#34;&#34;&#34;
        self.scopes.append(VarScope())

    def destroy_scope(self) -&gt; None:
        &#34;&#34;&#34;
        Destroy the current scope and return to the last one. This will delete all local variables defined in the current
        scope.
        &#34;&#34;&#34;
        if len(self.scopes) == 1:
            # there should always be at least one scope
            raise ValueError(&#34;There must be at least one scope.&#34;)

        self.scopes.pop()

    def declare_nonlocal(self, name: str) -&gt; None:
        &#34;&#34;&#34;
        Declare a variable as nonlocal. This means that all attempts to read/write the variable will automatically
        go to the enclosing scope.
        &#34;&#34;&#34;
        self.current_scope.nonlocals[name] = True

    def declare_global(self, name: str) -&gt; None:
        &#34;&#34;&#34;
        Declare a variable as global. This means all attempts to read/write the variable will automatically go to
        the global scope.
        &#34;&#34;&#34;
        self.current_scope.globals[name] = True

    def search_scope(self, name: str, scopes: t.Sequence[VarScope], read_search: bool = False) -&gt; VarScope:
        &#34;&#34;&#34;
        Using a variable name, search up the scope stack for something to read/write. This search will honor nonlocal
        and global declarations made for all scopes.

        Args:
            name: The name of the variable to search for.

            scopes: The scopes to search. Typically, this will be `ScopedVarStore.scopes`.

            read_search: Must be `True` if no writes will be performed on the scope you&#39;re searching for.
            Adds additional logic that reads the global store as a fallback if a defined value could not be found
            after searching up the stack.

        Raises:
            KeyError: If an appropriate scope could not be found.
        &#34;&#34;&#34;
        scopes = list(scopes)
        scope = scopes[-1]

        while scopes:
            scope = scopes.pop()

            if name in scope.globals:
                # If global, immediately go to the highest scope
                return scopes[0] if scopes else scope

            if name in scope.nonlocals:
                # If nonlocal, go to the enclosing scope.
                continue

            # Just break as soon as we step off global/nonlocal references.
            break

        if read_search:
            # Do a little bit of extra logic for a read search. If we can&#39;t find a value in the
            # current scope, try globals as a fallback.
            if name in scope.vars:
                return scope
            elif scopes and name in scopes[0].vars:
                return scopes[0]
            else:
                raise KeyError(name)

        return scope

    def get_scope_for_read(self, name: str) -&gt; VarScope:
        &#34;&#34;&#34;Shortcut for `ScopedVarStore.search_scope(..., read_search=True)`

        See Also: `ScopedVarStore.search_scope`
        &#34;&#34;&#34;
        return self.search_scope(name, self.scopes, read_search=True)

    def get_scope_for_write(self, name: str) -&gt; VarScope:
        &#34;&#34;&#34;Shortcut for `ScopedVarStore.search_scope(..., read_search=False)`

        See Also: `ScopedVarStore.search_scope`
        &#34;&#34;&#34;
        return self.search_scope(name, self.scopes, read_search=False)

    @property
    def current_scope(self) -&gt; VarScope:
        &#34;&#34;&#34;The current scope.&#34;&#34;&#34;
        return self.scopes[-1]

    def get_var(self, name: str) -&gt; str:
        &#34;&#34;&#34;Get a variable from this store, following all nonlocal and global declarations.&#34;&#34;&#34;
        return self.get_scope_for_read(name).vars[name]

    def set_var(self, name: str, value: str) -&gt; None:
        &#34;&#34;&#34;Set a variable in this store, following all nonlocal and global declarations.&#34;&#34;&#34;
        try:
            scope = self.get_scope_for_write(name)
            scope.vars[name] = value
        except KeyError:
            self.current_scope.vars[name] = value

    def del_var(self, name: str) -&gt; None:
        &#34;&#34;&#34;Delete a variable from this store, following all nonlocal and global declarations.&#34;&#34;&#34;
        try:
            scope = self.get_scope_for_write(name)
            del scope.vars[name]
        except KeyError:
            del self.current_scope.vars[name]


class InterpreterContext:
    &#34;&#34;&#34;
    Base class for the command interpreter context. Contains all state information for the `Interpreter`.
    This is also the main interface plugin writers will use to interact with the interpreter, and is passed to all
    `CallHandler` implementations.
    &#34;&#34;&#34;
    def __init__(self, *_: t.Any):
        self._current_node: t.Optional[ast.ASTNode] = None
        self._call_context: t.Optional[CallContext] = None
        self._interpreter: t.Optional[Interpreter] = None
        self._vars = ScopedVarStore()

        self.statement_count = 0
        &#34;&#34;&#34;The number of statements that have been run by the interpreter so far.&#34;&#34;&#34;

        self._call_stack: t.MutableSequence[CallContext] = []
        self._command_handlers: BaseCallHandlerContainer[None] = BaseCallHandlerContainer()
        self._expansion_handlers: BaseCallHandlerContainer[str] = BaseCallHandlerContainer()

        self._open_files: t.MutableMapping[int, t.IO[str]] = {}
        self._fid = 0

    @property
    def vars(self) -&gt; ScopedVarStore:
        &#34;&#34;&#34;The variable store.&#34;&#34;&#34;
        return self._vars

    def set_var(self, name: str, value: str) -&gt; None:
        &#34;&#34;&#34;Set a variable.&#34;&#34;&#34;
        self.vars.set_var(name, value)

    def del_var(self, name: str) -&gt; None:
        &#34;&#34;&#34;Delete a variable.&#34;&#34;&#34;
        self.vars.del_var(name)

    def get_var(self, name: str) -&gt; str:
        &#34;&#34;&#34;Get a variable.&#34;&#34;&#34;
        return self.vars.get_var(name)

    def open_file(self, path: str, mode: str) -&gt; int:
        &#34;&#34;&#34;
        Opens a file for this context.

        Returns:
             A numeric file ID that should be used in other `*_file` functions
             for `InterpreterContext`.
        &#34;&#34;&#34;
        p = pathlib.Path(path)

        if not p.exists():
            raise InterpreterError(
                self,
                f&#34;{path} does not exist&#34;
            )

        if not p.is_file():
            raise InterpreterError(
                self,
                f&#34;{path} is not a file&#34;
            )

        # do not allow binary mode for now
        mode = mode.replace(&#34;b&#34;, &#34;&#34;)

        f = open(p, mode)
        self._open_files[self._fid] = f
        used_fid = self._fid
        self._fid += 1

        logger.debug(f&#34;Opened file: {path}&#34;)

        return used_fid

    def close_file(self, fid: int) -&gt; None:
        &#34;&#34;&#34;
        Closes a file for this context.
        &#34;&#34;&#34;
        if fid not in self._open_files:
            raise InterpreterError(
                self,
                f&#34;file already closed, or not open (fid {fid})&#34;
            )

        self._open_files[fid].close()
        del self._open_files[fid]

    def get_file(self, fid: int) -&gt; t.IO[str]:
        &#34;&#34;&#34;
        Gets an open file for this context.
        &#34;&#34;&#34;
        if fid not in self._open_files:
            raise InterpreterError(
                self,
                f&#34;file already closed, or not open (fid {fid})&#34;
            )

        return self._open_files[fid]

    @property
    def runtime_commands(self) -&gt; &#39;BaseCallHandlerContainer[None]&#39;:
        &#34;&#34;&#34;The call handler container for runtime command handlers. Runtime commands are defined while the interpreter
        is running, i.e. through the `!def` directive or similar. Runtime commands

        For any command handler added to this container, all commands defined within it:

        - **Should** always perform their work in their own variable scope. See `ScopedVarStore.new_scope`.
        - **Must** set the `CallContext.runtime_call` parameter to `True`.
        - **Must** cease executing if an `InterpreterStop` or `InterpreterReturn` is raised.
        &#34;&#34;&#34;
        return self._command_handlers

    @property
    def runtime_expansions(self) -&gt; &#39;BaseCallHandlerContainer[str]&#39;:
        &#34;&#34;&#34;Same as `InterpreterContext.runtime_commands`, but for expansion calls.

        Runtime expansions follow the same requirements as commands, plus:

        - **Must** set the `CallContext.return_value` parameter upon call completion.
        - **Must** catch `InterpreterReturn` and set the return value on this exception.
        &#34;&#34;&#34;
        return self._expansion_handlers

    @property
    def interpreter(self) -&gt; &#39;Interpreter&#39;:
        &#34;&#34;&#34;
        The interpreter running using this context.

        Raises:
            InternalInterpreterError: If this property is not initialized.
        &#34;&#34;&#34;
        if self._interpreter is None:
            raise InternalInterpreterError(
                self, &#34;Interpreter is not initialized.&#34;
            )

        return self._interpreter

    @interpreter.setter
    def interpreter(self, interpreter: &#39;Interpreter&#39;) -&gt; None:
        self._interpreter = interpreter

    @property
    def current_node(self) -&gt; ast.ASTNode:
        &#34;&#34;&#34;
        The current `scrolls.ast.ASTNode` being interpreted.

        Raises:
            InternalInterpreterError: If there is no current node.
        &#34;&#34;&#34;
        if self._current_node is None:
            raise InternalInterpreterError(
                self, &#34;Current node is not initialized.&#34;
            )

        return self._current_node

    @current_node.setter
    def current_node(self, node: ast.ASTNode) -&gt; None:
        self._current_node = node

    def _call_check(self) -&gt; None:
        if self._call_context is None:
            raise InternalInterpreterError(
                self, &#34;Current context is not a call.&#34;
            )

    @property
    def call_stack(self) -&gt; t.Sequence[CallContext]:
        &#34;&#34;&#34;
        The call stack. Used primarily for tracking return values in runtime calls, and feeding
        call information to `CallHandler` implementations. Variables scopes are tracked separately.
        See `InterpreterContext.vars`.

        .. WARNING::
            This stack does not contain the current call. See `InterpreterContext.call_context` for that.
        &#34;&#34;&#34;
        return self._call_stack

    @property
    def call_context(self) -&gt; CallContext:
        &#34;&#34;&#34;
        The current call context.
        &#34;&#34;&#34;
        self._call_check()
        return t.cast(CallContext, self._call_context)

    @property
    def call_name(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the current call.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.call_name

    @property
    def args(self) -&gt; t.Sequence[str]:
        &#34;&#34;&#34;
        The argments passed into the current call.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.args

    @property
    def arg_nodes(self) -&gt; ArgSourceMap[ast.ASTNode]:
        &#34;&#34;&#34;
        The `scrolls.ast.ASTNode` instances the current call&#39;s arguments came from.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.arg_nodes

    @property
    def control_node(self) -&gt; ast.ASTNode:
        &#34;&#34;&#34;
        If the current context is a control call, this will contain the `scrolls.ast.ASTNode` parameter passed into it.

        Raises:
            InternalInterpreterError: If the current context is not a call.
        &#34;&#34;&#34;
        if self.call_context.control_node is None:
            raise InternalInterpreterError(
                self, &#34;Current context is not a control call.&#34;
            )

        return self.call_context.control_node

    def set_call(
        self,
        command: str,
        args: t.Sequence[str],
        arg_nodes: ArgSourceMap[ast.ASTNode],
        control_node: t.Optional[ast.ASTNode] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Sets the current call context, overwriting whatever was previously current. If you want to preserve the
        current context for later use, see `InterpreterContext.push_call`

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        self._call_context = CallContext(
            command,
            args,
            arg_nodes,
            control_node
        )

    def in_call(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the current context is in a call or not.
        &#34;&#34;&#34;
        return self._call_context is not None

    def reset_call(self) -&gt; None:
        &#34;&#34;&#34;
        Destroys the current call context.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        self._call_context = None

    def push_call(self) -&gt; None:
        &#34;&#34;&#34;
        Duplicate the current call context and push it onto the call stack. Should be followed up with
        `InterpreterContext.set_call` to create a new context.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        self._call_check()
        self._call_stack.append(self.call_context)

    def pop_call(self) -&gt; None:
        &#34;&#34;&#34;
        Destroy the current call context, and replace it with the first context on the call stack.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.

        Raises:
            InternalInterpreterError: If not calls have been pushed.
        &#34;&#34;&#34;
        if not self._call_stack:
            raise InternalInterpreterError(
                self,
                f&#34;Cannot pop call. No calls pushed.&#34;
            )

        ctx = self._call_stack.pop()
        self._call_context = ctx

    # In order to set a return value, we need to traverse up the
    # context stack in order to find one actually created by a dynamically
    # generated call.
    def set_retval(self, retval: str) -&gt; None:
        &#34;&#34;&#34;
        Sets the return value in the first runtime call found in the stack.

        Raises:
            InterpreterError: If outside a call context, no call stack, or no runtime call contexts found.
        &#34;&#34;&#34;
        self._call_check()

        if not self.call_stack:
            raise InterpreterError(
                self,
                f&#34;cannot return, no call stack (outside calls)&#34;
            )

        for ctx in reversed(self.call_stack):
            if ctx.runtime_call:
                ctx.return_value = retval
                return

        raise InterpreterError(
            self,
            f&#34;cannot return outside of function&#34;
        )


class CallHandler(t.Protocol[T_co]):
    &#34;&#34;&#34;
    The minimum interface required to implement a call handler.
    &#34;&#34;&#34;
    def handle_call(self, context: AnyContextTV) -&gt; T_co:
        &#34;&#34;&#34;
        Handle a call. An `InterpreterContext` object will be passed in reflecting the state of the `Interpreter` for
        this call.
        &#34;&#34;&#34;
        ...

    def __contains__(self, command_name: str) -&gt; bool: ...


class ScrollCallback(t.Protocol[T_co]):
    &#34;&#34;&#34;
    Protocol for Callbacks passed into CallbackCallHandlers.

    A `ScrollCallback` is any `typing.Callable` that takes an `InterpreterContext` or subclass as its only parameter.
    &#34;&#34;&#34;
    def __call__(self, context: AnyContextTV) -&gt; T_co: ...


class Initializer(abc.ABC):
    &#34;&#34;&#34;
    The base class for initializers. Initializers are used by the interpreter to set up `InterpreterContext` instances
    immediately before a script is run. Initializers are considered to implement the `CallHandler` interface, even though
    they don&#39;t actually handle calls.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def handle_call(self, context: AnyContextTV) -&gt; None:
        &#34;&#34;&#34;
        Initialize an `InterpreterContext` or subclass.
        &#34;&#34;&#34;
        ...

    def __contains__(self, command_name: str) -&gt; bool:
        return False


@dataclasses.dataclass
class RuntimeCall:
    &#34;&#34;&#34;
    A simple runtime call that is implemented by some Scrolls code.

    .. WARNING::
        Instances of this class are created automatically by `RuntimeCallHandler`.
    &#34;&#34;&#34;

    name: str
    &#34;&#34;&#34;The name of the call.&#34;&#34;&#34;

    node: ast.ASTNode
    &#34;&#34;&#34;The statement node that should be run when this call is executed.&#34;&#34;&#34;

    params: t.Sequence[str]
    &#34;&#34;&#34;The names of the parameters, corresponding to the names of the local variables created when this call
    is executed.
    &#34;&#34;&#34;

    collect_param: t.Optional[str]
    &#34;&#34;&#34;The name of the collect parameter, if any. This will always be the last parameter, and will
    collect all extra arguments fed into this call and interpret them as a string vector. In other words, this is
    the `*args` parameter, for Scrolls.
    &#34;&#34;&#34;


class RuntimeCallHandler(t.Generic[T_co]):
    &#34;&#34;&#34;
    A basic call handler that maps names to AST nodes.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        self.calls: t.MutableMapping[str, RuntimeCall] = {}

    def define(self, name: str, node: ast.ASTNode, params: t.Sequence[str]) -&gt; None:
        &#34;&#34;&#34;
        Defines a new call implemented with Scrolls code. See `RuntimeCall`.
        &#34;&#34;&#34;
        collect_param: t.Optional[str] = None

        if params and params[-1].startswith(&#34;*&#34;):
            collect_param = params[-1][1:]
            params = params[:-1]

        call = RuntimeCall(
            name,
            node,
            params,
            collect_param
        )

        self.calls[name] = call

    def undefine(self, name: str) -&gt; None:
        &#34;&#34;&#34;
        Delete a defined runtime call.
        &#34;&#34;&#34;
        del self.calls[name]

    def handle_call(self, context: InterpreterContext) -&gt; T_co:
        call = self.calls[context.call_name]

        # Arg length check
        if call.collect_param is None:
            if len(call.params) != len(context.args):
                raise InterpreterError(
                    context,
                    f&#34;{context.call_name}: Invalid # of arguments (expected {len(call.params)})&#34;
                )
        else:
            if len(context.args) &lt; len(call.params) - 1:
                raise InterpreterError(
                    context,
                    f&#34;{context.call_name}: Invalid # of arguments (expected at least {len(call.params)})&#34;
                )

        params = list(call.params)

        if call.collect_param is None:
            args = context.args
        else:
            params.append(call.collect_param)
            collected = context.args[len(call.params):]
            args = list(context.args[:len(call.params)])
            args.append(&#34; &#34;.join(collected))

        # New scope must be created. We&#39;re running Scrolls code to implement this call, so it might trample
        # what&#39;s been defined otherwise. Plus, we don&#39;t want our call arguments to continue existing
        # after we&#39;re done.
        context.vars.new_scope()
        for param, arg in zip(params, args):
            context.set_var(param, arg)

        context.call_context.runtime_call = True
        try:
            # Interpret the body of the call.
            context.interpreter.interpret_statement(context, call.node)
        except InterpreterReturn:
            pass

        context.vars.destroy_scope()

        # TODO Fix typing here
        return t.cast(T_co, context.call_context.return_value)

    def __contains__(self, command_name: str) -&gt; bool:
        return command_name in self.calls


class CallbackCallHandler(t.Generic[T_co]):
    &#34;&#34;&#34;
    A basic call handler that uses `typing.Callable` (`ScrollCallback`) to
    implement a call handler.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        self.calls: t.MutableMapping[str, ScrollCallback[T_co]] = {}
        self.aliases: t.MutableMapping[str, str] = {}

    def add_call(self, name: str, command: ScrollCallback[T_co]) -&gt; None:
        &#34;&#34;&#34;
        Add a call.
        &#34;&#34;&#34;
        self.calls[name] = command

    def add_alias(self, alias: str, name: str) -&gt; None:
        &#34;&#34;&#34;Adds an alias for the named call. The call can then be executed by either it&#39;s real name or any of the
        defined aliases.&#34;&#34;&#34;
        self.aliases[alias] = name

    def remove_call(self, name: str) -&gt; None:
        &#34;&#34;&#34;Remove a call. Note that this also removes all of its associated aliases.&#34;&#34;&#34;
        del self.calls[name]

        # Delete all aliases associated with the name.
        for key, value in self.aliases.items():
            if value == name:
                del self.aliases[key]

    def get_callback(self, name: str) -&gt; ScrollCallback[T_co]:
        &#34;&#34;&#34;Get the callback for a call.&#34;&#34;&#34;
        if name in self.calls:
            return self.calls[name]

        return self.calls[self.aliases[name]]

    def handle_call(self, context: InterpreterContext) -&gt; T_co:
        return self.get_callback(context.call_name)(context)

    def __contains__(self, command_name: str) -&gt; bool:
        logger.debug(f&#34;{self.__class__.__qualname__}: __contains__({command_name})&#34;)
        return (
            command_name in self.calls or
            command_name in self.aliases
        )


CallbackCommandHandler = CallbackCallHandler[None]
&#34;&#34;&#34;A basic command handler, shortcut for `CallbackCallHandler[None]`.&#34;&#34;&#34;

CallbackControlHandler = CallbackCallHandler[None]
&#34;&#34;&#34;A basic control handler, shortcut for `CallbackCallHandler[None]`.&#34;&#34;&#34;

CallbackExpansionHandler = CallbackCallHandler[str]
&#34;&#34;&#34;A basic expansion handler, shortcut for `CallbackCallHandler[str]`.&#34;&#34;&#34;


class CallHandlerContainer(t.Protocol[T_co]):
    &#34;&#34;&#34;
    A read-only `CallHandler` container.
    &#34;&#34;&#34;
    def get(self, name: str) -&gt; CallHandler[T_co]: ...
    &#34;&#34;&#34;Gets a call handler by name.&#34;&#34;&#34;

    def get_for_call(self, name: str) -&gt; CallHandler[T_co]: ...
    &#34;&#34;&#34;Gets a call handler for the named call.&#34;&#34;&#34;

    def __iter__(self) -&gt; t.Iterator[CallHandler[T_co]]: ...


class MutableCallHandlerContainer(CallHandlerContainer[T], t.Protocol[T]):
    &#34;&#34;&#34;
    A mutable `CallHandler` container.
    &#34;&#34;&#34;
    def add(self, handler: CallHandler[T], name: str = &#34;&#34;) -&gt; None: ...
    &#34;&#34;&#34;Add a call handler to this container.
    
    If `name` is not specified, then a unique name should be generated. The specific name generated is up to the
    implementor.
    &#34;&#34;&#34;

    def remove(self, handler: t.Union[CallHandler[T], str]) -&gt; None: ...
    &#34;&#34;&#34;Remove a call handler from this container.&#34;&#34;&#34;


class BaseCallHandlerContainer(t.Generic[T]):
    &#34;&#34;&#34;
    Generic container for `CallHandler` implementors.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        self._handlers: t.MutableMapping[str, CallHandler[T]] = {}

    def add(self, handler: CallHandler[T], name: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Add a call handler to this container.

        If `name` is not specified, then a unique name will be generated through `uuid.uuid4`.
        &#34;&#34;&#34;
        if not name:
            name = str(uuid.uuid4())

        logger.debug(f&#34;Register call handler type {handler.__class__.__qualname__} name {name}&#34;)
        self._handlers[name] = handler

    def add_all(self, handlers: t.Sequence[CallHandler[T]]) -&gt; None:
        &#34;&#34;&#34;Shortcut, adds all handlers in a list at once.&#34;&#34;&#34;
        for handler in handlers:
            self.add(handler)

    def find(self, handler: t.Union[CallHandler[T], str]) -&gt; tuple[str, CallHandler[T]]:
        &#34;&#34;&#34;Find a call handler.

        Args:
            handler: The handler to search for. It may be a CallHandler object, or the name of the handler to search for.

        Returns:
            A `tuple` of the form `(name, call_handler)`.
        &#34;&#34;&#34;
        if isinstance(handler, str):
            return handler, self._handlers[handler]
        else:
            for k, v in self._handlers.items():
                if v is handler:
                    return k, v

            raise KeyError(repr(handler))

    def remove(self, handler: t.Union[CallHandler[T], str]) -&gt; None:
        &#34;&#34;&#34;Remove a call handler from this container.&#34;&#34;&#34;
        k, v = self.find(handler)
        del self._handlers[k]

    def get(self, name: str) -&gt; CallHandler[T]:
        &#34;&#34;&#34;Gets a call handler by name.&#34;&#34;&#34;
        return self._handlers[name]

    def get_for_call(self, name: str) -&gt; CallHandler[T]:
        &#34;&#34;&#34;
        Get the handler for a given command name.
        &#34;&#34;&#34;
        logger.debug(f&#34;get_for_call: {name}&#34;)
        for handler in self._handlers.values():
            if name in handler:
                return handler

        raise KeyError(name)

    def __iter__(self) -&gt; t.Iterator[CallHandler[T]]:
        yield from self._handlers.values()


class ChoiceCallHandlerContainer(t.Generic[T]):
    &#34;&#34;&#34;
    A call handler tries to handle a call with a sequence of call handler containers, one after another.
    &#34;&#34;&#34;
    def __init__(self, *containers: CallHandlerContainer[T]):
        self.containers = containers

    def get(self, name: str) -&gt; CallHandler[T]:
        for container in self.containers:
            try:
                return container.get(name)
            except KeyError:
                pass

        raise KeyError(name)

    def get_for_call(self, name: str) -&gt; CallHandler[T]:
        logger.debug(f&#34;ChoiceCallHandlerContainer: get_for_call {name}&#34;)
        for container in self.containers:
            try:
                return container.get_for_call(name)
            except KeyError:
                logger.debug(f&#34;fail on {container.__class__.__qualname__}&#34;)
                pass

        raise KeyError(name)

    def __iter__(self) -&gt; t.Iterator[CallHandler[T]]:
        for container in self.containers:
            yield from container


class InterpreterError(errors.PositionalError):
    &#34;&#34;&#34;
    A generic interpreter error. All interpreter errors should subclass this.
    &#34;&#34;&#34;
    def __init__(self, ctx: InterpreterContext, message: str):
        self.ctx = ctx

        if self.ctx.current_node.has_token():
            tok = self.ctx.current_node.tok
            super().__init__(
                tok.line,
                tok.position,
                tok.tokenizer.stream.history(),
                message
            )
        else:
            super().__init__(
                0,
                0,
                &#34;&#34;,
                message
            )

    def __str__(self) -&gt; str:
        if self.ctx.current_node.has_token():
            return super().__str__()
        else:
            return &#34;Interpreter error on node with uninitialized token.&#34;


class MissingCallError(InterpreterError):
    &#34;&#34;&#34;
    Raised when a call cannot be found.
    &#34;&#34;&#34;
    def __init__(self, ctx: InterpreterContext, call_type: str, call_name: str):
        self.call = call_name
        message = f&#34;{call_type.capitalize()} &#39;{call_name}&#39; not found.&#34;
        super().__init__(
            ctx, message
        )


class InternalInterpreterError(InterpreterError):
    &#34;&#34;&#34;
    Raised on critical interpreter errors that are usually the result of bugs.
    &#34;&#34;&#34;
    def __init__(self, context: InterpreterContext, message: str):
        super().__init__(
            context,
            &#34;INTERNAL ERROR. If you see this, please report it!\n&#34; + message
        )


class InterpreterStop(errors.ScrollError):
    &#34;&#34;&#34;
    An exception raised to stop the interpreter.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__(&#34;InterpreterStop&#34;)


class InterpreterReturn(errors.ScrollError):
    &#34;&#34;&#34;
    An exception raised to signal a return from a runtime call.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__(&#34;InterpreterReturn&#34;)


class Interpreter:
    &#34;&#34;&#34;
    The interpreter implementation for Scrolls. Configure through the `*_handlers` properties. Or, for a more organized
    configuration, see `scrolls.containers.DecoratorInterpreterConfig`.

    Args:
        context_cls: The `InterpreterContext` class to use when automatically instantiating new context objects.
            Must be `InterpreterContext` or a subclass of it.

        statement_limit: The number of statements allowed while executing a script. This is counted in the
            `InterpreterContext` object for a given run. If the number of executed statements exceeds this, an
            `InterpreterError` will be raised. If set to zero, then there is no statement limit.

        call_depth_limit: The number of levels deep the call stack is allowed to go. This is used to prevent
            denial of service through infinite recursion. If zero, then call depth is unlimited.
    &#34;&#34;&#34;
    def __init__(
        self,
        context_cls: t.Type[InterpreterContext] = InterpreterContext,
        statement_limit: int = 0,
        call_depth_limit: int = 200
    ):
        self._command_handlers: BaseCallHandlerContainer[None] = BaseCallHandlerContainer()
        self._control_handlers: BaseCallHandlerContainer[None] = BaseCallHandlerContainer()
        self._expansion_handlers: BaseCallHandlerContainer[str] = BaseCallHandlerContainer()
        self._initializers: BaseCallHandlerContainer[None] = BaseCallHandlerContainer()

        self.context_cls = context_cls
        &#34;&#34;&#34;
        The `InterpreterContext` class to use when automatically instantiating new context objects.
        Must be `InterpreterContext` or a subclass of it.
        &#34;&#34;&#34;

        self.statement_limit = statement_limit
        self.call_depth_limit = call_depth_limit

    def over_statement_limit(self, context: InterpreterContext) -&gt; bool:
        &#34;&#34;&#34;
        Utility function. Checks whether the passed context has exceeded the statement limit set for this interpreter.
        &#34;&#34;&#34;
        if self.statement_limit == 0:
            return False
        else:
            return context.statement_count &gt; self.statement_limit

    def over_call_depth_limit(self, context: InterpreterContext) -&gt; bool:
        &#34;&#34;&#34;
        Utility function. Checks whether the passed context has exceeded the call stack depth limit set for this
        interpreter.
        &#34;&#34;&#34;
        if self.call_depth_limit == 0:
            return False
        else:
            return len(context.call_stack) &gt; self.call_depth_limit

    @property
    def command_handlers(self) -&gt; BaseCallHandlerContainer[None]:
        &#34;&#34;&#34;The container of command handlers for this interpreter.&#34;&#34;&#34;
        return self._command_handlers

    @property
    def control_handlers(self) -&gt; BaseCallHandlerContainer[None]:
        &#34;&#34;&#34;The container of control handlers for this interpreter.&#34;&#34;&#34;
        return self._control_handlers

    @property
    def expansion_handlers(self) -&gt; BaseCallHandlerContainer[str]:
        &#34;&#34;&#34;The container of expansion handlers for this interpreter.&#34;&#34;&#34;
        return self._expansion_handlers

    @property
    def initializers(self) -&gt; BaseCallHandlerContainer[None]:
        &#34;&#34;&#34;The container of `Initializer` instances for this interpreter.&#34;&#34;&#34;
        return self._initializers

    def apply_initializers(self, context: InterpreterContext) -&gt; None:
        &#34;&#34;&#34;Apply this interpreter&#39;s context initializers to the given context object.&#34;&#34;&#34;
        for init in self.initializers:
            init.handle_call(context)

    def run(
        self,
        script: str,
        context: t.Optional[InterpreterContext] = None,
        consume_rest_triggers: t.Mapping[str, int] = types.MappingProxyType({})
    ) -&gt; InterpreterContext:
        &#34;&#34;&#34;Run a Scrolls script.

        Args:
            script: The script to run.
            context: Optional. If no context is specified, then an instance of `Interpreter.context_cls` is created
                automatically. Otherwise, the passed context object will be used.
            consume_rest_triggers: A mapping of triggers for the CONSUME_REST parsing feature.

        Returns:
            The context used to execute the script. If `context` was not None, `context` will be returned. Otherwise,
            it will be the automatically created `InterpreterContext` instance.
        &#34;&#34;&#34;
        tokenizer = ast.Tokenizer(script, consume_rest_triggers)
        tree = ast.parse_scroll(tokenizer)
        return self.interpret_ast(tree, context)

    def init_context(self, context: InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Initialize a context for this interpreter.
        &#34;&#34;&#34;
        context.interpreter = self
        self.apply_initializers(context)

    def run_statement(
        self,
        statement: t.Union[str, ast.Tokenizer],
        context: t.Optional[InterpreterContext] = None,
    ) -&gt; InterpreterContext:
        &#34;&#34;&#34;Run a single Scrolls statement.

        Args:
            statement: The statement to run. Must be either a string, or a tokenizer populated with a valid Scrolls
                statement.
            context: Optional. If no context is specified, then an instance of `Interpreter.context_cls` is created
                automatically. Otherwise, the passed context object will be used.

        Returns:
            The context used to execute the script. If `context` was not None, `context` will be returned. Otherwise,
            it will be the automatically created `InterpreterContext` instance.
        &#34;&#34;&#34;
        # Set up parsing and parse statement
        if isinstance(statement, str):
            tokenizer = ast.Tokenizer(statement)
        else:
            tokenizer = statement

        statement_node = ast.parse_statement(tokenizer)

        # Interpret statement
        if context is None:
            context = self.context_cls(statement_node)

        self.init_context(context)
        self.interpret_statement(context, statement_node)

        return context

    def repl(
        self,
        on_error: t.Optional[t.Callable[[errors.ScrollError], None]] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Drop into a REPL (read eval print loop).

        Args:
            on_error: A function to call when an error occurs. If `None`,
                      errors will stop the REPL.
        &#34;&#34;&#34;
        stream = ast.REPLStream()
        tokenizer = ast.Tokenizer(stream)
        context = self.context_cls()
        self.init_context(context)

        while True:
            try:
                statement_node = ast.parse_statement(tokenizer)
                stream.set_statement()

                self.interpret_statement(context, statement_node)
            except InterpreterStop:
                return
            except InterpreterReturn:
                e = InterpreterError(
                    context,
                    f&#34;returning only allowed in functions&#34;
                )
                if on_error is not None:
                    on_error(e)
                    stream.set_statement()
                    stream.next_line()
                else:
                    raise e
            except KeyboardInterrupt:
                print(&#34;Keyboard interrupt.&#34;)
                return
            except errors.ScrollError as e:
                if on_error is not None:
                    on_error(e)
                    stream.set_statement()
                    stream.next_line()
                else:
                    raise


    @staticmethod
    def test_parse(
        script: str,
        consume_rest_triggers: t.Mapping[str, int] = types.MappingProxyType({})
    ) -&gt; str:
        &#34;&#34;&#34;
        Returns a JSON-formatted string showing the full `scrolls.ast.ASTNode` structure of a parsed script, including
        `consume_rest_triggers`.

        .. WARNING::
            For debugging and demonstration purposes only.
        &#34;&#34;&#34;
        tokenizer = ast.Tokenizer(script, consume_rest_triggers)
        tree = ast.parse_scroll(tokenizer)
        return tree.prettify()

    def interpret_ast(
        self,
        tree: ast.AST,
        context: t.Optional[InterpreterContext] = None
    ) -&gt; InterpreterContext:
        &#34;&#34;&#34;
        Interprets a full AST structure.

        Args:
            tree: The AST to interpret.
            context: Optional. If no context is specified, then an instance of `Interpreter.context_cls` is created
                automatically. Otherwise, the passed context object will be used.

        Returns:
            The context used to execute the script. If `context` was not None, `context` will be returned. Otherwise,
            it will be the automatically created `InterpreterContext` instance.
        &#34;&#34;&#34;
        if context is None:
            context = self.context_cls(tree.root)

        context.interpreter = self
        self.apply_initializers(context)

        try:
            self.interpret_root(context, tree.root)
        except InterpreterStop:
            logger.debug(&#34;Interpreter stop raised.&#34;)
            pass
        except InterpreterReturn:
            raise InterpreterError(
                context,
                f&#34;returning only allowed in functions&#34;
            )

        return context

    def interpret_root(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.ROOT`.&#34;&#34;&#34;
        self.interpret_block(context, node)

    def interpret_call(
        self,
        call_handler_container: CallHandlerContainer[T_co],
        context: InterpreterContext,
        node: ast.ASTNode,
        expected_node_type: ast.ASTNodeType,
        pass_control_node: bool = False
    ) -&gt; T_co:
        &#34;&#34;&#34;
        Generic function for interpreting call nodes.

        Args:
            call_handler_container: The call handler container to check for call handlers.
            context: The interpreter context.
            node: The AST node to interpret.
            expected_node_type: The type of AST node to be expected.
            pass_control_node: Whether to pass `node.children[2]` into the control parameter of a call. Currently,
                this only applies to control calls. See `InterpreterContext.control_node`.

        Returns:
            The result of the call, if any.

        Related:
            `Interpreter.interpret_command` `Interpreter.interpret_control` `Interpreter.interpret_expansion_call`
        &#34;&#34;&#34;

        if node.type != expected_node_type:
            raise InternalInterpreterError(
                context,
                f&#34;interpret_call: name: Expected {expected_node_type.name}, got {node.type.name}&#34;
            )

        name_node = node.children[0]
        args_node = node.children[1]
        arg_node_map: ArgSourceMap[ast.ASTNode] = ArgSourceMap()

        raw_call = list(self.interpret_string_or_expansion(context, name_node))

        if not raw_call:
            raise InterpreterError(
                context,
                f&#34;Call name must not expand to empty string.&#34;
            )

        arg_node_map.add_args(raw_call[1:], name_node)

        for arg_node in args_node.children:
            new_args = self.interpret_string_or_expansion(context, arg_node)
            arg_node_map.add_args(new_args, arg_node)

            raw_call += new_args

        logger.debug(f&#34;interpret_call: raw {raw_call}&#34;)
        call_name = raw_call[0]
        call_args: t.Sequence[str] = raw_call[1:]

        context.current_node = node
        control_node: t.Optional[ast.ASTNode]

        if pass_control_node:
            control_node = node.children[2]
        else:
            control_node = None

        if context.in_call():
            context.push_call()
            if self.over_call_depth_limit(context):
                raise InterpreterError(
                    context,
                    f&#34;Maximum call stack depth ({self.call_depth_limit}) exceeded.&#34;
                )

        context.set_call(call_name, call_args, arg_node_map, control_node=control_node)

        try:
            handler = call_handler_container.get_for_call(call_name)
        except KeyError:
            context.current_node = name_node
            raise MissingCallError(context, expected_node_type.name, call_name)

        try:
            result: T_co = handler.handle_call(context)
        except InterpreterReturn:
            # Ensure call stack is properly changed even on returns
            if context.call_stack:
                context.pop_call()
            else:
                context.reset_call()

            raise

        if context.call_stack:
            context.pop_call()
        else:
            context.reset_call()

        return result

    def interpret_control(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.CONTROL_CALL`.&#34;&#34;&#34;
        self.interpret_call(
            self.control_handlers,
            context,
            node,
            ast.ASTNodeType.CONTROL_CALL,
            pass_control_node=True
        )

    def interpret_command(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.COMMAND_CALL`.&#34;&#34;&#34;
        self.interpret_call(
            ChoiceCallHandlerContainer(
                context.runtime_commands,
                self.command_handlers
            ),
            context,
            node,
            ast.ASTNodeType.COMMAND_CALL
        )

    def interpret_variable_reference(self, context: InterpreterContext, node: ast.ASTNode) -&gt; str:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.EXPANSION_VAR`.&#34;&#34;&#34;
        context.current_node = node

        var_name = &#34; &#34;.join(self.interpret_string_or_expansion(context, node.children[0]))
        try:
            return context.get_var(var_name)
        except KeyError:
            raise InterpreterError(
                context, f&#34;No such variable {var_name}.&#34;
            )

    def interpret_expansion_call(self, context: InterpreterContext, node: ast.ASTNode) -&gt; str:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.EXPANSION_CALL`.&#34;&#34;&#34;
        result = self.interpret_call(
            ChoiceCallHandlerContainer(
                context.runtime_expansions,
                self.expansion_handlers
            ),
            context,
            node,
            ast.ASTNodeType.EXPANSION_CALL
        )
        assert result is not None
        return result

    def interpret_sub_expansion(self, context: InterpreterContext, node: ast.ASTNode) -&gt; str:
        &#34;&#34;&#34;Utility. Interprets an expansion child node, which may be either `scrolls.ast.ASTNodeType.EXPANSION_VAR` or
        `scrolls.ast.ASTNodeType.EXPANSION_CALL`.
        &#34;&#34;&#34;
        context.current_node = node

        if node.type == ast.ASTNodeType.EXPANSION_VAR:
            return self.interpret_variable_reference(context, node)
        elif node.type == ast.ASTNodeType.EXPANSION_CALL:
            return self.interpret_expansion_call(context, node)
        else:
            raise InternalInterpreterError(
                context,
                f&#34;Bad expansion node type {node.type.name}&#34;
            )

    def interpret_expansion(self, context: InterpreterContext, node: ast.ASTNode) -&gt; t.Sequence[str]:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.EXPANSION`.&#34;&#34;&#34;
        context.current_node = node

        multi_node, expansion_node = node.children

        if multi_node.type == ast.ASTNodeType.EXPANSION_MULTI:
            multi = True
        elif multi_node.type == ast.ASTNodeType.EXPANSION_SINGLE:
            multi = False
        else:
            raise InternalInterpreterError(
                context,
                f&#34;Bad expansion multi_node type {multi_node.type.name}&#34;
            )

        str = self.interpret_sub_expansion(context, expansion_node)
        if multi:
            return [s.strip() for s in str.split()]
        else:
            return [str]

    def interpret_string_or_expansion(self, context: InterpreterContext, node: ast.ASTNode) -&gt; t.Sequence[str]:
        &#34;&#34;&#34;Utility. Interprets call names and arguments, which may be either `scrolls.ast.ASTNodeType.STRING` or
        `scrolls.ast.ASTNodeType.EXPANSION`
        &#34;&#34;&#34;

        context.current_node = node

        if node.type == ast.ASTNodeType.STRING:
            return [node.str_content()]
        elif node.type == ast.ASTNodeType.EXPANSION:
            return self.interpret_expansion(context, node)
        else:
            raise InternalInterpreterError(
                context, f&#34;Bad node type for string_or_expansion: {node.type.name}&#34;
            )

    def interpret_block(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.BLOCK`.&#34;&#34;&#34;
        context.current_node = node

        for sub_statement in context.current_node.children:
            self.interpret_statement(context, sub_statement)

    def interpret_statement(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
        &#34;&#34;&#34;Utility. Interprets Scrolls statements, which may be `scrolls.ast.ASTNodeType.CONTROL_CALL`,
        `scrolls.ast.ASTNodeType.COMMAND_CALL`, or `scrolls.ast.ASTNodeType.BLOCK`.

        More often than not, this is the function that control calls will use to run the statement passed to
        `InterpreterContext.control_node`. See `scrolls.builtins.BuiltinControlHandler` for examples.
        &#34;&#34;&#34;
        context.current_node = node

        type = context.current_node.type

        if type == ast.ASTNodeType.CONTROL_CALL:
            self.interpret_control(context, context.current_node)
        elif type == ast.ASTNodeType.COMMAND_CALL:
            self.interpret_command(context, context.current_node)
        elif type == ast.ASTNodeType.BLOCK:
            self.interpret_block(context, context.current_node)
        else:
            raise InternalInterpreterError(
                context, f&#34;Bad statement type {type.name}&#34;
            )

        context.statement_count += 1
        if self.over_statement_limit(context):
            raise InterpreterError(
                context,
                f&#34;Exceeded maximum statement limit of {self.statement_limit}.&#34;
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="scrolls.interpreter.CallbackCommandHandler"><code class="name">var <span class="ident">CallbackCommandHandler</span></code></dt>
<dd>
<div class="desc"><p>A basic command handler, shortcut for <code><a title="scrolls.interpreter.CallbackCallHandler" href="#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a>[None]</code>.</p></div>
</dd>
<dt id="scrolls.interpreter.CallbackControlHandler"><code class="name">var <span class="ident">CallbackControlHandler</span></code></dt>
<dd>
<div class="desc"><p>A basic control handler, shortcut for <code><a title="scrolls.interpreter.CallbackCallHandler" href="#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a>[None]</code>.</p></div>
</dd>
<dt id="scrolls.interpreter.CallbackExpansionHandler"><code class="name">var <span class="ident">CallbackExpansionHandler</span></code></dt>
<dd>
<div class="desc"><p>A basic expansion handler, shortcut for <code><a title="scrolls.interpreter.CallbackCallHandler" href="#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a>[str]</code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrolls.interpreter.ArgSourceMap"><code class="flex name class">
<span>class <span class="ident">ArgSourceMap</span></span>
<span>(</span><span>*args:Â Any, **kwargs:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>A utility class that maps argument numbers to some source.</p>
<p>The main purpose of this container is to map call arguments to the <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> they came from.
This class is typically used to accurately point to a node in the case of a call error.</p>
<p>Usage</p>
<pre><code class="language-py"># Note: SourceClass is just an example here.
sources: typing.Sequence[SourceClass] = get_some_sources()
source_map: ArgSourceMap[SourceClass] = ArgSourceMap()

args = []
for source in sources:
    args_from_source = source.get_args()
    source_map.add_args(args_from_source, source)

# Now, you can use an arg number to look up which SourceClass it came from.
arg_2_src = source_map[2]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArgSourceMap(dict[int, T], t.Generic[T]):
    &#34;&#34;&#34;A utility class that maps argument numbers to some source.

    The main purpose of this container is to map call arguments to the `scrolls.ast.ASTNode` they came from.
    This class is typically used to accurately point to a node in the case of a call error.

    Usage
    ```py
    # Note: SourceClass is just an example here.
    sources: typing.Sequence[SourceClass] = get_some_sources()
    source_map: ArgSourceMap[SourceClass] = ArgSourceMap()

    args = []
    for source in sources:
        args_from_source = source.get_args()
        source_map.add_args(args_from_source, source)

    # Now, you can use an arg number to look up which SourceClass it came from.
    arg_2_src = source_map[2]
    ```
    &#34;&#34;&#34;

    def __init__(self, *args: t.Any, **kwargs: t.Any):
        super().__init__(*args, **kwargs)

        self.count = 0

    def add_args(self, args: t.Sequence, source: T) -&gt; None:
        &#34;&#34;&#34;
        Add an `(args, source)` pair to this mapping. See usage example above.
        &#34;&#34;&#34;
        for i, _ in enumerate(args):
            self[i + self.count] = source

        self.count += len(args)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.ArgSourceMap.add_args"><code class="name flex">
<span>def <span class="ident">add_args</span></span>(<span>self, args:Â Sequence, source:Â ~T) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an <code>(args, source)</code> pair to this mapping. See usage example above.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_args(self, args: t.Sequence, source: T) -&gt; None:
    &#34;&#34;&#34;
    Add an `(args, source)` pair to this mapping. See usage example above.
    &#34;&#34;&#34;
    for i, _ in enumerate(args):
        self[i + self.count] = source

    self.count += len(args)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.BaseCallHandlerContainer"><code class="flex name class">
<span>class <span class="ident">BaseCallHandlerContainer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Generic container for <code><a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a></code> implementors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseCallHandlerContainer(t.Generic[T]):
    &#34;&#34;&#34;
    Generic container for `CallHandler` implementors.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        self._handlers: t.MutableMapping[str, CallHandler[T]] = {}

    def add(self, handler: CallHandler[T], name: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Add a call handler to this container.

        If `name` is not specified, then a unique name will be generated through `uuid.uuid4`.
        &#34;&#34;&#34;
        if not name:
            name = str(uuid.uuid4())

        logger.debug(f&#34;Register call handler type {handler.__class__.__qualname__} name {name}&#34;)
        self._handlers[name] = handler

    def add_all(self, handlers: t.Sequence[CallHandler[T]]) -&gt; None:
        &#34;&#34;&#34;Shortcut, adds all handlers in a list at once.&#34;&#34;&#34;
        for handler in handlers:
            self.add(handler)

    def find(self, handler: t.Union[CallHandler[T], str]) -&gt; tuple[str, CallHandler[T]]:
        &#34;&#34;&#34;Find a call handler.

        Args:
            handler: The handler to search for. It may be a CallHandler object, or the name of the handler to search for.

        Returns:
            A `tuple` of the form `(name, call_handler)`.
        &#34;&#34;&#34;
        if isinstance(handler, str):
            return handler, self._handlers[handler]
        else:
            for k, v in self._handlers.items():
                if v is handler:
                    return k, v

            raise KeyError(repr(handler))

    def remove(self, handler: t.Union[CallHandler[T], str]) -&gt; None:
        &#34;&#34;&#34;Remove a call handler from this container.&#34;&#34;&#34;
        k, v = self.find(handler)
        del self._handlers[k]

    def get(self, name: str) -&gt; CallHandler[T]:
        &#34;&#34;&#34;Gets a call handler by name.&#34;&#34;&#34;
        return self._handlers[name]

    def get_for_call(self, name: str) -&gt; CallHandler[T]:
        &#34;&#34;&#34;
        Get the handler for a given command name.
        &#34;&#34;&#34;
        logger.debug(f&#34;get_for_call: {name}&#34;)
        for handler in self._handlers.values():
            if name in handler:
                return handler

        raise KeyError(name)

    def __iter__(self) -&gt; t.Iterator[CallHandler[T]]:
        yield from self._handlers.values()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.BaseCallHandlerContainer.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, handler:Â <a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[~T], name:Â strÂ =Â '') â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a call handler to this container.</p>
<p>If <code>name</code> is not specified, then a unique name will be generated through <code>uuid.uuid4</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, handler: CallHandler[T], name: str = &#34;&#34;) -&gt; None:
    &#34;&#34;&#34;Add a call handler to this container.

    If `name` is not specified, then a unique name will be generated through `uuid.uuid4`.
    &#34;&#34;&#34;
    if not name:
        name = str(uuid.uuid4())

    logger.debug(f&#34;Register call handler type {handler.__class__.__qualname__} name {name}&#34;)
    self._handlers[name] = handler</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.BaseCallHandlerContainer.add_all"><code class="name flex">
<span>def <span class="ident">add_all</span></span>(<span>self, handlers:Â Sequence[<a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[~T]]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut, adds all handlers in a list at once.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_all(self, handlers: t.Sequence[CallHandler[T]]) -&gt; None:
    &#34;&#34;&#34;Shortcut, adds all handlers in a list at once.&#34;&#34;&#34;
    for handler in handlers:
        self.add(handler)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.BaseCallHandlerContainer.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, handler:Â Union[<a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[~T],Â str]) â€‘>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Find a call handler.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>handler</code></strong></dt>
<dd>The handler to search for. It may be a CallHandler object, or the name of the handler to search for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>tuple</code> of the form <code>(name, call_handler)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, handler: t.Union[CallHandler[T], str]) -&gt; tuple[str, CallHandler[T]]:
    &#34;&#34;&#34;Find a call handler.

    Args:
        handler: The handler to search for. It may be a CallHandler object, or the name of the handler to search for.

    Returns:
        A `tuple` of the form `(name, call_handler)`.
    &#34;&#34;&#34;
    if isinstance(handler, str):
        return handler, self._handlers[handler]
    else:
        for k, v in self._handlers.items():
            if v is handler:
                return k, v

        raise KeyError(repr(handler))</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.BaseCallHandlerContainer.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name:Â str) â€‘>Â <a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a call handler by name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, name: str) -&gt; CallHandler[T]:
    &#34;&#34;&#34;Gets a call handler by name.&#34;&#34;&#34;
    return self._handlers[name]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.BaseCallHandlerContainer.get_for_call"><code class="name flex">
<span>def <span class="ident">get_for_call</span></span>(<span>self, name:Â str) â€‘>Â <a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the handler for a given command name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_for_call(self, name: str) -&gt; CallHandler[T]:
    &#34;&#34;&#34;
    Get the handler for a given command name.
    &#34;&#34;&#34;
    logger.debug(f&#34;get_for_call: {name}&#34;)
    for handler in self._handlers.values():
        if name in handler:
            return handler

    raise KeyError(name)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.BaseCallHandlerContainer.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, handler:Â Union[<a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[~T],Â str]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a call handler from this container.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, handler: t.Union[CallHandler[T], str]) -&gt; None:
    &#34;&#34;&#34;Remove a call handler from this container.&#34;&#34;&#34;
    k, v = self.find(handler)
    del self._handlers[k]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.CallContext"><code class="flex name class">
<span>class <span class="ident">CallContext</span></span>
<span>(</span><span>call_name:Â str, args:Â Sequence[str], arg_nodes:Â <a title="scrolls.interpreter.ArgSourceMap" href="#scrolls.interpreter.ArgSourceMap">ArgSourceMap</a>, control_node:Â Optional[<a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>]Â =Â None, return_value:Â Optional[Any]Â =Â None, runtime_call:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>The context of a call. Contains all information necessary to run a call. Under normal circumstances,
you won't need to create instances of this yourself. Instead access instances through:</p>
<ul>
<li><code><a title="scrolls.interpreter.InterpreterContext.call_stack" href="#scrolls.interpreter.InterpreterContext.call_stack">InterpreterContext.call_stack</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.call_context" href="#scrolls.interpreter.InterpreterContext.call_context">InterpreterContext.call_context</a></code></li>
</ul>
<p><br/></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Control structures such as <code>!for</code>, <code>!while</code>, etc., are also considered calls, but they do not create
a new <code><a title="scrolls.interpreter.VarScope" href="#scrolls.interpreter.VarScope">VarScope</a></code>. So, call contexts and variable scopes are considered separately.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class CallContext:
    &#34;&#34;&#34;
    The context of a call. Contains all information necessary to run a call. Under normal circumstances,
    you won&#39;t need to create instances of this yourself. Instead access instances through:

    - `InterpreterContext.call_stack`
    - `InterpreterContext.call_context`

    &lt;br/&gt;

    .. NOTE::
        Control structures such as `!for`, `!while`, etc., are also considered calls, but they do not create
        a new `VarScope`. So, call contexts and variable scopes are considered separately.
    &#34;&#34;&#34;

    call_name: str
    &#34;&#34;&#34;The name of this call.&#34;&#34;&#34;

    args: t.Sequence[str]
    &#34;&#34;&#34;The arguments passed into this call.&#34;&#34;&#34;

    arg_nodes: ArgSourceMap[ast.ASTNode]
    &#34;&#34;&#34;A map of argument indices to the `scrolls.ast.ASTNode` they came from.&#34;&#34;&#34;

    control_node: t.Optional[ast.ASTNode] = None
    &#34;&#34;&#34;If this call is a control call, this will contain the call&#39;s `scrolls.ast.ASTNode` parameter.&#34;&#34;&#34;

    return_value: t.Optional[t.Any] = None
    &#34;&#34;&#34;The return value set by a runtime call.&#34;&#34;&#34;

    runtime_call: bool = False
    &#34;&#34;&#34;A runtime call is a call defined while the interpreter is running, such as through `!def`.&#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="scrolls.interpreter.CallContext.arg_nodes"><code class="name">var <span class="ident">arg_nodes</span> :Â <a title="scrolls.interpreter.ArgSourceMap" href="#scrolls.interpreter.ArgSourceMap">ArgSourceMap</a></code></dt>
<dd>
<div class="desc"><p>A map of argument indices to the <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> they came from.</p></div>
</dd>
<dt id="scrolls.interpreter.CallContext.args"><code class="name">var <span class="ident">args</span> :Â Sequence[str]</code></dt>
<dd>
<div class="desc"><p>The arguments passed into this call.</p></div>
</dd>
<dt id="scrolls.interpreter.CallContext.call_name"><code class="name">var <span class="ident">call_name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The name of this call.</p></div>
</dd>
<dt id="scrolls.interpreter.CallContext.control_node"><code class="name">var <span class="ident">control_node</span> :Â Optional[<a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>]</code></dt>
<dd>
<div class="desc"><p>If this call is a control call, this will contain the call's <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> parameter.</p></div>
</dd>
<dt id="scrolls.interpreter.CallContext.return_value"><code class="name">var <span class="ident">return_value</span> :Â Optional[Any]</code></dt>
<dd>
<div class="desc"><p>The return value set by a runtime call.</p></div>
</dd>
<dt id="scrolls.interpreter.CallContext.runtime_call"><code class="name">var <span class="ident">runtime_call</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>A runtime call is a call defined while the interpreter is running, such as through <code>!def</code>.</p></div>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.CallHandler"><code class="flex name class">
<span>class <span class="ident">CallHandler</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The minimum interface required to implement a call handler.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CallHandler(t.Protocol[T_co]):
    &#34;&#34;&#34;
    The minimum interface required to implement a call handler.
    &#34;&#34;&#34;
    def handle_call(self, context: AnyContextTV) -&gt; T_co:
        &#34;&#34;&#34;
        Handle a call. An `InterpreterContext` object will be passed in reflecting the state of the `Interpreter` for
        this call.
        &#34;&#34;&#34;
        ...

    def __contains__(self, command_name: str) -&gt; bool: ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.CallHandler.handle_call"><code class="name flex">
<span>def <span class="ident">handle_call</span></span>(<span>self, context:Â ~AnyContextTV) â€‘>Â +T_co</span>
</code></dt>
<dd>
<div class="desc"><p>Handle a call. An <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> object will be passed in reflecting the state of the <code><a title="scrolls.interpreter.Interpreter" href="#scrolls.interpreter.Interpreter">Interpreter</a></code> for
this call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_call(self, context: AnyContextTV) -&gt; T_co:
    &#34;&#34;&#34;
    Handle a call. An `InterpreterContext` object will be passed in reflecting the state of the `Interpreter` for
    this call.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.CallHandlerContainer"><code class="flex name class">
<span>class <span class="ident">CallHandlerContainer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A read-only <code><a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a></code> container.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CallHandlerContainer(t.Protocol[T_co]):
    &#34;&#34;&#34;
    A read-only `CallHandler` container.
    &#34;&#34;&#34;
    def get(self, name: str) -&gt; CallHandler[T_co]: ...
    &#34;&#34;&#34;Gets a call handler by name.&#34;&#34;&#34;

    def get_for_call(self, name: str) -&gt; CallHandler[T_co]: ...
    &#34;&#34;&#34;Gets a call handler for the named call.&#34;&#34;&#34;

    def __iter__(self) -&gt; t.Iterator[CallHandler[T_co]]: ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.MutableCallHandlerContainer" href="#scrolls.interpreter.MutableCallHandlerContainer">MutableCallHandlerContainer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.CallHandlerContainer.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name:Â str) â€‘>Â <a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[+T_co]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, name: str) -&gt; CallHandler[T_co]: ...</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.CallHandlerContainer.get_for_call"><code class="name flex">
<span>def <span class="ident">get_for_call</span></span>(<span>self, name:Â str) â€‘>Â <a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[+T_co]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_for_call(self, name: str) -&gt; CallHandler[T_co]: ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.CallbackCallHandler"><code class="flex name class">
<span>class <span class="ident">CallbackCallHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>A basic call handler that uses <code>typing.Callable</code> (<code><a title="scrolls.interpreter.ScrollCallback" href="#scrolls.interpreter.ScrollCallback">ScrollCallback</a></code>) to
implement a call handler.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CallbackCallHandler(t.Generic[T_co]):
    &#34;&#34;&#34;
    A basic call handler that uses `typing.Callable` (`ScrollCallback`) to
    implement a call handler.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        self.calls: t.MutableMapping[str, ScrollCallback[T_co]] = {}
        self.aliases: t.MutableMapping[str, str] = {}

    def add_call(self, name: str, command: ScrollCallback[T_co]) -&gt; None:
        &#34;&#34;&#34;
        Add a call.
        &#34;&#34;&#34;
        self.calls[name] = command

    def add_alias(self, alias: str, name: str) -&gt; None:
        &#34;&#34;&#34;Adds an alias for the named call. The call can then be executed by either it&#39;s real name or any of the
        defined aliases.&#34;&#34;&#34;
        self.aliases[alias] = name

    def remove_call(self, name: str) -&gt; None:
        &#34;&#34;&#34;Remove a call. Note that this also removes all of its associated aliases.&#34;&#34;&#34;
        del self.calls[name]

        # Delete all aliases associated with the name.
        for key, value in self.aliases.items():
            if value == name:
                del self.aliases[key]

    def get_callback(self, name: str) -&gt; ScrollCallback[T_co]:
        &#34;&#34;&#34;Get the callback for a call.&#34;&#34;&#34;
        if name in self.calls:
            return self.calls[name]

        return self.calls[self.aliases[name]]

    def handle_call(self, context: InterpreterContext) -&gt; T_co:
        return self.get_callback(context.call_name)(context)

    def __contains__(self, command_name: str) -&gt; bool:
        logger.debug(f&#34;{self.__class__.__qualname__}: __contains__({command_name})&#34;)
        return (
            command_name in self.calls or
            command_name in self.aliases
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrolls.builtins.ArithmeticExpansionHandler" href="builtins.html#scrolls.builtins.ArithmeticExpansionHandler">ArithmeticExpansionHandler</a></li>
<li><a title="scrolls.builtins.BuiltinCommandHandler" href="builtins.html#scrolls.builtins.BuiltinCommandHandler">BuiltinCommandHandler</a></li>
<li><a title="scrolls.builtins.BuiltinControlHandler" href="builtins.html#scrolls.builtins.BuiltinControlHandler">BuiltinControlHandler</a></li>
<li><a title="scrolls.builtins.ComparisonExpansionHandler" href="builtins.html#scrolls.builtins.ComparisonExpansionHandler">ComparisonExpansionHandler</a></li>
<li><a title="scrolls.builtins.FileCommandHandler" href="builtins.html#scrolls.builtins.FileCommandHandler">FileCommandHandler</a></li>
<li><a title="scrolls.builtins.FileExpansionHandler" href="builtins.html#scrolls.builtins.FileExpansionHandler">FileExpansionHandler</a></li>
<li><a title="scrolls.builtins.LogicExpansionHandler" href="builtins.html#scrolls.builtins.LogicExpansionHandler">LogicExpansionHandler</a></li>
<li><a title="scrolls.builtins.RandomExpansionHandler" href="builtins.html#scrolls.builtins.RandomExpansionHandler">RandomExpansionHandler</a></li>
<li><a title="scrolls.builtins.StdIoCommandHandler" href="builtins.html#scrolls.builtins.StdIoCommandHandler">StdIoCommandHandler</a></li>
<li><a title="scrolls.builtins.StringExpansionHandler" href="builtins.html#scrolls.builtins.StringExpansionHandler">StringExpansionHandler</a></li>
<li><a title="scrolls.ext.callbase.CallBaseCallHandler" href="ext/callbase.html#scrolls.ext.callbase.CallBaseCallHandler">CallBaseCallHandler</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.CallbackCallHandler.add_alias"><code class="name flex">
<span>def <span class="ident">add_alias</span></span>(<span>self, alias:Â str, name:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an alias for the named call. The call can then be executed by either it's real name or any of the
defined aliases.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_alias(self, alias: str, name: str) -&gt; None:
    &#34;&#34;&#34;Adds an alias for the named call. The call can then be executed by either it&#39;s real name or any of the
    defined aliases.&#34;&#34;&#34;
    self.aliases[alias] = name</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.CallbackCallHandler.add_call"><code class="name flex">
<span>def <span class="ident">add_call</span></span>(<span>self, name:Â str, command:Â <a title="scrolls.interpreter.ScrollCallback" href="#scrolls.interpreter.ScrollCallback">ScrollCallback</a>[+T_co]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_call(self, name: str, command: ScrollCallback[T_co]) -&gt; None:
    &#34;&#34;&#34;
    Add a call.
    &#34;&#34;&#34;
    self.calls[name] = command</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.CallbackCallHandler.get_callback"><code class="name flex">
<span>def <span class="ident">get_callback</span></span>(<span>self, name:Â str) â€‘>Â <a title="scrolls.interpreter.ScrollCallback" href="#scrolls.interpreter.ScrollCallback">ScrollCallback</a>[+T_co]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the callback for a call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_callback(self, name: str) -&gt; ScrollCallback[T_co]:
    &#34;&#34;&#34;Get the callback for a call.&#34;&#34;&#34;
    if name in self.calls:
        return self.calls[name]

    return self.calls[self.aliases[name]]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.CallbackCallHandler.handle_call"><code class="name flex">
<span>def <span class="ident">handle_call</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â +T_co</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_call(self, context: InterpreterContext) -&gt; T_co:
    return self.get_callback(context.call_name)(context)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.CallbackCallHandler.remove_call"><code class="name flex">
<span>def <span class="ident">remove_call</span></span>(<span>self, name:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a call. Note that this also removes all of its associated aliases.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_call(self, name: str) -&gt; None:
    &#34;&#34;&#34;Remove a call. Note that this also removes all of its associated aliases.&#34;&#34;&#34;
    del self.calls[name]

    # Delete all aliases associated with the name.
    for key, value in self.aliases.items():
        if value == name:
            del self.aliases[key]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.ChoiceCallHandlerContainer"><code class="flex name class">
<span>class <span class="ident">ChoiceCallHandlerContainer</span></span>
<span>(</span><span>*containers:Â <a title="scrolls.interpreter.CallHandlerContainer" href="#scrolls.interpreter.CallHandlerContainer">CallHandlerContainer</a>[~T])</span>
</code></dt>
<dd>
<div class="desc"><p>A call handler tries to handle a call with a sequence of call handler containers, one after another.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChoiceCallHandlerContainer(t.Generic[T]):
    &#34;&#34;&#34;
    A call handler tries to handle a call with a sequence of call handler containers, one after another.
    &#34;&#34;&#34;
    def __init__(self, *containers: CallHandlerContainer[T]):
        self.containers = containers

    def get(self, name: str) -&gt; CallHandler[T]:
        for container in self.containers:
            try:
                return container.get(name)
            except KeyError:
                pass

        raise KeyError(name)

    def get_for_call(self, name: str) -&gt; CallHandler[T]:
        logger.debug(f&#34;ChoiceCallHandlerContainer: get_for_call {name}&#34;)
        for container in self.containers:
            try:
                return container.get_for_call(name)
            except KeyError:
                logger.debug(f&#34;fail on {container.__class__.__qualname__}&#34;)
                pass

        raise KeyError(name)

    def __iter__(self) -&gt; t.Iterator[CallHandler[T]]:
        for container in self.containers:
            yield from container</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.ChoiceCallHandlerContainer.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name:Â str) â€‘>Â <a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[~T]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, name: str) -&gt; CallHandler[T]:
    for container in self.containers:
        try:
            return container.get(name)
        except KeyError:
            pass

    raise KeyError(name)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ChoiceCallHandlerContainer.get_for_call"><code class="name flex">
<span>def <span class="ident">get_for_call</span></span>(<span>self, name:Â str) â€‘>Â <a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[~T]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_for_call(self, name: str) -&gt; CallHandler[T]:
    logger.debug(f&#34;ChoiceCallHandlerContainer: get_for_call {name}&#34;)
    for container in self.containers:
        try:
            return container.get_for_call(name)
        except KeyError:
            logger.debug(f&#34;fail on {container.__class__.__qualname__}&#34;)
            pass

    raise KeyError(name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.Initializer"><code class="flex name class">
<span>class <span class="ident">Initializer</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for initializers. Initializers are used by the interpreter to set up <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> instances
immediately before a script is run. Initializers are considered to implement the <code><a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a></code> interface, even though
they don't actually handle calls.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Initializer(abc.ABC):
    &#34;&#34;&#34;
    The base class for initializers. Initializers are used by the interpreter to set up `InterpreterContext` instances
    immediately before a script is run. Initializers are considered to implement the `CallHandler` interface, even though
    they don&#39;t actually handle calls.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def handle_call(self, context: AnyContextTV) -&gt; None:
        &#34;&#34;&#34;
        Initialize an `InterpreterContext` or subclass.
        &#34;&#34;&#34;
        ...

    def __contains__(self, command_name: str) -&gt; bool:
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrolls.builtins.BuiltinInitializer" href="builtins.html#scrolls.builtins.BuiltinInitializer">BuiltinInitializer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.Initializer.handle_call"><code class="name flex">
<span>def <span class="ident">handle_call</span></span>(<span>self, context:Â ~AnyContextTV) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize an <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> or subclass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def handle_call(self, context: AnyContextTV) -&gt; None:
    &#34;&#34;&#34;
    Initialize an `InterpreterContext` or subclass.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.InternalInterpreterError"><code class="flex name class">
<span>class <span class="ident">InternalInterpreterError</span></span>
<span>(</span><span>context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, message:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised on critical interpreter errors that are usually the result of bugs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InternalInterpreterError(InterpreterError):
    &#34;&#34;&#34;
    Raised on critical interpreter errors that are usually the result of bugs.
    &#34;&#34;&#34;
    def __init__(self, context: InterpreterContext, message: str):
        super().__init__(
            context,
            &#34;INTERNAL ERROR. If you see this, please report it!\n&#34; + message
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.InterpreterError" href="#scrolls.interpreter.InterpreterError">InterpreterError</a></li>
<li><a title="scrolls.errors.PositionalError" href="errors.html#scrolls.errors.PositionalError">PositionalError</a></li>
<li><a title="scrolls.errors.ScrollError" href="errors.html#scrolls.errors.ScrollError">ScrollError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.interpreter.InterpreterError" href="#scrolls.interpreter.InterpreterError">InterpreterError</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.interpreter.InterpreterError.line" href="errors.html#scrolls.errors.PositionalError.line">line</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterError.message" href="errors.html#scrolls.errors.PositionalError.message">message</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterError.pos" href="errors.html#scrolls.errors.PositionalError.pos">pos</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterError.string" href="errors.html#scrolls.errors.PositionalError.string">string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.interpreter.Interpreter"><code class="flex name class">
<span>class <span class="ident">Interpreter</span></span>
<span>(</span><span>context_cls:Â Type[<a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>]Â =Â scrolls.interpreter.InterpreterContext, statement_limit:Â intÂ =Â 0, call_depth_limit:Â intÂ =Â 200)</span>
</code></dt>
<dd>
<div class="desc"><p>The interpreter implementation for Scrolls. Configure through the <code>*_handlers</code> properties. Or, for a more organized
configuration, see <code><a title="scrolls.containers.DecoratorInterpreterConfig" href="containers.html#scrolls.containers.DecoratorInterpreterConfig">DecoratorInterpreterConfig</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context_cls</code></strong></dt>
<dd>The <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> class to use when automatically instantiating new context objects.
Must be <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> or a subclass of it.</dd>
<dt><strong><code>statement_limit</code></strong></dt>
<dd>The number of statements allowed while executing a script. This is counted in the
<code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> object for a given run. If the number of executed statements exceeds this, an
<code><a title="scrolls.interpreter.InterpreterError" href="#scrolls.interpreter.InterpreterError">InterpreterError</a></code> will be raised. If set to zero, then there is no statement limit.</dd>
<dt><strong><code>call_depth_limit</code></strong></dt>
<dd>The number of levels deep the call stack is allowed to go. This is used to prevent
denial of service through infinite recursion. If zero, then call depth is unlimited.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interpreter:
    &#34;&#34;&#34;
    The interpreter implementation for Scrolls. Configure through the `*_handlers` properties. Or, for a more organized
    configuration, see `scrolls.containers.DecoratorInterpreterConfig`.

    Args:
        context_cls: The `InterpreterContext` class to use when automatically instantiating new context objects.
            Must be `InterpreterContext` or a subclass of it.

        statement_limit: The number of statements allowed while executing a script. This is counted in the
            `InterpreterContext` object for a given run. If the number of executed statements exceeds this, an
            `InterpreterError` will be raised. If set to zero, then there is no statement limit.

        call_depth_limit: The number of levels deep the call stack is allowed to go. This is used to prevent
            denial of service through infinite recursion. If zero, then call depth is unlimited.
    &#34;&#34;&#34;
    def __init__(
        self,
        context_cls: t.Type[InterpreterContext] = InterpreterContext,
        statement_limit: int = 0,
        call_depth_limit: int = 200
    ):
        self._command_handlers: BaseCallHandlerContainer[None] = BaseCallHandlerContainer()
        self._control_handlers: BaseCallHandlerContainer[None] = BaseCallHandlerContainer()
        self._expansion_handlers: BaseCallHandlerContainer[str] = BaseCallHandlerContainer()
        self._initializers: BaseCallHandlerContainer[None] = BaseCallHandlerContainer()

        self.context_cls = context_cls
        &#34;&#34;&#34;
        The `InterpreterContext` class to use when automatically instantiating new context objects.
        Must be `InterpreterContext` or a subclass of it.
        &#34;&#34;&#34;

        self.statement_limit = statement_limit
        self.call_depth_limit = call_depth_limit

    def over_statement_limit(self, context: InterpreterContext) -&gt; bool:
        &#34;&#34;&#34;
        Utility function. Checks whether the passed context has exceeded the statement limit set for this interpreter.
        &#34;&#34;&#34;
        if self.statement_limit == 0:
            return False
        else:
            return context.statement_count &gt; self.statement_limit

    def over_call_depth_limit(self, context: InterpreterContext) -&gt; bool:
        &#34;&#34;&#34;
        Utility function. Checks whether the passed context has exceeded the call stack depth limit set for this
        interpreter.
        &#34;&#34;&#34;
        if self.call_depth_limit == 0:
            return False
        else:
            return len(context.call_stack) &gt; self.call_depth_limit

    @property
    def command_handlers(self) -&gt; BaseCallHandlerContainer[None]:
        &#34;&#34;&#34;The container of command handlers for this interpreter.&#34;&#34;&#34;
        return self._command_handlers

    @property
    def control_handlers(self) -&gt; BaseCallHandlerContainer[None]:
        &#34;&#34;&#34;The container of control handlers for this interpreter.&#34;&#34;&#34;
        return self._control_handlers

    @property
    def expansion_handlers(self) -&gt; BaseCallHandlerContainer[str]:
        &#34;&#34;&#34;The container of expansion handlers for this interpreter.&#34;&#34;&#34;
        return self._expansion_handlers

    @property
    def initializers(self) -&gt; BaseCallHandlerContainer[None]:
        &#34;&#34;&#34;The container of `Initializer` instances for this interpreter.&#34;&#34;&#34;
        return self._initializers

    def apply_initializers(self, context: InterpreterContext) -&gt; None:
        &#34;&#34;&#34;Apply this interpreter&#39;s context initializers to the given context object.&#34;&#34;&#34;
        for init in self.initializers:
            init.handle_call(context)

    def run(
        self,
        script: str,
        context: t.Optional[InterpreterContext] = None,
        consume_rest_triggers: t.Mapping[str, int] = types.MappingProxyType({})
    ) -&gt; InterpreterContext:
        &#34;&#34;&#34;Run a Scrolls script.

        Args:
            script: The script to run.
            context: Optional. If no context is specified, then an instance of `Interpreter.context_cls` is created
                automatically. Otherwise, the passed context object will be used.
            consume_rest_triggers: A mapping of triggers for the CONSUME_REST parsing feature.

        Returns:
            The context used to execute the script. If `context` was not None, `context` will be returned. Otherwise,
            it will be the automatically created `InterpreterContext` instance.
        &#34;&#34;&#34;
        tokenizer = ast.Tokenizer(script, consume_rest_triggers)
        tree = ast.parse_scroll(tokenizer)
        return self.interpret_ast(tree, context)

    def init_context(self, context: InterpreterContext) -&gt; None:
        &#34;&#34;&#34;
        Initialize a context for this interpreter.
        &#34;&#34;&#34;
        context.interpreter = self
        self.apply_initializers(context)

    def run_statement(
        self,
        statement: t.Union[str, ast.Tokenizer],
        context: t.Optional[InterpreterContext] = None,
    ) -&gt; InterpreterContext:
        &#34;&#34;&#34;Run a single Scrolls statement.

        Args:
            statement: The statement to run. Must be either a string, or a tokenizer populated with a valid Scrolls
                statement.
            context: Optional. If no context is specified, then an instance of `Interpreter.context_cls` is created
                automatically. Otherwise, the passed context object will be used.

        Returns:
            The context used to execute the script. If `context` was not None, `context` will be returned. Otherwise,
            it will be the automatically created `InterpreterContext` instance.
        &#34;&#34;&#34;
        # Set up parsing and parse statement
        if isinstance(statement, str):
            tokenizer = ast.Tokenizer(statement)
        else:
            tokenizer = statement

        statement_node = ast.parse_statement(tokenizer)

        # Interpret statement
        if context is None:
            context = self.context_cls(statement_node)

        self.init_context(context)
        self.interpret_statement(context, statement_node)

        return context

    def repl(
        self,
        on_error: t.Optional[t.Callable[[errors.ScrollError], None]] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Drop into a REPL (read eval print loop).

        Args:
            on_error: A function to call when an error occurs. If `None`,
                      errors will stop the REPL.
        &#34;&#34;&#34;
        stream = ast.REPLStream()
        tokenizer = ast.Tokenizer(stream)
        context = self.context_cls()
        self.init_context(context)

        while True:
            try:
                statement_node = ast.parse_statement(tokenizer)
                stream.set_statement()

                self.interpret_statement(context, statement_node)
            except InterpreterStop:
                return
            except InterpreterReturn:
                e = InterpreterError(
                    context,
                    f&#34;returning only allowed in functions&#34;
                )
                if on_error is not None:
                    on_error(e)
                    stream.set_statement()
                    stream.next_line()
                else:
                    raise e
            except KeyboardInterrupt:
                print(&#34;Keyboard interrupt.&#34;)
                return
            except errors.ScrollError as e:
                if on_error is not None:
                    on_error(e)
                    stream.set_statement()
                    stream.next_line()
                else:
                    raise


    @staticmethod
    def test_parse(
        script: str,
        consume_rest_triggers: t.Mapping[str, int] = types.MappingProxyType({})
    ) -&gt; str:
        &#34;&#34;&#34;
        Returns a JSON-formatted string showing the full `scrolls.ast.ASTNode` structure of a parsed script, including
        `consume_rest_triggers`.

        .. WARNING::
            For debugging and demonstration purposes only.
        &#34;&#34;&#34;
        tokenizer = ast.Tokenizer(script, consume_rest_triggers)
        tree = ast.parse_scroll(tokenizer)
        return tree.prettify()

    def interpret_ast(
        self,
        tree: ast.AST,
        context: t.Optional[InterpreterContext] = None
    ) -&gt; InterpreterContext:
        &#34;&#34;&#34;
        Interprets a full AST structure.

        Args:
            tree: The AST to interpret.
            context: Optional. If no context is specified, then an instance of `Interpreter.context_cls` is created
                automatically. Otherwise, the passed context object will be used.

        Returns:
            The context used to execute the script. If `context` was not None, `context` will be returned. Otherwise,
            it will be the automatically created `InterpreterContext` instance.
        &#34;&#34;&#34;
        if context is None:
            context = self.context_cls(tree.root)

        context.interpreter = self
        self.apply_initializers(context)

        try:
            self.interpret_root(context, tree.root)
        except InterpreterStop:
            logger.debug(&#34;Interpreter stop raised.&#34;)
            pass
        except InterpreterReturn:
            raise InterpreterError(
                context,
                f&#34;returning only allowed in functions&#34;
            )

        return context

    def interpret_root(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.ROOT`.&#34;&#34;&#34;
        self.interpret_block(context, node)

    def interpret_call(
        self,
        call_handler_container: CallHandlerContainer[T_co],
        context: InterpreterContext,
        node: ast.ASTNode,
        expected_node_type: ast.ASTNodeType,
        pass_control_node: bool = False
    ) -&gt; T_co:
        &#34;&#34;&#34;
        Generic function for interpreting call nodes.

        Args:
            call_handler_container: The call handler container to check for call handlers.
            context: The interpreter context.
            node: The AST node to interpret.
            expected_node_type: The type of AST node to be expected.
            pass_control_node: Whether to pass `node.children[2]` into the control parameter of a call. Currently,
                this only applies to control calls. See `InterpreterContext.control_node`.

        Returns:
            The result of the call, if any.

        Related:
            `Interpreter.interpret_command` `Interpreter.interpret_control` `Interpreter.interpret_expansion_call`
        &#34;&#34;&#34;

        if node.type != expected_node_type:
            raise InternalInterpreterError(
                context,
                f&#34;interpret_call: name: Expected {expected_node_type.name}, got {node.type.name}&#34;
            )

        name_node = node.children[0]
        args_node = node.children[1]
        arg_node_map: ArgSourceMap[ast.ASTNode] = ArgSourceMap()

        raw_call = list(self.interpret_string_or_expansion(context, name_node))

        if not raw_call:
            raise InterpreterError(
                context,
                f&#34;Call name must not expand to empty string.&#34;
            )

        arg_node_map.add_args(raw_call[1:], name_node)

        for arg_node in args_node.children:
            new_args = self.interpret_string_or_expansion(context, arg_node)
            arg_node_map.add_args(new_args, arg_node)

            raw_call += new_args

        logger.debug(f&#34;interpret_call: raw {raw_call}&#34;)
        call_name = raw_call[0]
        call_args: t.Sequence[str] = raw_call[1:]

        context.current_node = node
        control_node: t.Optional[ast.ASTNode]

        if pass_control_node:
            control_node = node.children[2]
        else:
            control_node = None

        if context.in_call():
            context.push_call()
            if self.over_call_depth_limit(context):
                raise InterpreterError(
                    context,
                    f&#34;Maximum call stack depth ({self.call_depth_limit}) exceeded.&#34;
                )

        context.set_call(call_name, call_args, arg_node_map, control_node=control_node)

        try:
            handler = call_handler_container.get_for_call(call_name)
        except KeyError:
            context.current_node = name_node
            raise MissingCallError(context, expected_node_type.name, call_name)

        try:
            result: T_co = handler.handle_call(context)
        except InterpreterReturn:
            # Ensure call stack is properly changed even on returns
            if context.call_stack:
                context.pop_call()
            else:
                context.reset_call()

            raise

        if context.call_stack:
            context.pop_call()
        else:
            context.reset_call()

        return result

    def interpret_control(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.CONTROL_CALL`.&#34;&#34;&#34;
        self.interpret_call(
            self.control_handlers,
            context,
            node,
            ast.ASTNodeType.CONTROL_CALL,
            pass_control_node=True
        )

    def interpret_command(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.COMMAND_CALL`.&#34;&#34;&#34;
        self.interpret_call(
            ChoiceCallHandlerContainer(
                context.runtime_commands,
                self.command_handlers
            ),
            context,
            node,
            ast.ASTNodeType.COMMAND_CALL
        )

    def interpret_variable_reference(self, context: InterpreterContext, node: ast.ASTNode) -&gt; str:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.EXPANSION_VAR`.&#34;&#34;&#34;
        context.current_node = node

        var_name = &#34; &#34;.join(self.interpret_string_or_expansion(context, node.children[0]))
        try:
            return context.get_var(var_name)
        except KeyError:
            raise InterpreterError(
                context, f&#34;No such variable {var_name}.&#34;
            )

    def interpret_expansion_call(self, context: InterpreterContext, node: ast.ASTNode) -&gt; str:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.EXPANSION_CALL`.&#34;&#34;&#34;
        result = self.interpret_call(
            ChoiceCallHandlerContainer(
                context.runtime_expansions,
                self.expansion_handlers
            ),
            context,
            node,
            ast.ASTNodeType.EXPANSION_CALL
        )
        assert result is not None
        return result

    def interpret_sub_expansion(self, context: InterpreterContext, node: ast.ASTNode) -&gt; str:
        &#34;&#34;&#34;Utility. Interprets an expansion child node, which may be either `scrolls.ast.ASTNodeType.EXPANSION_VAR` or
        `scrolls.ast.ASTNodeType.EXPANSION_CALL`.
        &#34;&#34;&#34;
        context.current_node = node

        if node.type == ast.ASTNodeType.EXPANSION_VAR:
            return self.interpret_variable_reference(context, node)
        elif node.type == ast.ASTNodeType.EXPANSION_CALL:
            return self.interpret_expansion_call(context, node)
        else:
            raise InternalInterpreterError(
                context,
                f&#34;Bad expansion node type {node.type.name}&#34;
            )

    def interpret_expansion(self, context: InterpreterContext, node: ast.ASTNode) -&gt; t.Sequence[str]:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.EXPANSION`.&#34;&#34;&#34;
        context.current_node = node

        multi_node, expansion_node = node.children

        if multi_node.type == ast.ASTNodeType.EXPANSION_MULTI:
            multi = True
        elif multi_node.type == ast.ASTNodeType.EXPANSION_SINGLE:
            multi = False
        else:
            raise InternalInterpreterError(
                context,
                f&#34;Bad expansion multi_node type {multi_node.type.name}&#34;
            )

        str = self.interpret_sub_expansion(context, expansion_node)
        if multi:
            return [s.strip() for s in str.split()]
        else:
            return [str]

    def interpret_string_or_expansion(self, context: InterpreterContext, node: ast.ASTNode) -&gt; t.Sequence[str]:
        &#34;&#34;&#34;Utility. Interprets call names and arguments, which may be either `scrolls.ast.ASTNodeType.STRING` or
        `scrolls.ast.ASTNodeType.EXPANSION`
        &#34;&#34;&#34;

        context.current_node = node

        if node.type == ast.ASTNodeType.STRING:
            return [node.str_content()]
        elif node.type == ast.ASTNodeType.EXPANSION:
            return self.interpret_expansion(context, node)
        else:
            raise InternalInterpreterError(
                context, f&#34;Bad node type for string_or_expansion: {node.type.name}&#34;
            )

    def interpret_block(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
        &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.BLOCK`.&#34;&#34;&#34;
        context.current_node = node

        for sub_statement in context.current_node.children:
            self.interpret_statement(context, sub_statement)

    def interpret_statement(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
        &#34;&#34;&#34;Utility. Interprets Scrolls statements, which may be `scrolls.ast.ASTNodeType.CONTROL_CALL`,
        `scrolls.ast.ASTNodeType.COMMAND_CALL`, or `scrolls.ast.ASTNodeType.BLOCK`.

        More often than not, this is the function that control calls will use to run the statement passed to
        `InterpreterContext.control_node`. See `scrolls.builtins.BuiltinControlHandler` for examples.
        &#34;&#34;&#34;
        context.current_node = node

        type = context.current_node.type

        if type == ast.ASTNodeType.CONTROL_CALL:
            self.interpret_control(context, context.current_node)
        elif type == ast.ASTNodeType.COMMAND_CALL:
            self.interpret_command(context, context.current_node)
        elif type == ast.ASTNodeType.BLOCK:
            self.interpret_block(context, context.current_node)
        else:
            raise InternalInterpreterError(
                context, f&#34;Bad statement type {type.name}&#34;
            )

        context.statement_count += 1
        if self.over_statement_limit(context):
            raise InterpreterError(
                context,
                f&#34;Exceeded maximum statement limit of {self.statement_limit}.&#34;
            )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="scrolls.interpreter.Interpreter.test_parse"><code class="name flex">
<span>def <span class="ident">test_parse</span></span>(<span>script:Â str, consume_rest_triggers:Â Mapping[str,Â int]Â =Â mappingproxy({})) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a JSON-formatted string showing the full <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> structure of a parsed script, including
<code>consume_rest_triggers</code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For debugging and demonstration purposes only.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def test_parse(
    script: str,
    consume_rest_triggers: t.Mapping[str, int] = types.MappingProxyType({})
) -&gt; str:
    &#34;&#34;&#34;
    Returns a JSON-formatted string showing the full `scrolls.ast.ASTNode` structure of a parsed script, including
    `consume_rest_triggers`.

    .. WARNING::
        For debugging and demonstration purposes only.
    &#34;&#34;&#34;
    tokenizer = ast.Tokenizer(script, consume_rest_triggers)
    tree = ast.parse_scroll(tokenizer)
    return tree.prettify()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="scrolls.interpreter.Interpreter.command_handlers"><code class="name">var <span class="ident">command_handlers</span> :Â <a title="scrolls.interpreter.BaseCallHandlerContainer" href="#scrolls.interpreter.BaseCallHandlerContainer">BaseCallHandlerContainer</a>[None]</code></dt>
<dd>
<div class="desc"><p>The container of command handlers for this interpreter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def command_handlers(self) -&gt; BaseCallHandlerContainer[None]:
    &#34;&#34;&#34;The container of command handlers for this interpreter.&#34;&#34;&#34;
    return self._command_handlers</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.context_cls"><code class="name">var <span class="ident">context_cls</span></code></dt>
<dd>
<div class="desc"><p>The <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> class to use when automatically instantiating new context objects.
Must be <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> or a subclass of it.</p></div>
</dd>
<dt id="scrolls.interpreter.Interpreter.control_handlers"><code class="name">var <span class="ident">control_handlers</span> :Â <a title="scrolls.interpreter.BaseCallHandlerContainer" href="#scrolls.interpreter.BaseCallHandlerContainer">BaseCallHandlerContainer</a>[None]</code></dt>
<dd>
<div class="desc"><p>The container of control handlers for this interpreter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def control_handlers(self) -&gt; BaseCallHandlerContainer[None]:
    &#34;&#34;&#34;The container of control handlers for this interpreter.&#34;&#34;&#34;
    return self._control_handlers</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.expansion_handlers"><code class="name">var <span class="ident">expansion_handlers</span> :Â <a title="scrolls.interpreter.BaseCallHandlerContainer" href="#scrolls.interpreter.BaseCallHandlerContainer">BaseCallHandlerContainer</a>[str]</code></dt>
<dd>
<div class="desc"><p>The container of expansion handlers for this interpreter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def expansion_handlers(self) -&gt; BaseCallHandlerContainer[str]:
    &#34;&#34;&#34;The container of expansion handlers for this interpreter.&#34;&#34;&#34;
    return self._expansion_handlers</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.initializers"><code class="name">var <span class="ident">initializers</span> :Â <a title="scrolls.interpreter.BaseCallHandlerContainer" href="#scrolls.interpreter.BaseCallHandlerContainer">BaseCallHandlerContainer</a>[None]</code></dt>
<dd>
<div class="desc"><p>The container of <code><a title="scrolls.interpreter.Initializer" href="#scrolls.interpreter.Initializer">Initializer</a></code> instances for this interpreter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def initializers(self) -&gt; BaseCallHandlerContainer[None]:
    &#34;&#34;&#34;The container of `Initializer` instances for this interpreter.&#34;&#34;&#34;
    return self._initializers</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.Interpreter.apply_initializers"><code class="name flex">
<span>def <span class="ident">apply_initializers</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply this interpreter's context initializers to the given context object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_initializers(self, context: InterpreterContext) -&gt; None:
    &#34;&#34;&#34;Apply this interpreter&#39;s context initializers to the given context object.&#34;&#34;&#34;
    for init in self.initializers:
        init.handle_call(context)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.init_context"><code class="name flex">
<span>def <span class="ident">init_context</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a context for this interpreter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_context(self, context: InterpreterContext) -&gt; None:
    &#34;&#34;&#34;
    Initialize a context for this interpreter.
    &#34;&#34;&#34;
    context.interpreter = self
    self.apply_initializers(context)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_ast"><code class="name flex">
<span>def <span class="ident">interpret_ast</span></span>(<span>self, tree:Â <a title="scrolls.ast.AST" href="ast.html#scrolls.ast.AST">AST</a>, context:Â Optional[<a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>]Â =Â None) â€‘>Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Interprets a full AST structure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tree</code></strong></dt>
<dd>The AST to interpret.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Optional. If no context is specified, then an instance of <code><a title="scrolls.interpreter.Interpreter.context_cls" href="#scrolls.interpreter.Interpreter.context_cls">Interpreter.context_cls</a></code> is created
automatically. Otherwise, the passed context object will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The context used to execute the script. If <code>context</code> was not None, <code>context</code> will be returned. Otherwise,
it will be the automatically created <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_ast(
    self,
    tree: ast.AST,
    context: t.Optional[InterpreterContext] = None
) -&gt; InterpreterContext:
    &#34;&#34;&#34;
    Interprets a full AST structure.

    Args:
        tree: The AST to interpret.
        context: Optional. If no context is specified, then an instance of `Interpreter.context_cls` is created
            automatically. Otherwise, the passed context object will be used.

    Returns:
        The context used to execute the script. If `context` was not None, `context` will be returned. Otherwise,
        it will be the automatically created `InterpreterContext` instance.
    &#34;&#34;&#34;
    if context is None:
        context = self.context_cls(tree.root)

    context.interpreter = self
    self.apply_initializers(context)

    try:
        self.interpret_root(context, tree.root)
    except InterpreterStop:
        logger.debug(&#34;Interpreter stop raised.&#34;)
        pass
    except InterpreterReturn:
        raise InterpreterError(
            context,
            f&#34;returning only allowed in functions&#34;
        )

    return context</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_block"><code class="name flex">
<span>def <span class="ident">interpret_block</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Interpret an <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> of type <code><a title="scrolls.ast.ASTNodeType.BLOCK" href="ast.html#scrolls.ast.ASTNodeType.BLOCK">ASTNodeType.BLOCK</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_block(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
    &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.BLOCK`.&#34;&#34;&#34;
    context.current_node = node

    for sub_statement in context.current_node.children:
        self.interpret_statement(context, sub_statement)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_call"><code class="name flex">
<span>def <span class="ident">interpret_call</span></span>(<span>self, call_handler_container:Â <a title="scrolls.interpreter.CallHandlerContainer" href="#scrolls.interpreter.CallHandlerContainer">CallHandlerContainer</a>[+T_co], context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>, expected_node_type:Â <a title="scrolls.ast.ASTNodeType" href="ast.html#scrolls.ast.ASTNodeType">ASTNodeType</a>, pass_control_node:Â boolÂ =Â False) â€‘>Â +T_co</span>
</code></dt>
<dd>
<div class="desc"><p>Generic function for interpreting call nodes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>call_handler_container</code></strong></dt>
<dd>The call handler container to check for call handlers.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>The interpreter context.</dd>
<dt><strong><code>node</code></strong></dt>
<dd>The AST node to interpret.</dd>
<dt><strong><code>expected_node_type</code></strong></dt>
<dd>The type of AST node to be expected.</dd>
<dt><strong><code>pass_control_node</code></strong></dt>
<dd>Whether to pass <code>node.children[2]</code> into the control parameter of a call. Currently,
this only applies to control calls. See <code><a title="scrolls.interpreter.InterpreterContext.control_node" href="#scrolls.interpreter.InterpreterContext.control_node">InterpreterContext.control_node</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The result of the call, if any.</p>
<h2 id="related">Related</h2>
<p><code><a title="scrolls.interpreter.Interpreter.interpret_command" href="#scrolls.interpreter.Interpreter.interpret_command">Interpreter.interpret_command()</a></code> <code><a title="scrolls.interpreter.Interpreter.interpret_control" href="#scrolls.interpreter.Interpreter.interpret_control">Interpreter.interpret_control()</a></code> <code><a title="scrolls.interpreter.Interpreter.interpret_expansion_call" href="#scrolls.interpreter.Interpreter.interpret_expansion_call">Interpreter.interpret_expansion_call()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_call(
    self,
    call_handler_container: CallHandlerContainer[T_co],
    context: InterpreterContext,
    node: ast.ASTNode,
    expected_node_type: ast.ASTNodeType,
    pass_control_node: bool = False
) -&gt; T_co:
    &#34;&#34;&#34;
    Generic function for interpreting call nodes.

    Args:
        call_handler_container: The call handler container to check for call handlers.
        context: The interpreter context.
        node: The AST node to interpret.
        expected_node_type: The type of AST node to be expected.
        pass_control_node: Whether to pass `node.children[2]` into the control parameter of a call. Currently,
            this only applies to control calls. See `InterpreterContext.control_node`.

    Returns:
        The result of the call, if any.

    Related:
        `Interpreter.interpret_command` `Interpreter.interpret_control` `Interpreter.interpret_expansion_call`
    &#34;&#34;&#34;

    if node.type != expected_node_type:
        raise InternalInterpreterError(
            context,
            f&#34;interpret_call: name: Expected {expected_node_type.name}, got {node.type.name}&#34;
        )

    name_node = node.children[0]
    args_node = node.children[1]
    arg_node_map: ArgSourceMap[ast.ASTNode] = ArgSourceMap()

    raw_call = list(self.interpret_string_or_expansion(context, name_node))

    if not raw_call:
        raise InterpreterError(
            context,
            f&#34;Call name must not expand to empty string.&#34;
        )

    arg_node_map.add_args(raw_call[1:], name_node)

    for arg_node in args_node.children:
        new_args = self.interpret_string_or_expansion(context, arg_node)
        arg_node_map.add_args(new_args, arg_node)

        raw_call += new_args

    logger.debug(f&#34;interpret_call: raw {raw_call}&#34;)
    call_name = raw_call[0]
    call_args: t.Sequence[str] = raw_call[1:]

    context.current_node = node
    control_node: t.Optional[ast.ASTNode]

    if pass_control_node:
        control_node = node.children[2]
    else:
        control_node = None

    if context.in_call():
        context.push_call()
        if self.over_call_depth_limit(context):
            raise InterpreterError(
                context,
                f&#34;Maximum call stack depth ({self.call_depth_limit}) exceeded.&#34;
            )

    context.set_call(call_name, call_args, arg_node_map, control_node=control_node)

    try:
        handler = call_handler_container.get_for_call(call_name)
    except KeyError:
        context.current_node = name_node
        raise MissingCallError(context, expected_node_type.name, call_name)

    try:
        result: T_co = handler.handle_call(context)
    except InterpreterReturn:
        # Ensure call stack is properly changed even on returns
        if context.call_stack:
            context.pop_call()
        else:
            context.reset_call()

        raise

    if context.call_stack:
        context.pop_call()
    else:
        context.reset_call()

    return result</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_command"><code class="name flex">
<span>def <span class="ident">interpret_command</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Interpret an <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> of type <code><a title="scrolls.ast.ASTNodeType.COMMAND_CALL" href="ast.html#scrolls.ast.ASTNodeType.COMMAND_CALL">ASTNodeType.COMMAND_CALL</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_command(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
    &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.COMMAND_CALL`.&#34;&#34;&#34;
    self.interpret_call(
        ChoiceCallHandlerContainer(
            context.runtime_commands,
            self.command_handlers
        ),
        context,
        node,
        ast.ASTNodeType.COMMAND_CALL
    )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_control"><code class="name flex">
<span>def <span class="ident">interpret_control</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Interpret an <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> of type <code><a title="scrolls.ast.ASTNodeType.CONTROL_CALL" href="ast.html#scrolls.ast.ASTNodeType.CONTROL_CALL">ASTNodeType.CONTROL_CALL</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_control(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
    &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.CONTROL_CALL`.&#34;&#34;&#34;
    self.interpret_call(
        self.control_handlers,
        context,
        node,
        ast.ASTNodeType.CONTROL_CALL,
        pass_control_node=True
    )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_expansion"><code class="name flex">
<span>def <span class="ident">interpret_expansion</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>) â€‘>Â Sequence[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Interpret an <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> of type <code><a title="scrolls.ast.ASTNodeType.EXPANSION" href="ast.html#scrolls.ast.ASTNodeType.EXPANSION">ASTNodeType.EXPANSION</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_expansion(self, context: InterpreterContext, node: ast.ASTNode) -&gt; t.Sequence[str]:
    &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.EXPANSION`.&#34;&#34;&#34;
    context.current_node = node

    multi_node, expansion_node = node.children

    if multi_node.type == ast.ASTNodeType.EXPANSION_MULTI:
        multi = True
    elif multi_node.type == ast.ASTNodeType.EXPANSION_SINGLE:
        multi = False
    else:
        raise InternalInterpreterError(
            context,
            f&#34;Bad expansion multi_node type {multi_node.type.name}&#34;
        )

    str = self.interpret_sub_expansion(context, expansion_node)
    if multi:
        return [s.strip() for s in str.split()]
    else:
        return [str]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_expansion_call"><code class="name flex">
<span>def <span class="ident">interpret_expansion_call</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Interpret an <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> of type <code><a title="scrolls.ast.ASTNodeType.EXPANSION_CALL" href="ast.html#scrolls.ast.ASTNodeType.EXPANSION_CALL">ASTNodeType.EXPANSION_CALL</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_expansion_call(self, context: InterpreterContext, node: ast.ASTNode) -&gt; str:
    &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.EXPANSION_CALL`.&#34;&#34;&#34;
    result = self.interpret_call(
        ChoiceCallHandlerContainer(
            context.runtime_expansions,
            self.expansion_handlers
        ),
        context,
        node,
        ast.ASTNodeType.EXPANSION_CALL
    )
    assert result is not None
    return result</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_root"><code class="name flex">
<span>def <span class="ident">interpret_root</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Interpret an <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> of type <code><a title="scrolls.ast.ASTNodeType.ROOT" href="ast.html#scrolls.ast.ASTNodeType.ROOT">ASTNodeType.ROOT</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_root(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
    &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.ROOT`.&#34;&#34;&#34;
    self.interpret_block(context, node)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_statement"><code class="name flex">
<span>def <span class="ident">interpret_statement</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Utility. Interprets Scrolls statements, which may be <code><a title="scrolls.ast.ASTNodeType.CONTROL_CALL" href="ast.html#scrolls.ast.ASTNodeType.CONTROL_CALL">ASTNodeType.CONTROL_CALL</a></code>,
<code><a title="scrolls.ast.ASTNodeType.COMMAND_CALL" href="ast.html#scrolls.ast.ASTNodeType.COMMAND_CALL">ASTNodeType.COMMAND_CALL</a></code>, or <code><a title="scrolls.ast.ASTNodeType.BLOCK" href="ast.html#scrolls.ast.ASTNodeType.BLOCK">ASTNodeType.BLOCK</a></code>.</p>
<p>More often than not, this is the function that control calls will use to run the statement passed to
<code><a title="scrolls.interpreter.InterpreterContext.control_node" href="#scrolls.interpreter.InterpreterContext.control_node">InterpreterContext.control_node</a></code>. See <code><a title="scrolls.builtins.BuiltinControlHandler" href="builtins.html#scrolls.builtins.BuiltinControlHandler">BuiltinControlHandler</a></code> for examples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_statement(self, context: InterpreterContext, node: ast.ASTNode) -&gt; None:
    &#34;&#34;&#34;Utility. Interprets Scrolls statements, which may be `scrolls.ast.ASTNodeType.CONTROL_CALL`,
    `scrolls.ast.ASTNodeType.COMMAND_CALL`, or `scrolls.ast.ASTNodeType.BLOCK`.

    More often than not, this is the function that control calls will use to run the statement passed to
    `InterpreterContext.control_node`. See `scrolls.builtins.BuiltinControlHandler` for examples.
    &#34;&#34;&#34;
    context.current_node = node

    type = context.current_node.type

    if type == ast.ASTNodeType.CONTROL_CALL:
        self.interpret_control(context, context.current_node)
    elif type == ast.ASTNodeType.COMMAND_CALL:
        self.interpret_command(context, context.current_node)
    elif type == ast.ASTNodeType.BLOCK:
        self.interpret_block(context, context.current_node)
    else:
        raise InternalInterpreterError(
            context, f&#34;Bad statement type {type.name}&#34;
        )

    context.statement_count += 1
    if self.over_statement_limit(context):
        raise InterpreterError(
            context,
            f&#34;Exceeded maximum statement limit of {self.statement_limit}.&#34;
        )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_string_or_expansion"><code class="name flex">
<span>def <span class="ident">interpret_string_or_expansion</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>) â€‘>Â Sequence[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Utility. Interprets call names and arguments, which may be either <code><a title="scrolls.ast.ASTNodeType.STRING" href="ast.html#scrolls.ast.ASTNodeType.STRING">ASTNodeType.STRING</a></code> or
<code><a title="scrolls.ast.ASTNodeType.EXPANSION" href="ast.html#scrolls.ast.ASTNodeType.EXPANSION">ASTNodeType.EXPANSION</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_string_or_expansion(self, context: InterpreterContext, node: ast.ASTNode) -&gt; t.Sequence[str]:
    &#34;&#34;&#34;Utility. Interprets call names and arguments, which may be either `scrolls.ast.ASTNodeType.STRING` or
    `scrolls.ast.ASTNodeType.EXPANSION`
    &#34;&#34;&#34;

    context.current_node = node

    if node.type == ast.ASTNodeType.STRING:
        return [node.str_content()]
    elif node.type == ast.ASTNodeType.EXPANSION:
        return self.interpret_expansion(context, node)
    else:
        raise InternalInterpreterError(
            context, f&#34;Bad node type for string_or_expansion: {node.type.name}&#34;
        )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_sub_expansion"><code class="name flex">
<span>def <span class="ident">interpret_sub_expansion</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Utility. Interprets an expansion child node, which may be either <code><a title="scrolls.ast.ASTNodeType.EXPANSION_VAR" href="ast.html#scrolls.ast.ASTNodeType.EXPANSION_VAR">ASTNodeType.EXPANSION_VAR</a></code> or
<code><a title="scrolls.ast.ASTNodeType.EXPANSION_CALL" href="ast.html#scrolls.ast.ASTNodeType.EXPANSION_CALL">ASTNodeType.EXPANSION_CALL</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_sub_expansion(self, context: InterpreterContext, node: ast.ASTNode) -&gt; str:
    &#34;&#34;&#34;Utility. Interprets an expansion child node, which may be either `scrolls.ast.ASTNodeType.EXPANSION_VAR` or
    `scrolls.ast.ASTNodeType.EXPANSION_CALL`.
    &#34;&#34;&#34;
    context.current_node = node

    if node.type == ast.ASTNodeType.EXPANSION_VAR:
        return self.interpret_variable_reference(context, node)
    elif node.type == ast.ASTNodeType.EXPANSION_CALL:
        return self.interpret_expansion_call(context, node)
    else:
        raise InternalInterpreterError(
            context,
            f&#34;Bad expansion node type {node.type.name}&#34;
        )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.interpret_variable_reference"><code class="name flex">
<span>def <span class="ident">interpret_variable_reference</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Interpret an <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> of type <code><a title="scrolls.ast.ASTNodeType.EXPANSION_VAR" href="ast.html#scrolls.ast.ASTNodeType.EXPANSION_VAR">ASTNodeType.EXPANSION_VAR</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_variable_reference(self, context: InterpreterContext, node: ast.ASTNode) -&gt; str:
    &#34;&#34;&#34;Interpret an `scrolls.ast.ASTNode` of type `scrolls.ast.ASTNodeType.EXPANSION_VAR`.&#34;&#34;&#34;
    context.current_node = node

    var_name = &#34; &#34;.join(self.interpret_string_or_expansion(context, node.children[0]))
    try:
        return context.get_var(var_name)
    except KeyError:
        raise InterpreterError(
            context, f&#34;No such variable {var_name}.&#34;
        )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.over_call_depth_limit"><code class="name flex">
<span>def <span class="ident">over_call_depth_limit</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function. Checks whether the passed context has exceeded the call stack depth limit set for this
interpreter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def over_call_depth_limit(self, context: InterpreterContext) -&gt; bool:
    &#34;&#34;&#34;
    Utility function. Checks whether the passed context has exceeded the call stack depth limit set for this
    interpreter.
    &#34;&#34;&#34;
    if self.call_depth_limit == 0:
        return False
    else:
        return len(context.call_stack) &gt; self.call_depth_limit</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.over_statement_limit"><code class="name flex">
<span>def <span class="ident">over_statement_limit</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function. Checks whether the passed context has exceeded the statement limit set for this interpreter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def over_statement_limit(self, context: InterpreterContext) -&gt; bool:
    &#34;&#34;&#34;
    Utility function. Checks whether the passed context has exceeded the statement limit set for this interpreter.
    &#34;&#34;&#34;
    if self.statement_limit == 0:
        return False
    else:
        return context.statement_count &gt; self.statement_limit</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.repl"><code class="name flex">
<span>def <span class="ident">repl</span></span>(<span>self, on_error:Â Optional[Callable[[<a title="scrolls.errors.ScrollError" href="errors.html#scrolls.errors.ScrollError">ScrollError</a>],Â None]]Â =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Drop into a REPL (read eval print loop).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>on_error</code></strong></dt>
<dd>A function to call when an error occurs. If <code>None</code>,
errors will stop the REPL.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repl(
    self,
    on_error: t.Optional[t.Callable[[errors.ScrollError], None]] = None
) -&gt; None:
    &#34;&#34;&#34;
    Drop into a REPL (read eval print loop).

    Args:
        on_error: A function to call when an error occurs. If `None`,
                  errors will stop the REPL.
    &#34;&#34;&#34;
    stream = ast.REPLStream()
    tokenizer = ast.Tokenizer(stream)
    context = self.context_cls()
    self.init_context(context)

    while True:
        try:
            statement_node = ast.parse_statement(tokenizer)
            stream.set_statement()

            self.interpret_statement(context, statement_node)
        except InterpreterStop:
            return
        except InterpreterReturn:
            e = InterpreterError(
                context,
                f&#34;returning only allowed in functions&#34;
            )
            if on_error is not None:
                on_error(e)
                stream.set_statement()
                stream.next_line()
            else:
                raise e
        except KeyboardInterrupt:
            print(&#34;Keyboard interrupt.&#34;)
            return
        except errors.ScrollError as e:
            if on_error is not None:
                on_error(e)
                stream.set_statement()
                stream.next_line()
            else:
                raise</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, script:Â str, context:Â Optional[<a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>]Â =Â None, consume_rest_triggers:Â Mapping[str,Â int]Â =Â mappingproxy({})) â€‘>Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Run a Scrolls script.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>script</code></strong></dt>
<dd>The script to run.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Optional. If no context is specified, then an instance of <code><a title="scrolls.interpreter.Interpreter.context_cls" href="#scrolls.interpreter.Interpreter.context_cls">Interpreter.context_cls</a></code> is created
automatically. Otherwise, the passed context object will be used.</dd>
<dt><strong><code>consume_rest_triggers</code></strong></dt>
<dd>A mapping of triggers for the CONSUME_REST parsing feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The context used to execute the script. If <code>context</code> was not None, <code>context</code> will be returned. Otherwise,
it will be the automatically created <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(
    self,
    script: str,
    context: t.Optional[InterpreterContext] = None,
    consume_rest_triggers: t.Mapping[str, int] = types.MappingProxyType({})
) -&gt; InterpreterContext:
    &#34;&#34;&#34;Run a Scrolls script.

    Args:
        script: The script to run.
        context: Optional. If no context is specified, then an instance of `Interpreter.context_cls` is created
            automatically. Otherwise, the passed context object will be used.
        consume_rest_triggers: A mapping of triggers for the CONSUME_REST parsing feature.

    Returns:
        The context used to execute the script. If `context` was not None, `context` will be returned. Otherwise,
        it will be the automatically created `InterpreterContext` instance.
    &#34;&#34;&#34;
    tokenizer = ast.Tokenizer(script, consume_rest_triggers)
    tree = ast.parse_scroll(tokenizer)
    return self.interpret_ast(tree, context)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.Interpreter.run_statement"><code class="name flex">
<span>def <span class="ident">run_statement</span></span>(<span>self, statement:Â Union[str,Â <a title="scrolls.ast.Tokenizer" href="ast.html#scrolls.ast.Tokenizer">Tokenizer</a>], context:Â Optional[<a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>]Â =Â None) â€‘>Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Run a single Scrolls statement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement to run. Must be either a string, or a tokenizer populated with a valid Scrolls
statement.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>Optional. If no context is specified, then an instance of <code><a title="scrolls.interpreter.Interpreter.context_cls" href="#scrolls.interpreter.Interpreter.context_cls">Interpreter.context_cls</a></code> is created
automatically. Otherwise, the passed context object will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The context used to execute the script. If <code>context</code> was not None, <code>context</code> will be returned. Otherwise,
it will be the automatically created <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_statement(
    self,
    statement: t.Union[str, ast.Tokenizer],
    context: t.Optional[InterpreterContext] = None,
) -&gt; InterpreterContext:
    &#34;&#34;&#34;Run a single Scrolls statement.

    Args:
        statement: The statement to run. Must be either a string, or a tokenizer populated with a valid Scrolls
            statement.
        context: Optional. If no context is specified, then an instance of `Interpreter.context_cls` is created
            automatically. Otherwise, the passed context object will be used.

    Returns:
        The context used to execute the script. If `context` was not None, `context` will be returned. Otherwise,
        it will be the automatically created `InterpreterContext` instance.
    &#34;&#34;&#34;
    # Set up parsing and parse statement
    if isinstance(statement, str):
        tokenizer = ast.Tokenizer(statement)
    else:
        tokenizer = statement

    statement_node = ast.parse_statement(tokenizer)

    # Interpret statement
    if context is None:
        context = self.context_cls(statement_node)

    self.init_context(context)
    self.interpret_statement(context, statement_node)

    return context</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.InterpreterContext"><code class="flex name class">
<span>class <span class="ident">InterpreterContext</span></span>
<span>(</span><span>*_:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for the command interpreter context. Contains all state information for the <code><a title="scrolls.interpreter.Interpreter" href="#scrolls.interpreter.Interpreter">Interpreter</a></code>.
This is also the main interface plugin writers will use to interact with the interpreter, and is passed to all
<code><a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a></code> implementations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InterpreterContext:
    &#34;&#34;&#34;
    Base class for the command interpreter context. Contains all state information for the `Interpreter`.
    This is also the main interface plugin writers will use to interact with the interpreter, and is passed to all
    `CallHandler` implementations.
    &#34;&#34;&#34;
    def __init__(self, *_: t.Any):
        self._current_node: t.Optional[ast.ASTNode] = None
        self._call_context: t.Optional[CallContext] = None
        self._interpreter: t.Optional[Interpreter] = None
        self._vars = ScopedVarStore()

        self.statement_count = 0
        &#34;&#34;&#34;The number of statements that have been run by the interpreter so far.&#34;&#34;&#34;

        self._call_stack: t.MutableSequence[CallContext] = []
        self._command_handlers: BaseCallHandlerContainer[None] = BaseCallHandlerContainer()
        self._expansion_handlers: BaseCallHandlerContainer[str] = BaseCallHandlerContainer()

        self._open_files: t.MutableMapping[int, t.IO[str]] = {}
        self._fid = 0

    @property
    def vars(self) -&gt; ScopedVarStore:
        &#34;&#34;&#34;The variable store.&#34;&#34;&#34;
        return self._vars

    def set_var(self, name: str, value: str) -&gt; None:
        &#34;&#34;&#34;Set a variable.&#34;&#34;&#34;
        self.vars.set_var(name, value)

    def del_var(self, name: str) -&gt; None:
        &#34;&#34;&#34;Delete a variable.&#34;&#34;&#34;
        self.vars.del_var(name)

    def get_var(self, name: str) -&gt; str:
        &#34;&#34;&#34;Get a variable.&#34;&#34;&#34;
        return self.vars.get_var(name)

    def open_file(self, path: str, mode: str) -&gt; int:
        &#34;&#34;&#34;
        Opens a file for this context.

        Returns:
             A numeric file ID that should be used in other `*_file` functions
             for `InterpreterContext`.
        &#34;&#34;&#34;
        p = pathlib.Path(path)

        if not p.exists():
            raise InterpreterError(
                self,
                f&#34;{path} does not exist&#34;
            )

        if not p.is_file():
            raise InterpreterError(
                self,
                f&#34;{path} is not a file&#34;
            )

        # do not allow binary mode for now
        mode = mode.replace(&#34;b&#34;, &#34;&#34;)

        f = open(p, mode)
        self._open_files[self._fid] = f
        used_fid = self._fid
        self._fid += 1

        logger.debug(f&#34;Opened file: {path}&#34;)

        return used_fid

    def close_file(self, fid: int) -&gt; None:
        &#34;&#34;&#34;
        Closes a file for this context.
        &#34;&#34;&#34;
        if fid not in self._open_files:
            raise InterpreterError(
                self,
                f&#34;file already closed, or not open (fid {fid})&#34;
            )

        self._open_files[fid].close()
        del self._open_files[fid]

    def get_file(self, fid: int) -&gt; t.IO[str]:
        &#34;&#34;&#34;
        Gets an open file for this context.
        &#34;&#34;&#34;
        if fid not in self._open_files:
            raise InterpreterError(
                self,
                f&#34;file already closed, or not open (fid {fid})&#34;
            )

        return self._open_files[fid]

    @property
    def runtime_commands(self) -&gt; &#39;BaseCallHandlerContainer[None]&#39;:
        &#34;&#34;&#34;The call handler container for runtime command handlers. Runtime commands are defined while the interpreter
        is running, i.e. through the `!def` directive or similar. Runtime commands

        For any command handler added to this container, all commands defined within it:

        - **Should** always perform their work in their own variable scope. See `ScopedVarStore.new_scope`.
        - **Must** set the `CallContext.runtime_call` parameter to `True`.
        - **Must** cease executing if an `InterpreterStop` or `InterpreterReturn` is raised.
        &#34;&#34;&#34;
        return self._command_handlers

    @property
    def runtime_expansions(self) -&gt; &#39;BaseCallHandlerContainer[str]&#39;:
        &#34;&#34;&#34;Same as `InterpreterContext.runtime_commands`, but for expansion calls.

        Runtime expansions follow the same requirements as commands, plus:

        - **Must** set the `CallContext.return_value` parameter upon call completion.
        - **Must** catch `InterpreterReturn` and set the return value on this exception.
        &#34;&#34;&#34;
        return self._expansion_handlers

    @property
    def interpreter(self) -&gt; &#39;Interpreter&#39;:
        &#34;&#34;&#34;
        The interpreter running using this context.

        Raises:
            InternalInterpreterError: If this property is not initialized.
        &#34;&#34;&#34;
        if self._interpreter is None:
            raise InternalInterpreterError(
                self, &#34;Interpreter is not initialized.&#34;
            )

        return self._interpreter

    @interpreter.setter
    def interpreter(self, interpreter: &#39;Interpreter&#39;) -&gt; None:
        self._interpreter = interpreter

    @property
    def current_node(self) -&gt; ast.ASTNode:
        &#34;&#34;&#34;
        The current `scrolls.ast.ASTNode` being interpreted.

        Raises:
            InternalInterpreterError: If there is no current node.
        &#34;&#34;&#34;
        if self._current_node is None:
            raise InternalInterpreterError(
                self, &#34;Current node is not initialized.&#34;
            )

        return self._current_node

    @current_node.setter
    def current_node(self, node: ast.ASTNode) -&gt; None:
        self._current_node = node

    def _call_check(self) -&gt; None:
        if self._call_context is None:
            raise InternalInterpreterError(
                self, &#34;Current context is not a call.&#34;
            )

    @property
    def call_stack(self) -&gt; t.Sequence[CallContext]:
        &#34;&#34;&#34;
        The call stack. Used primarily for tracking return values in runtime calls, and feeding
        call information to `CallHandler` implementations. Variables scopes are tracked separately.
        See `InterpreterContext.vars`.

        .. WARNING::
            This stack does not contain the current call. See `InterpreterContext.call_context` for that.
        &#34;&#34;&#34;
        return self._call_stack

    @property
    def call_context(self) -&gt; CallContext:
        &#34;&#34;&#34;
        The current call context.
        &#34;&#34;&#34;
        self._call_check()
        return t.cast(CallContext, self._call_context)

    @property
    def call_name(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the current call.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.call_name

    @property
    def args(self) -&gt; t.Sequence[str]:
        &#34;&#34;&#34;
        The argments passed into the current call.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.args

    @property
    def arg_nodes(self) -&gt; ArgSourceMap[ast.ASTNode]:
        &#34;&#34;&#34;
        The `scrolls.ast.ASTNode` instances the current call&#39;s arguments came from.
        &#34;&#34;&#34;
        self._call_check()
        return self.call_context.arg_nodes

    @property
    def control_node(self) -&gt; ast.ASTNode:
        &#34;&#34;&#34;
        If the current context is a control call, this will contain the `scrolls.ast.ASTNode` parameter passed into it.

        Raises:
            InternalInterpreterError: If the current context is not a call.
        &#34;&#34;&#34;
        if self.call_context.control_node is None:
            raise InternalInterpreterError(
                self, &#34;Current context is not a control call.&#34;
            )

        return self.call_context.control_node

    def set_call(
        self,
        command: str,
        args: t.Sequence[str],
        arg_nodes: ArgSourceMap[ast.ASTNode],
        control_node: t.Optional[ast.ASTNode] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Sets the current call context, overwriting whatever was previously current. If you want to preserve the
        current context for later use, see `InterpreterContext.push_call`

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        self._call_context = CallContext(
            command,
            args,
            arg_nodes,
            control_node
        )

    def in_call(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the current context is in a call or not.
        &#34;&#34;&#34;
        return self._call_context is not None

    def reset_call(self) -&gt; None:
        &#34;&#34;&#34;
        Destroys the current call context.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        self._call_context = None

    def push_call(self) -&gt; None:
        &#34;&#34;&#34;
        Duplicate the current call context and push it onto the call stack. Should be followed up with
        `InterpreterContext.set_call` to create a new context.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
        &#34;&#34;&#34;
        self._call_check()
        self._call_stack.append(self.call_context)

    def pop_call(self) -&gt; None:
        &#34;&#34;&#34;
        Destroy the current call context, and replace it with the first context on the call stack.

        .. WARNING::
            Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.

        Raises:
            InternalInterpreterError: If not calls have been pushed.
        &#34;&#34;&#34;
        if not self._call_stack:
            raise InternalInterpreterError(
                self,
                f&#34;Cannot pop call. No calls pushed.&#34;
            )

        ctx = self._call_stack.pop()
        self._call_context = ctx

    # In order to set a return value, we need to traverse up the
    # context stack in order to find one actually created by a dynamically
    # generated call.
    def set_retval(self, retval: str) -&gt; None:
        &#34;&#34;&#34;
        Sets the return value in the first runtime call found in the stack.

        Raises:
            InterpreterError: If outside a call context, no call stack, or no runtime call contexts found.
        &#34;&#34;&#34;
        self._call_check()

        if not self.call_stack:
            raise InterpreterError(
                self,
                f&#34;cannot return, no call stack (outside calls)&#34;
            )

        for ctx in reversed(self.call_stack):
            if ctx.runtime_call:
                ctx.return_value = retval
                return

        raise InterpreterError(
            self,
            f&#34;cannot return outside of function&#34;
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="scrolls.interpreter.InterpreterContext.arg_nodes"><code class="name">var <span class="ident">arg_nodes</span> :Â <a title="scrolls.interpreter.ArgSourceMap" href="#scrolls.interpreter.ArgSourceMap">ArgSourceMap</a></code></dt>
<dd>
<div class="desc"><p>The <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> instances the current call's arguments came from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def arg_nodes(self) -&gt; ArgSourceMap[ast.ASTNode]:
    &#34;&#34;&#34;
    The `scrolls.ast.ASTNode` instances the current call&#39;s arguments came from.
    &#34;&#34;&#34;
    self._call_check()
    return self.call_context.arg_nodes</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.args"><code class="name">var <span class="ident">args</span> :Â Sequence[str]</code></dt>
<dd>
<div class="desc"><p>The argments passed into the current call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def args(self) -&gt; t.Sequence[str]:
    &#34;&#34;&#34;
    The argments passed into the current call.
    &#34;&#34;&#34;
    self._call_check()
    return self.call_context.args</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.call_context"><code class="name">var <span class="ident">call_context</span> :Â <a title="scrolls.interpreter.CallContext" href="#scrolls.interpreter.CallContext">CallContext</a></code></dt>
<dd>
<div class="desc"><p>The current call context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_context(self) -&gt; CallContext:
    &#34;&#34;&#34;
    The current call context.
    &#34;&#34;&#34;
    self._call_check()
    return t.cast(CallContext, self._call_context)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.call_name"><code class="name">var <span class="ident">call_name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The name of the current call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_name(self) -&gt; str:
    &#34;&#34;&#34;
    The name of the current call.
    &#34;&#34;&#34;
    self._call_check()
    return self.call_context.call_name</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.call_stack"><code class="name">var <span class="ident">call_stack</span> :Â Sequence[<a title="scrolls.interpreter.CallContext" href="#scrolls.interpreter.CallContext">CallContext</a>]</code></dt>
<dd>
<div class="desc"><p>The call stack. Used primarily for tracking return values in runtime calls, and feeding
call information to <code><a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a></code> implementations. Variables scopes are tracked separately.
See <code><a title="scrolls.interpreter.InterpreterContext.vars" href="#scrolls.interpreter.InterpreterContext.vars">InterpreterContext.vars</a></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This stack does not contain the current call. See <code><a title="scrolls.interpreter.InterpreterContext.call_context" href="#scrolls.interpreter.InterpreterContext.call_context">InterpreterContext.call_context</a></code> for that.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_stack(self) -&gt; t.Sequence[CallContext]:
    &#34;&#34;&#34;
    The call stack. Used primarily for tracking return values in runtime calls, and feeding
    call information to `CallHandler` implementations. Variables scopes are tracked separately.
    See `InterpreterContext.vars`.

    .. WARNING::
        This stack does not contain the current call. See `InterpreterContext.call_context` for that.
    &#34;&#34;&#34;
    return self._call_stack</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.control_node"><code class="name">var <span class="ident">control_node</span> :Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code></dt>
<dd>
<div class="desc"><p>If the current context is a control call, this will contain the <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> parameter passed into it.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.InternalInterpreterError" href="#scrolls.interpreter.InternalInterpreterError">InternalInterpreterError</a></code></dt>
<dd>If the current context is not a call.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def control_node(self) -&gt; ast.ASTNode:
    &#34;&#34;&#34;
    If the current context is a control call, this will contain the `scrolls.ast.ASTNode` parameter passed into it.

    Raises:
        InternalInterpreterError: If the current context is not a call.
    &#34;&#34;&#34;
    if self.call_context.control_node is None:
        raise InternalInterpreterError(
            self, &#34;Current context is not a control call.&#34;
        )

    return self.call_context.control_node</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.current_node"><code class="name">var <span class="ident">current_node</span> :Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code></dt>
<dd>
<div class="desc"><p>The current <code><a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code> being interpreted.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.InternalInterpreterError" href="#scrolls.interpreter.InternalInterpreterError">InternalInterpreterError</a></code></dt>
<dd>If there is no current node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def current_node(self) -&gt; ast.ASTNode:
    &#34;&#34;&#34;
    The current `scrolls.ast.ASTNode` being interpreted.

    Raises:
        InternalInterpreterError: If there is no current node.
    &#34;&#34;&#34;
    if self._current_node is None:
        raise InternalInterpreterError(
            self, &#34;Current node is not initialized.&#34;
        )

    return self._current_node</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.interpreter"><code class="name">var <span class="ident">interpreter</span> :Â <a title="scrolls.interpreter.Interpreter" href="#scrolls.interpreter.Interpreter">Interpreter</a></code></dt>
<dd>
<div class="desc"><p>The interpreter running using this context.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.InternalInterpreterError" href="#scrolls.interpreter.InternalInterpreterError">InternalInterpreterError</a></code></dt>
<dd>If this property is not initialized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def interpreter(self) -&gt; &#39;Interpreter&#39;:
    &#34;&#34;&#34;
    The interpreter running using this context.

    Raises:
        InternalInterpreterError: If this property is not initialized.
    &#34;&#34;&#34;
    if self._interpreter is None:
        raise InternalInterpreterError(
            self, &#34;Interpreter is not initialized.&#34;
        )

    return self._interpreter</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.runtime_commands"><code class="name">var <span class="ident">runtime_commands</span> :Â <a title="scrolls.interpreter.BaseCallHandlerContainer" href="#scrolls.interpreter.BaseCallHandlerContainer">BaseCallHandlerContainer</a>[None]</code></dt>
<dd>
<div class="desc"><p>The call handler container for runtime command handlers. Runtime commands are defined while the interpreter
is running, i.e. through the <code>!def</code> directive or similar. Runtime commands</p>
<p>For any command handler added to this container, all commands defined within it:</p>
<ul>
<li><strong>Should</strong> always perform their work in their own variable scope. See <code><a title="scrolls.interpreter.ScopedVarStore.new_scope" href="#scrolls.interpreter.ScopedVarStore.new_scope">ScopedVarStore.new_scope()</a></code>.</li>
<li><strong>Must</strong> set the <code><a title="scrolls.interpreter.CallContext.runtime_call" href="#scrolls.interpreter.CallContext.runtime_call">CallContext.runtime_call</a></code> parameter to <code>True</code>.</li>
<li><strong>Must</strong> cease executing if an <code><a title="scrolls.interpreter.InterpreterStop" href="#scrolls.interpreter.InterpreterStop">InterpreterStop</a></code> or <code><a title="scrolls.interpreter.InterpreterReturn" href="#scrolls.interpreter.InterpreterReturn">InterpreterReturn</a></code> is raised.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def runtime_commands(self) -&gt; &#39;BaseCallHandlerContainer[None]&#39;:
    &#34;&#34;&#34;The call handler container for runtime command handlers. Runtime commands are defined while the interpreter
    is running, i.e. through the `!def` directive or similar. Runtime commands

    For any command handler added to this container, all commands defined within it:

    - **Should** always perform their work in their own variable scope. See `ScopedVarStore.new_scope`.
    - **Must** set the `CallContext.runtime_call` parameter to `True`.
    - **Must** cease executing if an `InterpreterStop` or `InterpreterReturn` is raised.
    &#34;&#34;&#34;
    return self._command_handlers</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.runtime_expansions"><code class="name">var <span class="ident">runtime_expansions</span> :Â <a title="scrolls.interpreter.BaseCallHandlerContainer" href="#scrolls.interpreter.BaseCallHandlerContainer">BaseCallHandlerContainer</a>[str]</code></dt>
<dd>
<div class="desc"><p>Same as <code><a title="scrolls.interpreter.InterpreterContext.runtime_commands" href="#scrolls.interpreter.InterpreterContext.runtime_commands">InterpreterContext.runtime_commands</a></code>, but for expansion calls.</p>
<p>Runtime expansions follow the same requirements as commands, plus:</p>
<ul>
<li><strong>Must</strong> set the <code><a title="scrolls.interpreter.CallContext.return_value" href="#scrolls.interpreter.CallContext.return_value">CallContext.return_value</a></code> parameter upon call completion.</li>
<li><strong>Must</strong> catch <code><a title="scrolls.interpreter.InterpreterReturn" href="#scrolls.interpreter.InterpreterReturn">InterpreterReturn</a></code> and set the return value on this exception.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def runtime_expansions(self) -&gt; &#39;BaseCallHandlerContainer[str]&#39;:
    &#34;&#34;&#34;Same as `InterpreterContext.runtime_commands`, but for expansion calls.

    Runtime expansions follow the same requirements as commands, plus:

    - **Must** set the `CallContext.return_value` parameter upon call completion.
    - **Must** catch `InterpreterReturn` and set the return value on this exception.
    &#34;&#34;&#34;
    return self._expansion_handlers</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.statement_count"><code class="name">var <span class="ident">statement_count</span></code></dt>
<dd>
<div class="desc"><p>The number of statements that have been run by the interpreter so far.</p></div>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.vars"><code class="name">var <span class="ident">vars</span> :Â <a title="scrolls.interpreter.ScopedVarStore" href="#scrolls.interpreter.ScopedVarStore">ScopedVarStore</a></code></dt>
<dd>
<div class="desc"><p>The variable store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vars(self) -&gt; ScopedVarStore:
    &#34;&#34;&#34;The variable store.&#34;&#34;&#34;
    return self._vars</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.InterpreterContext.close_file"><code class="name flex">
<span>def <span class="ident">close_file</span></span>(<span>self, fid:Â int) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Closes a file for this context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_file(self, fid: int) -&gt; None:
    &#34;&#34;&#34;
    Closes a file for this context.
    &#34;&#34;&#34;
    if fid not in self._open_files:
        raise InterpreterError(
            self,
            f&#34;file already closed, or not open (fid {fid})&#34;
        )

    self._open_files[fid].close()
    del self._open_files[fid]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.del_var"><code class="name flex">
<span>def <span class="ident">del_var</span></span>(<span>self, name:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_var(self, name: str) -&gt; None:
    &#34;&#34;&#34;Delete a variable.&#34;&#34;&#34;
    self.vars.del_var(name)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.get_file"><code class="name flex">
<span>def <span class="ident">get_file</span></span>(<span>self, fid:Â int) â€‘>Â IO[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets an open file for this context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file(self, fid: int) -&gt; t.IO[str]:
    &#34;&#34;&#34;
    Gets an open file for this context.
    &#34;&#34;&#34;
    if fid not in self._open_files:
        raise InterpreterError(
            self,
            f&#34;file already closed, or not open (fid {fid})&#34;
        )

    return self._open_files[fid]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.get_var"><code class="name flex">
<span>def <span class="ident">get_var</span></span>(<span>self, name:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Get a variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_var(self, name: str) -&gt; str:
    &#34;&#34;&#34;Get a variable.&#34;&#34;&#34;
    return self.vars.get_var(name)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.in_call"><code class="name flex">
<span>def <span class="ident">in_call</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the current context is in a call or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_call(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the current context is in a call or not.
    &#34;&#34;&#34;
    return self._call_context is not None</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.open_file"><code class="name flex">
<span>def <span class="ident">open_file</span></span>(<span>self, path:Â str, mode:Â str) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a file for this context.</p>
<h2 id="returns">Returns</h2>
<p>A numeric file ID that should be used in other <code>*_file</code> functions
for <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_file(self, path: str, mode: str) -&gt; int:
    &#34;&#34;&#34;
    Opens a file for this context.

    Returns:
         A numeric file ID that should be used in other `*_file` functions
         for `InterpreterContext`.
    &#34;&#34;&#34;
    p = pathlib.Path(path)

    if not p.exists():
        raise InterpreterError(
            self,
            f&#34;{path} does not exist&#34;
        )

    if not p.is_file():
        raise InterpreterError(
            self,
            f&#34;{path} is not a file&#34;
        )

    # do not allow binary mode for now
    mode = mode.replace(&#34;b&#34;, &#34;&#34;)

    f = open(p, mode)
    self._open_files[self._fid] = f
    used_fid = self._fid
    self._fid += 1

    logger.debug(f&#34;Opened file: {path}&#34;)

    return used_fid</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.pop_call"><code class="name flex">
<span>def <span class="ident">pop_call</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Destroy the current call context, and replace it with the first context on the call stack.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.InternalInterpreterError" href="#scrolls.interpreter.InternalInterpreterError">InternalInterpreterError</a></code></dt>
<dd>If not calls have been pushed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_call(self) -&gt; None:
    &#34;&#34;&#34;
    Destroy the current call context, and replace it with the first context on the call stack.

    .. WARNING::
        Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.

    Raises:
        InternalInterpreterError: If not calls have been pushed.
    &#34;&#34;&#34;
    if not self._call_stack:
        raise InternalInterpreterError(
            self,
            f&#34;Cannot pop call. No calls pushed.&#34;
        )

    ctx = self._call_stack.pop()
    self._call_context = ctx</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.push_call"><code class="name flex">
<span>def <span class="ident">push_call</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Duplicate the current call context and push it onto the call stack. Should be followed up with
<code><a title="scrolls.interpreter.InterpreterContext.set_call" href="#scrolls.interpreter.InterpreterContext.set_call">InterpreterContext.set_call()</a></code> to create a new context.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_call(self) -&gt; None:
    &#34;&#34;&#34;
    Duplicate the current call context and push it onto the call stack. Should be followed up with
    `InterpreterContext.set_call` to create a new context.

    .. WARNING::
        Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
    &#34;&#34;&#34;
    self._call_check()
    self._call_stack.append(self.call_context)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.reset_call"><code class="name flex">
<span>def <span class="ident">reset_call</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Destroys the current call context.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_call(self) -&gt; None:
    &#34;&#34;&#34;
    Destroys the current call context.

    .. WARNING::
        Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
    &#34;&#34;&#34;
    self._call_context = None</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.set_call"><code class="name flex">
<span>def <span class="ident">set_call</span></span>(<span>self, command:Â str, args:Â Sequence[str], arg_nodes:Â <a title="scrolls.interpreter.ArgSourceMap" href="#scrolls.interpreter.ArgSourceMap">ArgSourceMap</a>, control_node:Â Optional[<a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>]Â =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the current call context, overwriting whatever was previously current. If you want to preserve the
current context for later use, see <code><a title="scrolls.interpreter.InterpreterContext.push_call" href="#scrolls.interpreter.InterpreterContext.push_call">InterpreterContext.push_call()</a></code></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_call(
    self,
    command: str,
    args: t.Sequence[str],
    arg_nodes: ArgSourceMap[ast.ASTNode],
    control_node: t.Optional[ast.ASTNode] = None
) -&gt; None:
    &#34;&#34;&#34;
    Sets the current call context, overwriting whatever was previously current. If you want to preserve the
    current context for later use, see `InterpreterContext.push_call`

    .. WARNING::
        Provided for advanced usage, this is usually done automatically. Typical users will never need to call this.
    &#34;&#34;&#34;
    self._call_context = CallContext(
        command,
        args,
        arg_nodes,
        control_node
    )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.set_retval"><code class="name flex">
<span>def <span class="ident">set_retval</span></span>(<span>self, retval:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the return value in the first runtime call found in the stack.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="scrolls.interpreter.InterpreterError" href="#scrolls.interpreter.InterpreterError">InterpreterError</a></code></dt>
<dd>If outside a call context, no call stack, or no runtime call contexts found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_retval(self, retval: str) -&gt; None:
    &#34;&#34;&#34;
    Sets the return value in the first runtime call found in the stack.

    Raises:
        InterpreterError: If outside a call context, no call stack, or no runtime call contexts found.
    &#34;&#34;&#34;
    self._call_check()

    if not self.call_stack:
        raise InterpreterError(
            self,
            f&#34;cannot return, no call stack (outside calls)&#34;
        )

    for ctx in reversed(self.call_stack):
        if ctx.runtime_call:
            ctx.return_value = retval
            return

    raise InterpreterError(
        self,
        f&#34;cannot return outside of function&#34;
    )</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.InterpreterContext.set_var"><code class="name flex">
<span>def <span class="ident">set_var</span></span>(<span>self, name:Â str, value:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Set a variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_var(self, name: str, value: str) -&gt; None:
    &#34;&#34;&#34;Set a variable.&#34;&#34;&#34;
    self.vars.set_var(name, value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.InterpreterError"><code class="flex name class">
<span>class <span class="ident">InterpreterError</span></span>
<span>(</span><span>ctx:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>, message:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic interpreter error. All interpreter errors should subclass this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InterpreterError(errors.PositionalError):
    &#34;&#34;&#34;
    A generic interpreter error. All interpreter errors should subclass this.
    &#34;&#34;&#34;
    def __init__(self, ctx: InterpreterContext, message: str):
        self.ctx = ctx

        if self.ctx.current_node.has_token():
            tok = self.ctx.current_node.tok
            super().__init__(
                tok.line,
                tok.position,
                tok.tokenizer.stream.history(),
                message
            )
        else:
            super().__init__(
                0,
                0,
                &#34;&#34;,
                message
            )

    def __str__(self) -&gt; str:
        if self.ctx.current_node.has_token():
            return super().__str__()
        else:
            return &#34;Interpreter error on node with uninitialized token.&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.errors.PositionalError" href="errors.html#scrolls.errors.PositionalError">PositionalError</a></li>
<li><a title="scrolls.errors.ScrollError" href="errors.html#scrolls.errors.ScrollError">ScrollError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.InternalInterpreterError" href="#scrolls.interpreter.InternalInterpreterError">InternalInterpreterError</a></li>
<li>scrolls.interpreter.MissingCallError</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrolls.errors.PositionalError" href="errors.html#scrolls.errors.PositionalError">PositionalError</a></b></code>:
<ul class="hlist">
<li><code><a title="scrolls.errors.PositionalError.line" href="errors.html#scrolls.errors.PositionalError.line">line</a></code></li>
<li><code><a title="scrolls.errors.PositionalError.message" href="errors.html#scrolls.errors.PositionalError.message">message</a></code></li>
<li><code><a title="scrolls.errors.PositionalError.pos" href="errors.html#scrolls.errors.PositionalError.pos">pos</a></code></li>
<li><code><a title="scrolls.errors.PositionalError.string" href="errors.html#scrolls.errors.PositionalError.string">string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrolls.interpreter.InterpreterReturn"><code class="flex name class">
<span>class <span class="ident">InterpreterReturn</span></span>
</code></dt>
<dd>
<div class="desc"><p>An exception raised to signal a return from a runtime call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InterpreterReturn(errors.ScrollError):
    &#34;&#34;&#34;
    An exception raised to signal a return from a runtime call.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__(&#34;InterpreterReturn&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.errors.ScrollError" href="errors.html#scrolls.errors.ScrollError">ScrollError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="scrolls.interpreter.InterpreterStop"><code class="flex name class">
<span>class <span class="ident">InterpreterStop</span></span>
</code></dt>
<dd>
<div class="desc"><p>An exception raised to stop the interpreter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InterpreterStop(errors.ScrollError):
    &#34;&#34;&#34;
    An exception raised to stop the interpreter.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__(&#34;InterpreterStop&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.errors.ScrollError" href="errors.html#scrolls.errors.ScrollError">ScrollError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="scrolls.interpreter.MutableCallHandlerContainer"><code class="flex name class">
<span>class <span class="ident">MutableCallHandlerContainer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A mutable <code><a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a></code> container.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MutableCallHandlerContainer(CallHandlerContainer[T], t.Protocol[T]):
    &#34;&#34;&#34;
    A mutable `CallHandler` container.
    &#34;&#34;&#34;
    def add(self, handler: CallHandler[T], name: str = &#34;&#34;) -&gt; None: ...
    &#34;&#34;&#34;Add a call handler to this container.
    
    If `name` is not specified, then a unique name should be generated. The specific name generated is up to the
    implementor.
    &#34;&#34;&#34;

    def remove(self, handler: t.Union[CallHandler[T], str]) -&gt; None: ...
    &#34;&#34;&#34;Remove a call handler from this container.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrolls.interpreter.CallHandlerContainer" href="#scrolls.interpreter.CallHandlerContainer">CallHandlerContainer</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.MutableCallHandlerContainer.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, handler:Â <a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[~T], name:Â strÂ =Â '') â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, handler: CallHandler[T], name: str = &#34;&#34;) -&gt; None: ...</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.MutableCallHandlerContainer.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, handler:Â Union[<a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a>[~T],Â str]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, handler: t.Union[CallHandler[T], str]) -&gt; None: ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.RuntimeCall"><code class="flex name class">
<span>class <span class="ident">RuntimeCall</span></span>
<span>(</span><span>name:Â str, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>, params:Â Sequence[str], collect_param:Â Optional[str])</span>
</code></dt>
<dd>
<div class="desc"><p>A simple runtime call that is implemented by some Scrolls code.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Instances of this class are created automatically by <code><a title="scrolls.interpreter.RuntimeCallHandler" href="#scrolls.interpreter.RuntimeCallHandler">RuntimeCallHandler</a></code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class RuntimeCall:
    &#34;&#34;&#34;
    A simple runtime call that is implemented by some Scrolls code.

    .. WARNING::
        Instances of this class are created automatically by `RuntimeCallHandler`.
    &#34;&#34;&#34;

    name: str
    &#34;&#34;&#34;The name of the call.&#34;&#34;&#34;

    node: ast.ASTNode
    &#34;&#34;&#34;The statement node that should be run when this call is executed.&#34;&#34;&#34;

    params: t.Sequence[str]
    &#34;&#34;&#34;The names of the parameters, corresponding to the names of the local variables created when this call
    is executed.
    &#34;&#34;&#34;

    collect_param: t.Optional[str]
    &#34;&#34;&#34;The name of the collect parameter, if any. This will always be the last parameter, and will
    collect all extra arguments fed into this call and interpret them as a string vector. In other words, this is
    the `*args` parameter, for Scrolls.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="scrolls.interpreter.RuntimeCall.collect_param"><code class="name">var <span class="ident">collect_param</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"><p>The name of the collect parameter, if any. This will always be the last parameter, and will
collect all extra arguments fed into this call and interpret them as a string vector. In other words, this is
the <code>*args</code> parameter, for Scrolls.</p></div>
</dd>
<dt id="scrolls.interpreter.RuntimeCall.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The name of the call.</p></div>
</dd>
<dt id="scrolls.interpreter.RuntimeCall.node"><code class="name">var <span class="ident">node</span> :Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a></code></dt>
<dd>
<div class="desc"><p>The statement node that should be run when this call is executed.</p></div>
</dd>
<dt id="scrolls.interpreter.RuntimeCall.params"><code class="name">var <span class="ident">params</span> :Â Sequence[str]</code></dt>
<dd>
<div class="desc"><p>The names of the parameters, corresponding to the names of the local variables created when this call
is executed.</p></div>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.RuntimeCallHandler"><code class="flex name class">
<span>class <span class="ident">RuntimeCallHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>A basic call handler that maps names to AST nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuntimeCallHandler(t.Generic[T_co]):
    &#34;&#34;&#34;
    A basic call handler that maps names to AST nodes.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        self.calls: t.MutableMapping[str, RuntimeCall] = {}

    def define(self, name: str, node: ast.ASTNode, params: t.Sequence[str]) -&gt; None:
        &#34;&#34;&#34;
        Defines a new call implemented with Scrolls code. See `RuntimeCall`.
        &#34;&#34;&#34;
        collect_param: t.Optional[str] = None

        if params and params[-1].startswith(&#34;*&#34;):
            collect_param = params[-1][1:]
            params = params[:-1]

        call = RuntimeCall(
            name,
            node,
            params,
            collect_param
        )

        self.calls[name] = call

    def undefine(self, name: str) -&gt; None:
        &#34;&#34;&#34;
        Delete a defined runtime call.
        &#34;&#34;&#34;
        del self.calls[name]

    def handle_call(self, context: InterpreterContext) -&gt; T_co:
        call = self.calls[context.call_name]

        # Arg length check
        if call.collect_param is None:
            if len(call.params) != len(context.args):
                raise InterpreterError(
                    context,
                    f&#34;{context.call_name}: Invalid # of arguments (expected {len(call.params)})&#34;
                )
        else:
            if len(context.args) &lt; len(call.params) - 1:
                raise InterpreterError(
                    context,
                    f&#34;{context.call_name}: Invalid # of arguments (expected at least {len(call.params)})&#34;
                )

        params = list(call.params)

        if call.collect_param is None:
            args = context.args
        else:
            params.append(call.collect_param)
            collected = context.args[len(call.params):]
            args = list(context.args[:len(call.params)])
            args.append(&#34; &#34;.join(collected))

        # New scope must be created. We&#39;re running Scrolls code to implement this call, so it might trample
        # what&#39;s been defined otherwise. Plus, we don&#39;t want our call arguments to continue existing
        # after we&#39;re done.
        context.vars.new_scope()
        for param, arg in zip(params, args):
            context.set_var(param, arg)

        context.call_context.runtime_call = True
        try:
            # Interpret the body of the call.
            context.interpreter.interpret_statement(context, call.node)
        except InterpreterReturn:
            pass

        context.vars.destroy_scope()

        # TODO Fix typing here
        return t.cast(T_co, context.call_context.return_value)

    def __contains__(self, command_name: str) -&gt; bool:
        return command_name in self.calls</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.RuntimeCallHandler.define"><code class="name flex">
<span>def <span class="ident">define</span></span>(<span>self, name:Â str, node:Â <a title="scrolls.ast.ASTNode" href="ast.html#scrolls.ast.ASTNode">ASTNode</a>, params:Â Sequence[str]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a new call implemented with Scrolls code. See <code><a title="scrolls.interpreter.RuntimeCall" href="#scrolls.interpreter.RuntimeCall">RuntimeCall</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define(self, name: str, node: ast.ASTNode, params: t.Sequence[str]) -&gt; None:
    &#34;&#34;&#34;
    Defines a new call implemented with Scrolls code. See `RuntimeCall`.
    &#34;&#34;&#34;
    collect_param: t.Optional[str] = None

    if params and params[-1].startswith(&#34;*&#34;):
        collect_param = params[-1][1:]
        params = params[:-1]

    call = RuntimeCall(
        name,
        node,
        params,
        collect_param
    )

    self.calls[name] = call</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.RuntimeCallHandler.handle_call"><code class="name flex">
<span>def <span class="ident">handle_call</span></span>(<span>self, context:Â <a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a>) â€‘>Â +T_co</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_call(self, context: InterpreterContext) -&gt; T_co:
    call = self.calls[context.call_name]

    # Arg length check
    if call.collect_param is None:
        if len(call.params) != len(context.args):
            raise InterpreterError(
                context,
                f&#34;{context.call_name}: Invalid # of arguments (expected {len(call.params)})&#34;
            )
    else:
        if len(context.args) &lt; len(call.params) - 1:
            raise InterpreterError(
                context,
                f&#34;{context.call_name}: Invalid # of arguments (expected at least {len(call.params)})&#34;
            )

    params = list(call.params)

    if call.collect_param is None:
        args = context.args
    else:
        params.append(call.collect_param)
        collected = context.args[len(call.params):]
        args = list(context.args[:len(call.params)])
        args.append(&#34; &#34;.join(collected))

    # New scope must be created. We&#39;re running Scrolls code to implement this call, so it might trample
    # what&#39;s been defined otherwise. Plus, we don&#39;t want our call arguments to continue existing
    # after we&#39;re done.
    context.vars.new_scope()
    for param, arg in zip(params, args):
        context.set_var(param, arg)

    context.call_context.runtime_call = True
    try:
        # Interpret the body of the call.
        context.interpreter.interpret_statement(context, call.node)
    except InterpreterReturn:
        pass

    context.vars.destroy_scope()

    # TODO Fix typing here
    return t.cast(T_co, context.call_context.return_value)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.RuntimeCallHandler.undefine"><code class="name flex">
<span>def <span class="ident">undefine</span></span>(<span>self, name:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a defined runtime call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undefine(self, name: str) -&gt; None:
    &#34;&#34;&#34;
    Delete a defined runtime call.
    &#34;&#34;&#34;
    del self.calls[name]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore"><code class="flex name class">
<span>class <span class="ident">ScopedVarStore</span></span>
</code></dt>
<dd>
<div class="desc"><p>A variable store divided into a stack of key-value pairs.</p>
<p>This class is used to implement the concept of local vs global variables in scrolls. Runtime calls (see
<code><a title="scrolls.interpreter.CallContext" href="#scrolls.interpreter.CallContext">CallContext</a></code>) use scoped variable stores to allow the definition of local variables in call defs without
stepping on existing variables.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Calls implemented in Python do not enter a new variable scope by default. You typically won't need to enter
a new scope unless you run Scrolls code during a call, i.e. for control calls, and runtime-defined calls.</p>
<p>Most control calls, such as <code>while</code>, <code>for</code>, <code>if</code>, etc. do not need to define a new variable scope. The option
is available if desired. See the source code of <code><a title="scrolls.interpreter.RuntimeCallHandler.handle_call" href="#scrolls.interpreter.RuntimeCallHandler.handle_call">RuntimeCallHandler.handle_call()</a></code> for an example of defining
a new scope.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScopedVarStore:
    &#34;&#34;&#34;
    A variable store divided into a stack of key-value pairs.

    This class is used to implement the concept of local vs global variables in scrolls. Runtime calls (see
    `CallContext`) use scoped variable stores to allow the definition of local variables in call defs without
    stepping on existing variables.

    .. IMPORTANT::
        Calls implemented in Python do not enter a new variable scope by default. You typically won&#39;t need to enter
        a new scope unless you run Scrolls code during a call, i.e. for control calls, and runtime-defined calls.

        Most control calls, such as `while`, `for`, `if`, etc. do not need to define a new variable scope. The option
        is available if desired. See the source code of `RuntimeCallHandler.handle_call` for an example of defining
        a new scope.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        self.scopes: t.MutableSequence[VarScope] = []
        &#34;&#34;&#34;The `VarScope` stack. Later indices are deeper scopes. `scopes[0]` is the global scope, which is always available.&#34;&#34;&#34;

        self.new_scope()  # There should always be one scope.

    def new_scope(self) -&gt; None:
        &#34;&#34;&#34;
        Push a new scope onto the stack.
        &#34;&#34;&#34;
        self.scopes.append(VarScope())

    def destroy_scope(self) -&gt; None:
        &#34;&#34;&#34;
        Destroy the current scope and return to the last one. This will delete all local variables defined in the current
        scope.
        &#34;&#34;&#34;
        if len(self.scopes) == 1:
            # there should always be at least one scope
            raise ValueError(&#34;There must be at least one scope.&#34;)

        self.scopes.pop()

    def declare_nonlocal(self, name: str) -&gt; None:
        &#34;&#34;&#34;
        Declare a variable as nonlocal. This means that all attempts to read/write the variable will automatically
        go to the enclosing scope.
        &#34;&#34;&#34;
        self.current_scope.nonlocals[name] = True

    def declare_global(self, name: str) -&gt; None:
        &#34;&#34;&#34;
        Declare a variable as global. This means all attempts to read/write the variable will automatically go to
        the global scope.
        &#34;&#34;&#34;
        self.current_scope.globals[name] = True

    def search_scope(self, name: str, scopes: t.Sequence[VarScope], read_search: bool = False) -&gt; VarScope:
        &#34;&#34;&#34;
        Using a variable name, search up the scope stack for something to read/write. This search will honor nonlocal
        and global declarations made for all scopes.

        Args:
            name: The name of the variable to search for.

            scopes: The scopes to search. Typically, this will be `ScopedVarStore.scopes`.

            read_search: Must be `True` if no writes will be performed on the scope you&#39;re searching for.
            Adds additional logic that reads the global store as a fallback if a defined value could not be found
            after searching up the stack.

        Raises:
            KeyError: If an appropriate scope could not be found.
        &#34;&#34;&#34;
        scopes = list(scopes)
        scope = scopes[-1]

        while scopes:
            scope = scopes.pop()

            if name in scope.globals:
                # If global, immediately go to the highest scope
                return scopes[0] if scopes else scope

            if name in scope.nonlocals:
                # If nonlocal, go to the enclosing scope.
                continue

            # Just break as soon as we step off global/nonlocal references.
            break

        if read_search:
            # Do a little bit of extra logic for a read search. If we can&#39;t find a value in the
            # current scope, try globals as a fallback.
            if name in scope.vars:
                return scope
            elif scopes and name in scopes[0].vars:
                return scopes[0]
            else:
                raise KeyError(name)

        return scope

    def get_scope_for_read(self, name: str) -&gt; VarScope:
        &#34;&#34;&#34;Shortcut for `ScopedVarStore.search_scope(..., read_search=True)`

        See Also: `ScopedVarStore.search_scope`
        &#34;&#34;&#34;
        return self.search_scope(name, self.scopes, read_search=True)

    def get_scope_for_write(self, name: str) -&gt; VarScope:
        &#34;&#34;&#34;Shortcut for `ScopedVarStore.search_scope(..., read_search=False)`

        See Also: `ScopedVarStore.search_scope`
        &#34;&#34;&#34;
        return self.search_scope(name, self.scopes, read_search=False)

    @property
    def current_scope(self) -&gt; VarScope:
        &#34;&#34;&#34;The current scope.&#34;&#34;&#34;
        return self.scopes[-1]

    def get_var(self, name: str) -&gt; str:
        &#34;&#34;&#34;Get a variable from this store, following all nonlocal and global declarations.&#34;&#34;&#34;
        return self.get_scope_for_read(name).vars[name]

    def set_var(self, name: str, value: str) -&gt; None:
        &#34;&#34;&#34;Set a variable in this store, following all nonlocal and global declarations.&#34;&#34;&#34;
        try:
            scope = self.get_scope_for_write(name)
            scope.vars[name] = value
        except KeyError:
            self.current_scope.vars[name] = value

    def del_var(self, name: str) -&gt; None:
        &#34;&#34;&#34;Delete a variable from this store, following all nonlocal and global declarations.&#34;&#34;&#34;
        try:
            scope = self.get_scope_for_write(name)
            del scope.vars[name]
        except KeyError:
            del self.current_scope.vars[name]</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="scrolls.interpreter.ScopedVarStore.current_scope"><code class="name">var <span class="ident">current_scope</span> :Â <a title="scrolls.interpreter.VarScope" href="#scrolls.interpreter.VarScope">VarScope</a></code></dt>
<dd>
<div class="desc"><p>The current scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def current_scope(self) -&gt; VarScope:
    &#34;&#34;&#34;The current scope.&#34;&#34;&#34;
    return self.scopes[-1]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore.scopes"><code class="name">var <span class="ident">scopes</span></code></dt>
<dd>
<div class="desc"><p>The <code><a title="scrolls.interpreter.VarScope" href="#scrolls.interpreter.VarScope">VarScope</a></code> stack. Later indices are deeper scopes. <code>scopes[0]</code> is the global scope, which is always available.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrolls.interpreter.ScopedVarStore.declare_global"><code class="name flex">
<span>def <span class="ident">declare_global</span></span>(<span>self, name:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Declare a variable as global. This means all attempts to read/write the variable will automatically go to
the global scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_global(self, name: str) -&gt; None:
    &#34;&#34;&#34;
    Declare a variable as global. This means all attempts to read/write the variable will automatically go to
    the global scope.
    &#34;&#34;&#34;
    self.current_scope.globals[name] = True</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore.declare_nonlocal"><code class="name flex">
<span>def <span class="ident">declare_nonlocal</span></span>(<span>self, name:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Declare a variable as nonlocal. This means that all attempts to read/write the variable will automatically
go to the enclosing scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_nonlocal(self, name: str) -&gt; None:
    &#34;&#34;&#34;
    Declare a variable as nonlocal. This means that all attempts to read/write the variable will automatically
    go to the enclosing scope.
    &#34;&#34;&#34;
    self.current_scope.nonlocals[name] = True</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore.del_var"><code class="name flex">
<span>def <span class="ident">del_var</span></span>(<span>self, name:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a variable from this store, following all nonlocal and global declarations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_var(self, name: str) -&gt; None:
    &#34;&#34;&#34;Delete a variable from this store, following all nonlocal and global declarations.&#34;&#34;&#34;
    try:
        scope = self.get_scope_for_write(name)
        del scope.vars[name]
    except KeyError:
        del self.current_scope.vars[name]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore.destroy_scope"><code class="name flex">
<span>def <span class="ident">destroy_scope</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Destroy the current scope and return to the last one. This will delete all local variables defined in the current
scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy_scope(self) -&gt; None:
    &#34;&#34;&#34;
    Destroy the current scope and return to the last one. This will delete all local variables defined in the current
    scope.
    &#34;&#34;&#34;
    if len(self.scopes) == 1:
        # there should always be at least one scope
        raise ValueError(&#34;There must be at least one scope.&#34;)

    self.scopes.pop()</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore.get_scope_for_read"><code class="name flex">
<span>def <span class="ident">get_scope_for_read</span></span>(<span>self, name:Â str) â€‘>Â <a title="scrolls.interpreter.VarScope" href="#scrolls.interpreter.VarScope">VarScope</a></span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut for <code>ScopedVarStore.search_scope(..., read_search=True)</code></p>
<p>See Also: <code><a title="scrolls.interpreter.ScopedVarStore.search_scope" href="#scrolls.interpreter.ScopedVarStore.search_scope">ScopedVarStore.search_scope()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scope_for_read(self, name: str) -&gt; VarScope:
    &#34;&#34;&#34;Shortcut for `ScopedVarStore.search_scope(..., read_search=True)`

    See Also: `ScopedVarStore.search_scope`
    &#34;&#34;&#34;
    return self.search_scope(name, self.scopes, read_search=True)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore.get_scope_for_write"><code class="name flex">
<span>def <span class="ident">get_scope_for_write</span></span>(<span>self, name:Â str) â€‘>Â <a title="scrolls.interpreter.VarScope" href="#scrolls.interpreter.VarScope">VarScope</a></span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut for <code>ScopedVarStore.search_scope(..., read_search=False)</code></p>
<p>See Also: <code><a title="scrolls.interpreter.ScopedVarStore.search_scope" href="#scrolls.interpreter.ScopedVarStore.search_scope">ScopedVarStore.search_scope()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scope_for_write(self, name: str) -&gt; VarScope:
    &#34;&#34;&#34;Shortcut for `ScopedVarStore.search_scope(..., read_search=False)`

    See Also: `ScopedVarStore.search_scope`
    &#34;&#34;&#34;
    return self.search_scope(name, self.scopes, read_search=False)</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore.get_var"><code class="name flex">
<span>def <span class="ident">get_var</span></span>(<span>self, name:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Get a variable from this store, following all nonlocal and global declarations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_var(self, name: str) -&gt; str:
    &#34;&#34;&#34;Get a variable from this store, following all nonlocal and global declarations.&#34;&#34;&#34;
    return self.get_scope_for_read(name).vars[name]</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore.new_scope"><code class="name flex">
<span>def <span class="ident">new_scope</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Push a new scope onto the stack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_scope(self) -&gt; None:
    &#34;&#34;&#34;
    Push a new scope onto the stack.
    &#34;&#34;&#34;
    self.scopes.append(VarScope())</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore.search_scope"><code class="name flex">
<span>def <span class="ident">search_scope</span></span>(<span>self, name:Â str, scopes:Â Sequence[<a title="scrolls.interpreter.VarScope" href="#scrolls.interpreter.VarScope">VarScope</a>], read_search:Â boolÂ =Â False) â€‘>Â <a title="scrolls.interpreter.VarScope" href="#scrolls.interpreter.VarScope">VarScope</a></span>
</code></dt>
<dd>
<div class="desc"><p>Using a variable name, search up the scope stack for something to read/write. This search will honor nonlocal
and global declarations made for all scopes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the variable to search for.</dd>
<dt><strong><code>scopes</code></strong></dt>
<dd>The scopes to search. Typically, this will be <code><a title="scrolls.interpreter.ScopedVarStore.scopes" href="#scrolls.interpreter.ScopedVarStore.scopes">ScopedVarStore.scopes</a></code>.</dd>
<dt><strong><code>read_search</code></strong></dt>
<dd>Must be <code>True</code> if no writes will be performed on the scope you're searching for.</dd>
</dl>
<p>Adds additional logic that reads the global store as a fallback if a defined value could not be found
after searching up the stack.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>If an appropriate scope could not be found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_scope(self, name: str, scopes: t.Sequence[VarScope], read_search: bool = False) -&gt; VarScope:
    &#34;&#34;&#34;
    Using a variable name, search up the scope stack for something to read/write. This search will honor nonlocal
    and global declarations made for all scopes.

    Args:
        name: The name of the variable to search for.

        scopes: The scopes to search. Typically, this will be `ScopedVarStore.scopes`.

        read_search: Must be `True` if no writes will be performed on the scope you&#39;re searching for.
        Adds additional logic that reads the global store as a fallback if a defined value could not be found
        after searching up the stack.

    Raises:
        KeyError: If an appropriate scope could not be found.
    &#34;&#34;&#34;
    scopes = list(scopes)
    scope = scopes[-1]

    while scopes:
        scope = scopes.pop()

        if name in scope.globals:
            # If global, immediately go to the highest scope
            return scopes[0] if scopes else scope

        if name in scope.nonlocals:
            # If nonlocal, go to the enclosing scope.
            continue

        # Just break as soon as we step off global/nonlocal references.
        break

    if read_search:
        # Do a little bit of extra logic for a read search. If we can&#39;t find a value in the
        # current scope, try globals as a fallback.
        if name in scope.vars:
            return scope
        elif scopes and name in scopes[0].vars:
            return scopes[0]
        else:
            raise KeyError(name)

    return scope</code></pre>
</details>
</dd>
<dt id="scrolls.interpreter.ScopedVarStore.set_var"><code class="name flex">
<span>def <span class="ident">set_var</span></span>(<span>self, name:Â str, value:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Set a variable in this store, following all nonlocal and global declarations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_var(self, name: str, value: str) -&gt; None:
    &#34;&#34;&#34;Set a variable in this store, following all nonlocal and global declarations.&#34;&#34;&#34;
    try:
        scope = self.get_scope_for_write(name)
        scope.vars[name] = value
    except KeyError:
        self.current_scope.vars[name] = value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrolls.interpreter.ScrollCallback"><code class="flex name class">
<span>class <span class="ident">ScrollCallback</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol for Callbacks passed into CallbackCallHandlers.</p>
<p>A <code><a title="scrolls.interpreter.ScrollCallback" href="#scrolls.interpreter.ScrollCallback">ScrollCallback</a></code> is any <code>typing.Callable</code> that takes an <code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code> or subclass as its only parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScrollCallback(t.Protocol[T_co]):
    &#34;&#34;&#34;
    Protocol for Callbacks passed into CallbackCallHandlers.

    A `ScrollCallback` is any `typing.Callable` that takes an `InterpreterContext` or subclass as its only parameter.
    &#34;&#34;&#34;
    def __call__(self, context: AnyContextTV) -&gt; T_co: ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="scrolls.interpreter.VarScope"><code class="flex name class">
<span>class <span class="ident">VarScope</span></span>
</code></dt>
<dd>
<div class="desc"><p>A variable scope. See <code><a title="scrolls.interpreter.ScopedVarStore" href="#scrolls.interpreter.ScopedVarStore">ScopedVarStore</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VarScope:
    &#34;&#34;&#34;
    A variable scope. See `ScopedVarStore`.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        self.vars: t.MutableMapping[str, str] = {}
        &#34;&#34;&#34;The local variables defined in this scope.
        
        .. NOTE::
            Generally this should not be modified directly, use `ScopedVarStore.set_var` instead.
        &#34;&#34;&#34;

        self.nonlocals: t.MutableMapping[str, bool] = {}
        &#34;&#34;&#34;Nonlocal variables defined in this scope.
        
        If a variable is declared nonlocal, attempts to read/write it will go to the enclosing scope.
        
        .. NOTE::
            Generally this should not be modified directly, use `ScopedVarStore.declare_nonlocal` instead.
        &#34;&#34;&#34;

        self.globals: t.MutableMapping[str, bool] = {}
        &#34;&#34;&#34;Global variables defined in this scope.
        
        If a variable is declared global, attempts to read/write it will go to the global (top level) variable scope.
        
        .. NOTE::
            Generally this should not be modified directly, use `ScopedVarStore.declare_global` instead.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="scrolls.interpreter.VarScope.globals"><code class="name">var <span class="ident">globals</span></code></dt>
<dd>
<div class="desc"><p>Global variables defined in this scope.</p>
<p>If a variable is declared global, attempts to read/write it will go to the global (top level) variable scope.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generally this should not be modified directly, use <code><a title="scrolls.interpreter.ScopedVarStore.declare_global" href="#scrolls.interpreter.ScopedVarStore.declare_global">ScopedVarStore.declare_global()</a></code> instead.</p>
</div></div>
</dd>
<dt id="scrolls.interpreter.VarScope.nonlocals"><code class="name">var <span class="ident">nonlocals</span></code></dt>
<dd>
<div class="desc"><p>Nonlocal variables defined in this scope.</p>
<p>If a variable is declared nonlocal, attempts to read/write it will go to the enclosing scope.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generally this should not be modified directly, use <code><a title="scrolls.interpreter.ScopedVarStore.declare_nonlocal" href="#scrolls.interpreter.ScopedVarStore.declare_nonlocal">ScopedVarStore.declare_nonlocal()</a></code> instead.</p>
</div></div>
</dd>
<dt id="scrolls.interpreter.VarScope.vars"><code class="name">var <span class="ident">vars</span></code></dt>
<dd>
<div class="desc"><p>The local variables defined in this scope.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generally this should not be modified directly, use <code><a title="scrolls.interpreter.ScopedVarStore.set_var" href="#scrolls.interpreter.ScopedVarStore.set_var">ScopedVarStore.set_var()</a></code> instead.</p>
</div></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#using-the-interpreter">Using the Interpreter</a><ul>
<li><a href="#quickstart">Quickstart</a></li>
<li><a href="#extensions">Extensions</a><ul>
<li><a href="#call-types">Call Types</a><ul>
<li><a href="#command-calls">Command Calls</a></li>
<li><a href="#expansion-calls">Expansion Calls</a></li>
<li><a href="#control-calls">Control Calls</a></li>
</ul>
</li>
<li><a href="#implementing-call-handlers">Implementing Call Handlers</a></li>
<li><a href="#using-callbackcallhandler">Using CallbackCallHandler</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrolls" href="index.html">scrolls</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="scrolls.interpreter.CallbackCommandHandler" href="#scrolls.interpreter.CallbackCommandHandler">CallbackCommandHandler</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackControlHandler" href="#scrolls.interpreter.CallbackControlHandler">CallbackControlHandler</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackExpansionHandler" href="#scrolls.interpreter.CallbackExpansionHandler">CallbackExpansionHandler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrolls.interpreter.ArgSourceMap" href="#scrolls.interpreter.ArgSourceMap">ArgSourceMap</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.ArgSourceMap.add_args" href="#scrolls.interpreter.ArgSourceMap.add_args">add_args</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.BaseCallHandlerContainer" href="#scrolls.interpreter.BaseCallHandlerContainer">BaseCallHandlerContainer</a></code></h4>
<ul class="two-column">
<li><code><a title="scrolls.interpreter.BaseCallHandlerContainer.add" href="#scrolls.interpreter.BaseCallHandlerContainer.add">add</a></code></li>
<li><code><a title="scrolls.interpreter.BaseCallHandlerContainer.add_all" href="#scrolls.interpreter.BaseCallHandlerContainer.add_all">add_all</a></code></li>
<li><code><a title="scrolls.interpreter.BaseCallHandlerContainer.find" href="#scrolls.interpreter.BaseCallHandlerContainer.find">find</a></code></li>
<li><code><a title="scrolls.interpreter.BaseCallHandlerContainer.get" href="#scrolls.interpreter.BaseCallHandlerContainer.get">get</a></code></li>
<li><code><a title="scrolls.interpreter.BaseCallHandlerContainer.get_for_call" href="#scrolls.interpreter.BaseCallHandlerContainer.get_for_call">get_for_call</a></code></li>
<li><code><a title="scrolls.interpreter.BaseCallHandlerContainer.remove" href="#scrolls.interpreter.BaseCallHandlerContainer.remove">remove</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.CallContext" href="#scrolls.interpreter.CallContext">CallContext</a></code></h4>
<ul class="two-column">
<li><code><a title="scrolls.interpreter.CallContext.arg_nodes" href="#scrolls.interpreter.CallContext.arg_nodes">arg_nodes</a></code></li>
<li><code><a title="scrolls.interpreter.CallContext.args" href="#scrolls.interpreter.CallContext.args">args</a></code></li>
<li><code><a title="scrolls.interpreter.CallContext.call_name" href="#scrolls.interpreter.CallContext.call_name">call_name</a></code></li>
<li><code><a title="scrolls.interpreter.CallContext.control_node" href="#scrolls.interpreter.CallContext.control_node">control_node</a></code></li>
<li><code><a title="scrolls.interpreter.CallContext.return_value" href="#scrolls.interpreter.CallContext.return_value">return_value</a></code></li>
<li><code><a title="scrolls.interpreter.CallContext.runtime_call" href="#scrolls.interpreter.CallContext.runtime_call">runtime_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.CallHandler" href="#scrolls.interpreter.CallHandler">CallHandler</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.CallHandler.handle_call" href="#scrolls.interpreter.CallHandler.handle_call">handle_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.CallHandlerContainer" href="#scrolls.interpreter.CallHandlerContainer">CallHandlerContainer</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.CallHandlerContainer.get" href="#scrolls.interpreter.CallHandlerContainer.get">get</a></code></li>
<li><code><a title="scrolls.interpreter.CallHandlerContainer.get_for_call" href="#scrolls.interpreter.CallHandlerContainer.get_for_call">get_for_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.CallbackCallHandler" href="#scrolls.interpreter.CallbackCallHandler">CallbackCallHandler</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_alias" href="#scrolls.interpreter.CallbackCallHandler.add_alias">add_alias</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.add_call" href="#scrolls.interpreter.CallbackCallHandler.add_call">add_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.get_callback" href="#scrolls.interpreter.CallbackCallHandler.get_callback">get_callback</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.handle_call" href="#scrolls.interpreter.CallbackCallHandler.handle_call">handle_call</a></code></li>
<li><code><a title="scrolls.interpreter.CallbackCallHandler.remove_call" href="#scrolls.interpreter.CallbackCallHandler.remove_call">remove_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.ChoiceCallHandlerContainer" href="#scrolls.interpreter.ChoiceCallHandlerContainer">ChoiceCallHandlerContainer</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.ChoiceCallHandlerContainer.get" href="#scrolls.interpreter.ChoiceCallHandlerContainer.get">get</a></code></li>
<li><code><a title="scrolls.interpreter.ChoiceCallHandlerContainer.get_for_call" href="#scrolls.interpreter.ChoiceCallHandlerContainer.get_for_call">get_for_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.Initializer" href="#scrolls.interpreter.Initializer">Initializer</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.Initializer.handle_call" href="#scrolls.interpreter.Initializer.handle_call">handle_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.InternalInterpreterError" href="#scrolls.interpreter.InternalInterpreterError">InternalInterpreterError</a></code></h4>
</li>
<li>
<h4><code><a title="scrolls.interpreter.Interpreter" href="#scrolls.interpreter.Interpreter">Interpreter</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.Interpreter.apply_initializers" href="#scrolls.interpreter.Interpreter.apply_initializers">apply_initializers</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.command_handlers" href="#scrolls.interpreter.Interpreter.command_handlers">command_handlers</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.context_cls" href="#scrolls.interpreter.Interpreter.context_cls">context_cls</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.control_handlers" href="#scrolls.interpreter.Interpreter.control_handlers">control_handlers</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.expansion_handlers" href="#scrolls.interpreter.Interpreter.expansion_handlers">expansion_handlers</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.init_context" href="#scrolls.interpreter.Interpreter.init_context">init_context</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.initializers" href="#scrolls.interpreter.Interpreter.initializers">initializers</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_ast" href="#scrolls.interpreter.Interpreter.interpret_ast">interpret_ast</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_block" href="#scrolls.interpreter.Interpreter.interpret_block">interpret_block</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_call" href="#scrolls.interpreter.Interpreter.interpret_call">interpret_call</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_command" href="#scrolls.interpreter.Interpreter.interpret_command">interpret_command</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_control" href="#scrolls.interpreter.Interpreter.interpret_control">interpret_control</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_expansion" href="#scrolls.interpreter.Interpreter.interpret_expansion">interpret_expansion</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_expansion_call" href="#scrolls.interpreter.Interpreter.interpret_expansion_call">interpret_expansion_call</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_root" href="#scrolls.interpreter.Interpreter.interpret_root">interpret_root</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_statement" href="#scrolls.interpreter.Interpreter.interpret_statement">interpret_statement</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_string_or_expansion" href="#scrolls.interpreter.Interpreter.interpret_string_or_expansion">interpret_string_or_expansion</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_sub_expansion" href="#scrolls.interpreter.Interpreter.interpret_sub_expansion">interpret_sub_expansion</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.interpret_variable_reference" href="#scrolls.interpreter.Interpreter.interpret_variable_reference">interpret_variable_reference</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.over_call_depth_limit" href="#scrolls.interpreter.Interpreter.over_call_depth_limit">over_call_depth_limit</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.over_statement_limit" href="#scrolls.interpreter.Interpreter.over_statement_limit">over_statement_limit</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.repl" href="#scrolls.interpreter.Interpreter.repl">repl</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.run" href="#scrolls.interpreter.Interpreter.run">run</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.run_statement" href="#scrolls.interpreter.Interpreter.run_statement">run_statement</a></code></li>
<li><code><a title="scrolls.interpreter.Interpreter.test_parse" href="#scrolls.interpreter.Interpreter.test_parse">test_parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.InterpreterContext" href="#scrolls.interpreter.InterpreterContext">InterpreterContext</a></code></h4>
<ul class="two-column">
<li><code><a title="scrolls.interpreter.InterpreterContext.arg_nodes" href="#scrolls.interpreter.InterpreterContext.arg_nodes">arg_nodes</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.args" href="#scrolls.interpreter.InterpreterContext.args">args</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.call_context" href="#scrolls.interpreter.InterpreterContext.call_context">call_context</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.call_name" href="#scrolls.interpreter.InterpreterContext.call_name">call_name</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.call_stack" href="#scrolls.interpreter.InterpreterContext.call_stack">call_stack</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.close_file" href="#scrolls.interpreter.InterpreterContext.close_file">close_file</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.control_node" href="#scrolls.interpreter.InterpreterContext.control_node">control_node</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.current_node" href="#scrolls.interpreter.InterpreterContext.current_node">current_node</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.del_var" href="#scrolls.interpreter.InterpreterContext.del_var">del_var</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.get_file" href="#scrolls.interpreter.InterpreterContext.get_file">get_file</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.get_var" href="#scrolls.interpreter.InterpreterContext.get_var">get_var</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.in_call" href="#scrolls.interpreter.InterpreterContext.in_call">in_call</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.interpreter" href="#scrolls.interpreter.InterpreterContext.interpreter">interpreter</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.open_file" href="#scrolls.interpreter.InterpreterContext.open_file">open_file</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.pop_call" href="#scrolls.interpreter.InterpreterContext.pop_call">pop_call</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.push_call" href="#scrolls.interpreter.InterpreterContext.push_call">push_call</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.reset_call" href="#scrolls.interpreter.InterpreterContext.reset_call">reset_call</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.runtime_commands" href="#scrolls.interpreter.InterpreterContext.runtime_commands">runtime_commands</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.runtime_expansions" href="#scrolls.interpreter.InterpreterContext.runtime_expansions">runtime_expansions</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.set_call" href="#scrolls.interpreter.InterpreterContext.set_call">set_call</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.set_retval" href="#scrolls.interpreter.InterpreterContext.set_retval">set_retval</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.set_var" href="#scrolls.interpreter.InterpreterContext.set_var">set_var</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.statement_count" href="#scrolls.interpreter.InterpreterContext.statement_count">statement_count</a></code></li>
<li><code><a title="scrolls.interpreter.InterpreterContext.vars" href="#scrolls.interpreter.InterpreterContext.vars">vars</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.InterpreterError" href="#scrolls.interpreter.InterpreterError">InterpreterError</a></code></h4>
</li>
<li>
<h4><code><a title="scrolls.interpreter.InterpreterReturn" href="#scrolls.interpreter.InterpreterReturn">InterpreterReturn</a></code></h4>
</li>
<li>
<h4><code><a title="scrolls.interpreter.InterpreterStop" href="#scrolls.interpreter.InterpreterStop">InterpreterStop</a></code></h4>
</li>
<li>
<h4><code><a title="scrolls.interpreter.MutableCallHandlerContainer" href="#scrolls.interpreter.MutableCallHandlerContainer">MutableCallHandlerContainer</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.MutableCallHandlerContainer.add" href="#scrolls.interpreter.MutableCallHandlerContainer.add">add</a></code></li>
<li><code><a title="scrolls.interpreter.MutableCallHandlerContainer.remove" href="#scrolls.interpreter.MutableCallHandlerContainer.remove">remove</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.RuntimeCall" href="#scrolls.interpreter.RuntimeCall">RuntimeCall</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.RuntimeCall.collect_param" href="#scrolls.interpreter.RuntimeCall.collect_param">collect_param</a></code></li>
<li><code><a title="scrolls.interpreter.RuntimeCall.name" href="#scrolls.interpreter.RuntimeCall.name">name</a></code></li>
<li><code><a title="scrolls.interpreter.RuntimeCall.node" href="#scrolls.interpreter.RuntimeCall.node">node</a></code></li>
<li><code><a title="scrolls.interpreter.RuntimeCall.params" href="#scrolls.interpreter.RuntimeCall.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.RuntimeCallHandler" href="#scrolls.interpreter.RuntimeCallHandler">RuntimeCallHandler</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.RuntimeCallHandler.define" href="#scrolls.interpreter.RuntimeCallHandler.define">define</a></code></li>
<li><code><a title="scrolls.interpreter.RuntimeCallHandler.handle_call" href="#scrolls.interpreter.RuntimeCallHandler.handle_call">handle_call</a></code></li>
<li><code><a title="scrolls.interpreter.RuntimeCallHandler.undefine" href="#scrolls.interpreter.RuntimeCallHandler.undefine">undefine</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.ScopedVarStore" href="#scrolls.interpreter.ScopedVarStore">ScopedVarStore</a></code></h4>
<ul class="two-column">
<li><code><a title="scrolls.interpreter.ScopedVarStore.current_scope" href="#scrolls.interpreter.ScopedVarStore.current_scope">current_scope</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.declare_global" href="#scrolls.interpreter.ScopedVarStore.declare_global">declare_global</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.declare_nonlocal" href="#scrolls.interpreter.ScopedVarStore.declare_nonlocal">declare_nonlocal</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.del_var" href="#scrolls.interpreter.ScopedVarStore.del_var">del_var</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.destroy_scope" href="#scrolls.interpreter.ScopedVarStore.destroy_scope">destroy_scope</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.get_scope_for_read" href="#scrolls.interpreter.ScopedVarStore.get_scope_for_read">get_scope_for_read</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.get_scope_for_write" href="#scrolls.interpreter.ScopedVarStore.get_scope_for_write">get_scope_for_write</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.get_var" href="#scrolls.interpreter.ScopedVarStore.get_var">get_var</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.new_scope" href="#scrolls.interpreter.ScopedVarStore.new_scope">new_scope</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.scopes" href="#scrolls.interpreter.ScopedVarStore.scopes">scopes</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.search_scope" href="#scrolls.interpreter.ScopedVarStore.search_scope">search_scope</a></code></li>
<li><code><a title="scrolls.interpreter.ScopedVarStore.set_var" href="#scrolls.interpreter.ScopedVarStore.set_var">set_var</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrolls.interpreter.ScrollCallback" href="#scrolls.interpreter.ScrollCallback">ScrollCallback</a></code></h4>
</li>
<li>
<h4><code><a title="scrolls.interpreter.VarScope" href="#scrolls.interpreter.VarScope">VarScope</a></code></h4>
<ul class="">
<li><code><a title="scrolls.interpreter.VarScope.globals" href="#scrolls.interpreter.VarScope.globals">globals</a></code></li>
<li><code><a title="scrolls.interpreter.VarScope.nonlocals" href="#scrolls.interpreter.VarScope.nonlocals">nonlocals</a></code></li>
<li><code><a title="scrolls.interpreter.VarScope.vars" href="#scrolls.interpreter.VarScope.vars">vars</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>